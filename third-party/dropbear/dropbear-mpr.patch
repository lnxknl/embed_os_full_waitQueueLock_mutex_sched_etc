diff -aur dropbear-2022.83/Makefile.in ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/Makefile.in
--- dropbear-2022.83/Makefile.in	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/Makefile.in	2023-08-09 16:05:01.036016295 +0600
@@ -9,9 +9,12 @@
 # dbclient functionality, and includes the progress-bar functionality in scp.
 
 ifndef PROGRAMS
-	PROGRAMS=dropbear dbclient dropbearkey dropbearconvert
+	PROGRAMS=dropbear #dbclient dropbearkey dropbearconvert
 endif
 
+CPPFLAGS+=-DDROPBEAR_EMBOX_BUILD
+CFLAGS+=-I$(EMBOX_ROOT)/src/include/
+
 STATIC_LTC=libtomcrypt/libtomcrypt.a
 STATIC_LTM=libtommath/libtommath.a
 
@@ -38,7 +41,8 @@
 		ltc_prng.o ecc.o ecdsa.o sk-ecdsa.o crypto_desc.o \
 		curve25519.o ed25519.o sk-ed25519.o \
 		dbmalloc.o \
-		gensignkey.o gendss.o genrsa.o gened25519.o
+		gensignkey.o gendss.o genrsa.o gened25519.o embox_drpbr.o
+		
 
 SVROBJS=svr-kex.o svr-auth.o sshpty.o \
 		svr-authpasswd.o svr-authpubkey.o svr-authpubkeyoptions.o svr-session.o svr-service.o \
@@ -120,6 +124,7 @@
 # evilness so we detect 'dropbear' by itself as a word
 ifneq (,$(strip $(foreach prog, $(PROGRAMS), $(findstring ZdropbearZ, Z$(prog)Z))))
 	CPPFLAGS+= -DDROPBEAR_SERVER
+	CPPFLAGS+= -DDROPBEAR_CLIENT=0
 endif
 ifneq (,$(strip $(foreach prog, $(PROGRAMS), $(findstring ZdbclientZ, Z$(prog)Z))))
 	CPPFLAGS+= -DDROPBEAR_CLIENT
diff -aur dropbear-2022.83/cli-agentfwd.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-agentfwd.c
--- dropbear-2022.83/cli-agentfwd.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-agentfwd.c	2023-08-09 16:05:01.036016295 +0600
@@ -89,7 +89,7 @@
 
 	setnonblocking(fd);
 
-	ses.maxfd = MAX(ses.maxfd, fd);
+	ses->maxfd = MAX(ses->maxfd, fd);
 
 	channel->readfd = fd;
 	channel->writefd = fd;
@@ -238,7 +238,7 @@
 	
 	start_send_channel_request(channel, "auth-agent-req@openssh.com");
 	/* Don't want replies */
-	buf_putbyte(ses.writepayload, 0);
+	buf_putbyte(ses->writepayload, 0);
 	encrypt_packet();
 }
 
diff -aur dropbear-2022.83/cli-auth.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-auth.c
--- dropbear-2022.83/cli-auth.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-auth.c	2023-08-09 16:05:01.036016295 +0600
@@ -36,12 +36,12 @@
 void cli_auth_getmethods() {
 	TRACE(("enter cli_auth_getmethods"))
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);
-	buf_putstring(ses.writepayload, cli_opts.username,
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_REQUEST);
+	buf_putstring(ses->writepayload, cli_opts.username,
 			strlen(cli_opts.username));
-	buf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,
+	buf_putstring(ses->writepayload, SSH_SERVICE_CONNECTION,
 			SSH_SERVICE_CONNECTION_LEN);
-	buf_putstring(ses.writepayload, "none", 4); /* 'none' method */
+	buf_putstring(ses->writepayload, "none", 4); /* 'none' method */
 
 	encrypt_packet();
 
@@ -52,11 +52,11 @@
 	Race described at
 	http://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/zlib-openssh.html
 	*/
-	if (ses.keys->trans.algo_comp != DROPBEAR_COMP_ZLIB_DELAY) {
-		ses.authstate.authtypes = AUTH_TYPE_PUBKEY;
+	if (ses->keys->trans.algo_comp != DROPBEAR_COMP_ZLIB_DELAY) {
+		ses->authstate.authtypes = AUTH_TYPE_PUBKEY;
 #if DROPBEAR_USE_PASSWORD_ENV
 		if (getenv(DROPBEAR_PASSWORD_ENV)) {
-			ses.authstate.authtypes |= AUTH_TYPE_PASSWORD | AUTH_TYPE_INTERACT;
+			ses->authstate.authtypes |= AUTH_TYPE_PASSWORD | AUTH_TYPE_INTERACT;
 		}
 #endif
 		if (cli_auth_try() == DROPBEAR_SUCCESS) {
@@ -77,7 +77,7 @@
 	int truncated = 0;
 
 	TRACE(("enter recv_msg_userauth_banner"))
-	if (ses.authstate.authdone) {
+	if (ses->authstate.authdone) {
 		TRACE(("leave recv_msg_userauth_banner: banner after auth done"))
 		return;
 	}
@@ -87,8 +87,8 @@
 		return;
 	}
 
-	banner = buf_getstring(ses.payload, &bannerlen);
-	buf_eatstring(ses.payload); /* The language string */
+	banner = buf_getstring(ses->payload, &bannerlen);
+	buf_eatstring(ses->payload); /* The language string */
 
 	if (bannerlen > MAX_BANNER_SIZE) {
 		TRACE(("recv_msg_userauth_banner: bannerlen too long: %d", bannerlen))
@@ -165,7 +165,7 @@
 	TRACE(("<- MSG_USERAUTH_FAILURE"))
 	TRACE(("enter recv_msg_userauth_failure"))
 
-	if (ses.authstate.authdone) {
+	if (ses->authstate.authdone) {
 		TRACE(("leave recv_msg_userauth_failure, already authdone."))
 		return;
 	}
@@ -206,20 +206,20 @@
 		cli_ses.lastauthtype = AUTH_TYPE_NONE;
 	}
 
-	methods = buf_getstring(ses.payload, &methlen);
+	methods = buf_getstring(ses->payload, &methlen);
 
-	partial = buf_getbool(ses.payload);
+	partial = buf_getbool(ses->payload);
 
 	if (partial) {
 		dropbear_log(LOG_INFO, "Authentication partially succeeded, more attempts required");
 	} else {
-		ses.authstate.failcount++;
+		ses->authstate.failcount++;
 	}
 
 	TRACE(("Methods (len %d): '%s'", methlen, methods))
 
-	ses.authstate.authdone=0;
-	ses.authstate.authtypes=0;
+	ses->authstate.authdone=0;
+	ses->authstate.authtypes=0;
 
 	/* Split with nulls rather than commas */
 	for (i = 0; i < methlen; i++) {
@@ -235,19 +235,19 @@
 #if DROPBEAR_CLI_PUBKEY_AUTH
 			if (strncmp(AUTH_METHOD_PUBKEY, tok,
 				AUTH_METHOD_PUBKEY_LEN) == 0) {
-				ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
+				ses->authstate.authtypes |= AUTH_TYPE_PUBKEY;
 			}
 #endif
 #if DROPBEAR_CLI_INTERACT_AUTH
 			if (strncmp(AUTH_METHOD_INTERACT, tok,
 				AUTH_METHOD_INTERACT_LEN) == 0) {
-				ses.authstate.authtypes |= AUTH_TYPE_INTERACT;
+				ses->authstate.authtypes |= AUTH_TYPE_INTERACT;
 			}
 #endif
 #if DROPBEAR_CLI_PASSWORD_AUTH
 			if (strncmp(AUTH_METHOD_PASSWORD, tok,
 				AUTH_METHOD_PASSWORD_LEN) == 0) {
-				ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+				ses->authstate.authtypes |= AUTH_TYPE_PASSWORD;
 			}
 #endif
 			tok = &methods[i+1]; /* Must make sure we don't use it after the
@@ -271,7 +271,7 @@
 	}
 	/* Note: in delayed-zlib mode, setting authdone here 
 	 * will enable compression in the transport layer */
-	ses.authstate.authdone = 1;
+	ses->authstate.authdone = 1;
 	cli_ses.state = USERAUTH_SUCCESS_RCVD;
 	cli_ses.lastauthtype = AUTH_TYPE_NONE;
 
@@ -290,15 +290,15 @@
 	/* Order to try is pubkey, interactive, password.
 	 * As soon as "finished" is set for one, we don't do any more. */
 #if DROPBEAR_CLI_PUBKEY_AUTH
-	if (ses.authstate.authtypes & AUTH_TYPE_PUBKEY) {
+	if (ses->authstate.authtypes & AUTH_TYPE_PUBKEY) {
 		finished = cli_auth_pubkey();
 		cli_ses.lastauthtype = AUTH_TYPE_PUBKEY;
 	}
 #endif
 
 #if DROPBEAR_CLI_INTERACT_AUTH
-	if (!finished && (ses.authstate.authtypes & AUTH_TYPE_INTERACT)) {
-		if (ses.keys->trans.algo_crypt->cipherdesc == NULL) {
+	if (!finished && (ses->authstate.authtypes & AUTH_TYPE_INTERACT)) {
+		if (ses->keys->trans.algo_crypt->cipherdesc == NULL) {
 			fprintf(stderr, "Sorry, I won't let you use interactive auth unencrypted.\n");
 		} else {
 			if (!cli_ses.auth_interact_failed) {
@@ -311,8 +311,8 @@
 #endif
 
 #if DROPBEAR_CLI_PASSWORD_AUTH
-	if (!finished && (ses.authstate.authtypes & AUTH_TYPE_PASSWORD)) {
-		if (ses.keys->trans.algo_crypt->cipherdesc == NULL) {
+	if (!finished && (ses->authstate.authtypes & AUTH_TYPE_PASSWORD)) {
+		if (ses->keys->trans.algo_crypt->cipherdesc == NULL) {
 			fprintf(stderr, "Sorry, I won't let you use password auth unencrypted.\n");
 		} else {
 			cli_auth_password();
diff -aur dropbear-2022.83/cli-authinteract.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-authinteract.c
--- dropbear-2022.83/cli-authinteract.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-authinteract.c	2023-08-09 16:05:01.036016295 +0600
@@ -84,13 +84,13 @@
 	}
 	cli_ses.interact_request_received = 1;
 
-	name = buf_getstring(ses.payload, NULL);
-	instruction = buf_getstring(ses.payload, NULL);
+	name = buf_getstring(ses->payload, NULL);
+	instruction = buf_getstring(ses->payload, NULL);
 
 	/* language tag */
-	buf_eatstring(ses.payload);
+	buf_eatstring(ses->payload);
 
-	num_prompts = buf_getint(ses.payload);
+	num_prompts = buf_getint(ses->payload);
 	
 	if (num_prompts >= DROPBEAR_MAX_CLI_INTERACT_PROMPTS) {
 		dropbear_exit("Too many prompts received for keyboard-interactive");
@@ -98,8 +98,8 @@
 
 	/* we'll build the response as we go */
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_INFO_RESPONSE);
-	buf_putint(ses.writepayload, num_prompts);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_INFO_RESPONSE);
+	buf_putint(ses->writepayload, num_prompts);
 
 	if (strlen(name) > 0) {
 		cleantext(name);
@@ -116,10 +116,10 @@
 	for (i = 0; i < num_prompts; i++) {
 		unsigned int response_len = 0;
 		cli_ses.is_trivial_auth = 0;
-		prompt = buf_getstring(ses.payload, NULL);
+		prompt = buf_getstring(ses->payload, NULL);
 		cleantext(prompt);
 
-		echo = buf_getbool(ses.payload);
+		echo = buf_getbool(ses->payload);
 
 		if (!echo) {
 			char* p = getpass_or_cancel(prompt);
@@ -130,7 +130,7 @@
 		}
 
 		response_len = strlen(response);
-		buf_putstring(ses.writepayload, response, response_len);
+		buf_putstring(ses->writepayload, response, response_len);
 		m_burn(response, response_len);
 		m_free(prompt);
 		m_free(response);
@@ -147,25 +147,25 @@
 	TRACE(("enter cli_auth_interactive"))
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_REQUEST);
 
 	/* username */
-	buf_putstring(ses.writepayload, cli_opts.username,
+	buf_putstring(ses->writepayload, cli_opts.username,
 			strlen(cli_opts.username));
 
 	/* service name */
-	buf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,
+	buf_putstring(ses->writepayload, SSH_SERVICE_CONNECTION,
 			SSH_SERVICE_CONNECTION_LEN);
 
 	/* method */
-	buf_putstring(ses.writepayload, AUTH_METHOD_INTERACT,
+	buf_putstring(ses->writepayload, AUTH_METHOD_INTERACT,
 			AUTH_METHOD_INTERACT_LEN);
 
 	/* empty language tag */
-	buf_putstring(ses.writepayload, "", 0);
+	buf_putstring(ses->writepayload, "", 0);
 
 	/* empty submethods */
-	buf_putstring(ses.writepayload, "", 0);
+	buf_putstring(ses->writepayload, "", 0);
 
 	encrypt_packet();
 	cli_ses.interact_request_received = 0;
diff -aur dropbear-2022.83/cli-authpasswd.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-authpasswd.c
--- dropbear-2022.83/cli-authpasswd.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-authpasswd.c	2023-08-09 16:05:01.036016295 +0600
@@ -138,20 +138,20 @@
 		password = getpass_or_cancel(prompt);
 	}
 
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_REQUEST);
 
-	buf_putstring(ses.writepayload, cli_opts.username,
+	buf_putstring(ses->writepayload, cli_opts.username,
 			strlen(cli_opts.username));
 
-	buf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,
+	buf_putstring(ses->writepayload, SSH_SERVICE_CONNECTION,
 			SSH_SERVICE_CONNECTION_LEN);
 
-	buf_putstring(ses.writepayload, AUTH_METHOD_PASSWORD,
+	buf_putstring(ses->writepayload, AUTH_METHOD_PASSWORD,
 			AUTH_METHOD_PASSWORD_LEN);
 
-	buf_putbyte(ses.writepayload, 0); /* FALSE - so says the spec */
+	buf_putbyte(ses->writepayload, 0); /* FALSE - so says the spec */
 
-	buf_putstring(ses.writepayload, password, strlen(password));
+	buf_putstring(ses->writepayload, password, strlen(password));
 
 	encrypt_packet();
 	m_burn(password, strlen(password));
diff -aur dropbear-2022.83/cli-authpubkey.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-authpubkey.c
--- dropbear-2022.83/cli-authpubkey.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-authpubkey.c	2023-08-09 16:05:01.036016295 +0600
@@ -64,7 +64,7 @@
 
 	TRACE(("enter recv_msg_userauth_pk_ok"))
 
-	algotype = buf_getstring(ses.payload, &algolen);
+	algotype = buf_getstring(ses->payload, &algolen);
 	sigtype = signature_type_from_name(algotype, algolen);
 	keytype = signkey_type_from_signature(sigtype);
 	TRACE(("recv_msg_userauth_pk_ok: type %d", sigtype))
@@ -72,7 +72,7 @@
 
 	keybuf = buf_new(MAX_PUBKEY_SIZE);
 
-	remotelen = buf_getint(ses.payload);
+	remotelen = buf_getint(ses->payload);
 
 	/* Iterate through our keys, find which one it was that matched, and
 	 * send a real request with that key */
@@ -99,7 +99,7 @@
 			continue;
 		}
 		if (memcmp(buf_getptr(keybuf, remotelen),
-					buf_getptr(ses.payload, remotelen), remotelen) != 0) {
+					buf_getptr(ses->payload, remotelen), remotelen) != 0) {
 			/* Data didn't match this key */
 			TRACE(("data differed"))
 			continue;
@@ -150,31 +150,31 @@
 	DEBUG1(("enter send_msg_userauth_pubkey %s", signature_name_from_type(sigtype, NULL)))
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_REQUEST);
 
-	buf_putstring(ses.writepayload, cli_opts.username,
+	buf_putstring(ses->writepayload, cli_opts.username,
 			strlen(cli_opts.username));
 
-	buf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,
+	buf_putstring(ses->writepayload, SSH_SERVICE_CONNECTION,
 			SSH_SERVICE_CONNECTION_LEN);
 
-	buf_putstring(ses.writepayload, AUTH_METHOD_PUBKEY,
+	buf_putstring(ses->writepayload, AUTH_METHOD_PUBKEY,
 			AUTH_METHOD_PUBKEY_LEN);
 
-	buf_putbyte(ses.writepayload, realsign);
+	buf_putbyte(ses->writepayload, realsign);
 
 	algoname = signature_name_from_type(sigtype, &algolen);
-	buf_putstring(ses.writepayload, algoname, algolen);
-	buf_put_pub_key(ses.writepayload, key, keytype);
+	buf_putstring(ses->writepayload, algoname, algolen);
+	buf_put_pub_key(ses->writepayload, key, keytype);
 
 	if (realsign) {
 		TRACE(("realsign"))
 		/* We put the signature as well - this contains string(session id), then
 		 * the contents of the write payload to this point */
-		sigbuf = buf_new(4 + ses.session_id->len + ses.writepayload->len);
-		buf_putbufstring(sigbuf, ses.session_id);
-		buf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len);
-		cli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf);
+		sigbuf = buf_new(4 + ses->session_id->len + ses->writepayload->len);
+		buf_putbufstring(sigbuf, ses->session_id);
+		buf_putbytes(sigbuf, ses->writepayload->data, ses->writepayload->len);
+		cli_buf_put_sign(ses->writepayload, key, sigtype, sigbuf);
 		buf_free(sigbuf); /* Nothing confidential in the buffer */
 		cli_ses.is_trivial_auth = 0;
 	}
diff -aur dropbear-2022.83/cli-channel.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-channel.c
--- dropbear-2022.83/cli-channel.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-channel.c	2023-08-09 16:05:01.036016295 +0600
@@ -45,7 +45,7 @@
 		return; /* we just ignore it */
 	}
 
-	datatype = buf_getint(ses.payload);
+	datatype = buf_getint(ses->payload);
 	
 	if (datatype != SSH_EXTENDED_DATA_STDERR) {
 		TRACE(("leave recv_msg_channel_extended_data: wrong datatype: %d",
diff -aur dropbear-2022.83/cli-chansession.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-chansession.c
--- dropbear-2022.83/cli-chansession.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-chansession.c	2023-08-09 16:05:01.036016295 +0600
@@ -61,11 +61,11 @@
 
 	TRACE(("enter cli_chansessreq"))
 
-	type = buf_getstring(ses.payload, NULL);
-	wantreply = buf_getbool(ses.payload);
+	type = buf_getstring(ses->payload, NULL);
+	wantreply = buf_getbool(ses->payload);
 
 	if (strcmp(type, "exit-status") == 0) {
-		cli_ses.retval = buf_getint(ses.payload);
+		cli_ses.retval = buf_getint(ses->payload);
 		TRACE(("got exit-status of '%d'", cli_ses.retval))
 	} else if (strcmp(type, "exit-signal") == 0) {
 		TRACE(("got exit-signal, ignoring it"))
@@ -87,7 +87,7 @@
 	cli_tty_cleanup(); /* Restore tty modes etc */
 
 	/* This channel hasn't gone yet, so we have > 1 */
-	if (ses.chancount > 1) {
+	if (ses->chancount > 1) {
 		dropbear_log(LOG_INFO, "Waiting for other channels to close...");
 	}
 }
@@ -164,13 +164,13 @@
 
 	if (tcgetattr(STDIN_FILENO, &tio) == -1) {
 		dropbear_log(LOG_WARNING, "Failed reading termmodes");
-		buf_putint(ses.writepayload, 1); /* Just the terminator */
-		buf_putbyte(ses.writepayload, 0); /* TTY_OP_END */
+		buf_putint(ses->writepayload, 1); /* Just the terminator */
+		buf_putbyte(ses->writepayload, 0); /* TTY_OP_END */
 		return;
 	}
 
-	bufpos1 = ses.writepayload->pos;
-	buf_putint(ses.writepayload, 0); /* A placeholder for the final length */
+	bufpos1 = ses->writepayload->pos;
+	buf_putint(ses->writepayload, 0); /* A placeholder for the final length */
 
 	/* As with Dropbear server, we ignore baud rates for now */
 	for (sshcode = 1; sshcode < MAX_TERMCODE; sshcode++) {
@@ -209,18 +209,18 @@
 		}
 
 		/* If we reach here, we have something to say */
-		buf_putbyte(ses.writepayload, sshcode);
-		buf_putint(ses.writepayload, value);
+		buf_putbyte(ses->writepayload, sshcode);
+		buf_putint(ses->writepayload, value);
 	}
 
-	buf_putbyte(ses.writepayload, 0); /* THE END, aka TTY_OP_END */
+	buf_putbyte(ses->writepayload, 0); /* THE END, aka TTY_OP_END */
 
 	/* Put the string length at the start of the buffer */
-	bufpos2 = ses.writepayload->pos;
+	bufpos2 = ses->writepayload->pos;
 
-	buf_setpos(ses.writepayload, bufpos1); /* Jump back */
-	buf_putint(ses.writepayload, bufpos2 - bufpos1 - 4); /* len(termcodes) */
-	buf_setpos(ses.writepayload, bufpos2); /* Back where we were */
+	buf_setpos(ses->writepayload, bufpos1); /* Jump back */
+	buf_putint(ses->writepayload, bufpos2 - bufpos1 - 4); /* len(termcodes) */
+	buf_setpos(ses->writepayload, bufpos2); /* Back where we were */
 
 	TRACE(("leave put_termcodes"))
 }
@@ -237,10 +237,10 @@
 		ws.ws_ypixel = 0;
 	}
 
-	buf_putint(ses.writepayload, ws.ws_col); /* Cols */
-	buf_putint(ses.writepayload, ws.ws_row); /* Rows */
-	buf_putint(ses.writepayload, ws.ws_xpixel); /* Width */
-	buf_putint(ses.writepayload, ws.ws_ypixel); /* Height */
+	buf_putint(ses->writepayload, ws.ws_col); /* Cols */
+	buf_putint(ses->writepayload, ws.ws_row); /* Rows */
+	buf_putint(ses->writepayload, ws.ws_xpixel); /* Width */
+	buf_putint(ses->writepayload, ws.ws_ypixel); /* Height */
 
 }
 
@@ -255,14 +255,14 @@
 	unsigned int i;
 	struct Channel *channel = NULL;
 
-	for (i = 0; i < ses.chansize; i++) {
-		channel = ses.channels[i];
+	for (i = 0; i < ses->chansize; i++) {
+		channel = ses->channels[i];
 		if (channel != NULL && channel->type == &clichansess) {
 			CHECKCLEARTOWRITE();
-			buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_REQUEST);
-			buf_putint(ses.writepayload, channel->remotechan);
-			buf_putstring(ses.writepayload, "window-change", 13);
-			buf_putbyte(ses.writepayload, 0); /* FALSE says the spec */
+			buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_REQUEST);
+			buf_putint(ses->writepayload, channel->remotechan);
+			buf_putstring(ses->writepayload, "window-change", 13);
+			buf_putbyte(ses->writepayload, 0); /* FALSE says the spec */
 			put_winsize();
 			encrypt_packet();
 		}
@@ -279,14 +279,14 @@
 	start_send_channel_request(channel, "pty-req");
 
 	/* Don't want replies */
-	buf_putbyte(ses.writepayload, 0);
+	buf_putbyte(ses->writepayload, 0);
 
 	/* Get the terminal */
 	term = getenv("TERM");
 	if (term == NULL) {
 		term = "vt100"; /* Seems a safe default */
 	}
-	buf_putstring(ses.writepayload, term, strlen(term));
+	buf_putstring(ses->writepayload, term, strlen(term));
 
 	/* Window size */
 	put_winsize();
@@ -322,9 +322,9 @@
 	start_send_channel_request(channel, reqtype);
 
 	/* XXX TODO */
-	buf_putbyte(ses.writepayload, 0); /* Don't want replies */
+	buf_putbyte(ses->writepayload, 0); /* Don't want replies */
 	if (cli_opts.cmd) {
-		buf_putstring(ses.writepayload, cli_opts.cmd, strlen(cli_opts.cmd));
+		buf_putstring(ses->writepayload, cli_opts.cmd, strlen(cli_opts.cmd));
 	}
 
 	encrypt_packet();
@@ -342,7 +342,7 @@
 	channel->errfd = STDERR_FILENO;
 	setnonblocking(STDERR_FILENO);
 
-	channel->extrabuf = cbuf_new(opts.recv_window);
+	channel->extrabuf = cbuf_new(opts->recv_window);
 	channel->bidir_fd = 0;
 	return 0;
 }
@@ -400,13 +400,13 @@
 		dropbear_exit("Couldn't open initial channel");
 	}
 
-	buf_putstring(ses.writepayload, cli_opts.netcat_host,
+	buf_putstring(ses->writepayload, cli_opts.netcat_host,
 			strlen(cli_opts.netcat_host));
-	buf_putint(ses.writepayload, cli_opts.netcat_port);
+	buf_putint(ses->writepayload, cli_opts.netcat_port);
 
 	/* originator ip - localhost is accurate enough */
-	buf_putstring(ses.writepayload, source_host, strlen(source_host));
-	buf_putint(ses.writepayload, source_port);
+	buf_putstring(ses->writepayload, source_host, strlen(source_host));
+	buf_putint(ses->writepayload, source_port);
 
 	encrypt_packet();
 	TRACE(("leave cli_send_netcat_request"))
diff -aur dropbear-2022.83/cli-kex.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-kex.c
--- dropbear-2022.83/cli-kex.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-kex.c	2023-08-09 16:05:01.036016295 +0600
@@ -53,47 +53,47 @@
 	}
 #endif
 
-	buf_putbyte(ses.writepayload, SSH_MSG_KEXDH_INIT);
-	switch (ses.newkeys->algo_kex->mode) {
+	buf_putbyte(ses->writepayload, SSH_MSG_KEXDH_INIT);
+	switch (ses->newkeys->algo_kex->mode) {
 #if DROPBEAR_NORMAL_DH
 		case DROPBEAR_KEX_NORMAL_DH:
-			if (ses.newkeys->algo_kex != cli_ses.param_kex_algo
+			if (ses->newkeys->algo_kex != cli_ses.param_kex_algo
 				|| !cli_ses.dh_param) {
 				if (cli_ses.dh_param) {
 					free_kexdh_param(cli_ses.dh_param);
 				}
 				cli_ses.dh_param = gen_kexdh_param();
 			}
-			buf_putmpint(ses.writepayload, &cli_ses.dh_param->pub);
+			buf_putmpint(ses->writepayload, &cli_ses.dh_param->pub);
 			break;
 #endif
 #if DROPBEAR_ECDH
 		case DROPBEAR_KEX_ECDH:
-			if (ses.newkeys->algo_kex != cli_ses.param_kex_algo
+			if (ses->newkeys->algo_kex != cli_ses.param_kex_algo
 				|| !cli_ses.ecdh_param) {
 				if (cli_ses.ecdh_param) {
 					free_kexecdh_param(cli_ses.ecdh_param);
 				}
 				cli_ses.ecdh_param = gen_kexecdh_param();
 			}
-			buf_put_ecc_raw_pubkey_string(ses.writepayload, &cli_ses.ecdh_param->key);
+			buf_put_ecc_raw_pubkey_string(ses->writepayload, &cli_ses.ecdh_param->key);
 			break;
 #endif
 #if DROPBEAR_CURVE25519
 		case DROPBEAR_KEX_CURVE25519:
-			if (ses.newkeys->algo_kex != cli_ses.param_kex_algo
+			if (ses->newkeys->algo_kex != cli_ses.param_kex_algo
 				|| !cli_ses.curve25519_param) {
 				if (cli_ses.curve25519_param) {
 					free_kexcurve25519_param(cli_ses.curve25519_param);
 				}
 				cli_ses.curve25519_param = gen_kexcurve25519_param();
 			}
-			buf_putstring(ses.writepayload, cli_ses.curve25519_param->pub, CURVE25519_LEN);
+			buf_putstring(ses->writepayload, cli_ses.curve25519_param->pub, CURVE25519_LEN);
 			break;
 #endif
 	}
 
-	cli_ses.param_kex_algo = ses.newkeys->algo_kex;
+	cli_ses.param_kex_algo = ses->newkeys->algo_kex;
 	encrypt_packet();
 }
 
@@ -115,30 +115,30 @@
 	if (cli_ses.kex_state != KEXDH_INIT_SENT) {
 		dropbear_exit("Received out-of-order kexdhreply");
 	}
-	keytype = ses.newkeys->algo_hostkey;
+	keytype = ses->newkeys->algo_hostkey;
 	TRACE(("keytype is %d", keytype))
 
 	hostkey = new_sign_key();
-	keybloblen = buf_getint(ses.payload);
+	keybloblen = buf_getint(ses->payload);
 
-	keyblob = buf_getptr(ses.payload, keybloblen);
-	if (!ses.kexstate.donefirstkex) {
+	keyblob = buf_getptr(ses->payload, keybloblen);
+	if (!ses->kexstate.donefirstkex) {
 		/* Only makes sense the first time */
 		checkhostkey(keyblob, keybloblen);
 	}
 
-	if (buf_get_pub_key(ses.payload, hostkey, &keytype) != DROPBEAR_SUCCESS) {
+	if (buf_get_pub_key(ses->payload, hostkey, &keytype) != DROPBEAR_SUCCESS) {
 		TRACE(("failed getting pubkey"))
 		dropbear_exit("Bad KEX packet");
 	}
 
-	switch (ses.newkeys->algo_kex->mode) {
+	switch (ses->newkeys->algo_kex->mode) {
 #if DROPBEAR_NORMAL_DH
 		case DROPBEAR_KEX_NORMAL_DH:
 			{
 			DEF_MP_INT(dh_f);
 			m_mp_init(&dh_f);
-			if (buf_getmpint(ses.payload, &dh_f) != DROPBEAR_SUCCESS) {
+			if (buf_getmpint(ses->payload, &dh_f) != DROPBEAR_SUCCESS) {
 				TRACE(("failed getting mpint"))
 				dropbear_exit("Bad KEX packet");
 			}
@@ -151,7 +151,7 @@
 #if DROPBEAR_ECDH
 		case DROPBEAR_KEX_ECDH:
 			{
-			buffer *ecdh_qs = buf_getstringbuf(ses.payload);
+			buffer *ecdh_qs = buf_getstringbuf(ses->payload);
 			kexecdh_comb_key(cli_ses.ecdh_param, ecdh_qs, hostkey);
 			buf_free(ecdh_qs);
 			}
@@ -160,7 +160,7 @@
 #if DROPBEAR_CURVE25519
 		case DROPBEAR_KEX_CURVE25519:
 			{
-			buffer *ecdh_qs = buf_getstringbuf(ses.payload);
+			buffer *ecdh_qs = buf_getstringbuf(ses->payload);
 			kexcurve25519_comb_key(cli_ses.curve25519_param, ecdh_qs, hostkey);
 			buf_free(ecdh_qs);
 			}
@@ -188,8 +188,8 @@
 #endif
 
 	cli_ses.param_kex_algo = NULL;
-	if (buf_verify(ses.payload, hostkey, ses.newkeys->algo_signature, 
-			ses.hash) != DROPBEAR_SUCCESS) {
+	if (buf_verify(ses->payload, hostkey, ses->newkeys->algo_signature, 
+			ses->hash) != DROPBEAR_SUCCESS) {
 		dropbear_exit("Bad hostkey signature");
 	}
 
@@ -197,7 +197,7 @@
 	hostkey = NULL;
 
 	send_msg_newkeys();
-	ses.requirenext = SSH_MSG_NEWKEYS;
+	ses->requirenext = SSH_MSG_NEWKEYS;
 	TRACE(("leave recv_msg_kexdh_init"))
 }
 
@@ -316,7 +316,7 @@
 		return;
 	}
 
-	algoname = signkey_name_from_type(ses.newkeys->algo_hostkey, &algolen);
+	algoname = signkey_name_from_type(ses->newkeys->algo_hostkey, &algolen);
 
 	hostsfile = open_known_hosts_file(&readonly);
 	if (!hostsfile)	{
@@ -438,26 +438,26 @@
 	TRACE(("enter recv_msg_ext_info"))
 
 	/* Must be after the first SSH_MSG_NEWKEYS */
-	TRACE(("last %d, donefirst %d, donescond %d", ses.lastpacket, ses.kexstate.donefirstkex, ses.kexstate.donesecondkex))
-	if (!(ses.lastpacket == SSH_MSG_NEWKEYS && !ses.kexstate.donesecondkex)) {
+	TRACE(("last %d, donefirst %d, donescond %d", ses->lastpacket, ses->kexstate.donefirstkex, ses->kexstate.donesecondkex))
+	if (!(ses->lastpacket == SSH_MSG_NEWKEYS && !ses->kexstate.donesecondkex)) {
 		TRACE(("leave recv_msg_ext_info: ignoring packet received at the wrong time"))
 		return;
 	}
 
-	num_ext = buf_getint(ses.payload);
+	num_ext = buf_getint(ses->payload);
 	TRACE(("received SSH_MSG_EXT_INFO with %d items", num_ext))
 
 	for (i = 0; i < num_ext; i++) {
 		unsigned int name_len;
-		char *ext_name = buf_getstring(ses.payload, &name_len);
+		char *ext_name = buf_getstring(ses->payload, &name_len);
 		TRACE(("extension %d name '%s'", i, ext_name))
 		if (cli_ses.server_sig_algs == NULL
 				&& name_len == strlen(SSH_SERVER_SIG_ALGS)
 				&& strcmp(ext_name, SSH_SERVER_SIG_ALGS) == 0) {
-			cli_ses.server_sig_algs = buf_getbuf(ses.payload);
+			cli_ses.server_sig_algs = buf_getbuf(ses->payload);
 		} else {
 			/* valid extension values could be >MAX_STRING_LEN */
-			buf_eatstring(ses.payload);
+			buf_eatstring(ses->payload);
 		}
 		m_free(ext_name);
 	}
diff -aur dropbear-2022.83/cli-main.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-main.c
--- dropbear-2022.83/cli-main.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-main.c	2023-08-09 16:05:01.040016228 +0600
@@ -60,7 +60,7 @@
 	cli_getopts(argc, argv);
 
 #ifndef DISABLE_SYSLOG
-	if (opts.usingsyslog) {
+	if (opts->usingsyslog) {
 		startsyslog("dbclient");
 	}
 #endif
@@ -106,7 +106,7 @@
 	char *usershell;
 
 	usershell = m_strdup(get_user_shell());
-	run_shell_command(cmd, ses.maxfd, usershell);
+	run_shell_command(cmd, ses->maxfd, usershell);
 	dropbear_exit("Failed to run '%s'\n", cmd);
 }
 
diff -aur dropbear-2022.83/cli-runopts.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-runopts.c
--- dropbear-2022.83/cli-runopts.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-runopts.c	2023-08-09 16:05:01.040016228 +0600
@@ -158,7 +158,7 @@
 	cli_opts.disable_trivial_auth = 0;
 #if DROPBEAR_CLI_LOCALTCPFWD
 	cli_opts.localfwds = list_new();
-	opts.listen_fwd_all = 0;
+	opts->listen_fwd_all = 0;
 #endif
 #if DROPBEAR_CLI_REMOTETCPFWD
 	cli_opts.remotefwds = list_new();
@@ -174,22 +174,22 @@
 	cli_opts.bind_address = NULL;
 	cli_opts.bind_port = NULL;
 #ifndef DISABLE_ZLIB
-	opts.compress_mode = DROPBEAR_COMPRESS_ON;
+	opts->compress_mode = DROPBEAR_COMPRESS_ON;
 #endif
 #if DROPBEAR_USER_ALGO_LIST
-	opts.cipher_list = NULL;
-	opts.mac_list = NULL;
+	opts->cipher_list = NULL;
+	opts->mac_list = NULL;
 #endif
 #ifndef DISABLE_SYSLOG
-	opts.usingsyslog = 0;
+	opts->usingsyslog = 0;
 #endif
 	/* not yet
-	opts.ipv4 = 1;
-	opts.ipv6 = 1;
+	opts->ipv4 = 1;
+	opts->ipv6 = 1;
 	*/
-	opts.recv_window = DEFAULT_RECV_WINDOW;
-	opts.keepalive_secs = DEFAULT_KEEPALIVE;
-	opts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;
+	opts->recv_window = DEFAULT_RECV_WINDOW;
+	opts->keepalive_secs = DEFAULT_KEEPALIVE;
+	opts->idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;
 
 	fill_own_user();
 
@@ -251,7 +251,7 @@
 					opt = OPT_LOCALTCPFWD;
 					break;
 				case 'g':
-					opts.listen_fwd_all = 1;
+					opts->listen_fwd_all = 1;
 					break;
 #endif
 #if DROPBEAR_CLI_REMOTETCPFWD
@@ -295,10 +295,10 @@
 #endif
 #if DROPBEAR_USER_ALGO_LIST
 				case 'c':
-					next = &opts.cipher_list;
+					next = &opts->cipher_list;
 					break;
 				case 'm':
-					next = &opts.mac_list;
+					next = &opts->mac_list;
 					break;
 #endif
 #if DEBUG_TRACE
@@ -327,7 +327,7 @@
 					next = &bind_arg;
 					break;
 				case 'z':
-					opts.disable_ip_tos = 1;
+					opts->disable_ip_tos = 1;
 					break;
 				default:
 					fprintf(stderr,
@@ -465,7 +465,7 @@
 		if (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {
 			dropbear_exit("Bad keepalive '%s'", keepalive_arg);
 		}
-		opts.keepalive_secs = val;
+		opts->keepalive_secs = val;
 	}
 
 	if (idle_timeout_arg) {
@@ -473,7 +473,7 @@
 		if (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {
 			dropbear_exit("Bad idle_timeout '%s'", idle_timeout_arg);
 		}
-		opts.idle_timeout_secs = val;
+		opts->idle_timeout_secs = val;
 	}
 
 #if DROPBEAR_CLI_NETCAT
@@ -565,8 +565,8 @@
 		total += m_snprintf(ret+total, len-total, "-J '%s' ", cli_opts.proxycmd);
 	}
 
-	if (opts.recv_window != DEFAULT_RECV_WINDOW) {
-		total += m_snprintf(ret+total, len-total, "-W %u ", opts.recv_window);
+	if (opts->recv_window != DEFAULT_RECV_WINDOW) {
+		total += m_snprintf(ret+total, len-total, "-W %u ", opts->recv_window);
 	}
 
 #if DROPBEAR_CLI_PUBKEY_AUTH
@@ -649,7 +649,7 @@
 				passthrough_args, remainder);
 #ifndef DISABLE_ZLIB
 		/* The stream will be incompressible since it's encrypted. */
-		opts.compress_mode = DROPBEAR_COMPRESS_OFF;
+		opts->compress_mode = DROPBEAR_COMPRESS_OFF;
 #endif
 		m_free(passthrough_args);
 	}
@@ -910,7 +910,7 @@
 
 #ifndef DISABLE_SYSLOG
 	if (match_extendedopt(&optstr, "UseSyslog") == DROPBEAR_SUCCESS) {
-		opts.usingsyslog = parse_flag_value(optstr);
+		opts->usingsyslog = parse_flag_value(optstr);
 		return;
 	}
 #endif
diff -aur dropbear-2022.83/cli-session.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-session.c
--- dropbear-2022.83/cli-session.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-session.c	2023-08-09 16:05:01.040016228 +0600
@@ -103,7 +103,7 @@
 	}
 	myses->sock_in = myses->sock_out = sock;
 	DEBUG1(("cli_connected"))
-	ses.socket_prio = DROPBEAR_PRIO_NORMAL;
+	ses->socket_prio = DROPBEAR_PRIO_NORMAL;
 	/* switches to lowdelay */
 	update_channel_prio();
 }
@@ -113,7 +113,7 @@
 	common_session_init(sock_in, sock_out);
 
 	if (progress) {
-		connect_set_writequeue(progress, &ses.writequeue);
+		connect_set_writequeue(progress, &ses->writequeue);
 	}
 
 	chaninitialise(cli_chantypes);
@@ -122,7 +122,7 @@
 	cli_session_init(proxy_cmd_pid);
 
 	/* Ready to go */
-	ses.init_done = 1;
+	ses->init_done = 1;
 
 	/* Exchange identification */
 	send_session_identification();
@@ -171,17 +171,17 @@
 	cli_ses.is_trivial_auth = 1;
 
 	/* For printing "remote host closed" for the user */
-	ses.remoteclosed = cli_remoteclosed;
+	ses->remoteclosed = cli_remoteclosed;
 
-	ses.extra_session_cleanup = cli_session_cleanup;
+	ses->extra_session_cleanup = cli_session_cleanup;
 
 	/* packet handlers */
-	ses.packettypes = cli_packettypes;
+	ses->packettypes = cli_packettypes;
 
-	ses.isserver = 0;
+	ses->isserver = 0;
 
 #if DROPBEAR_KEX_FIRST_FOLLOWS
-	ses.send_kex_first_guess = cli_send_kex_first_guess;
+	ses->send_kex_first_guess = cli_send_kex_first_guess;
 #endif
 
 }
@@ -192,8 +192,8 @@
 
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_SERVICE_REQUEST);
-	buf_putstring(ses.writepayload, servicename, strlen(servicename));
+	buf_putbyte(ses->writepayload, SSH_MSG_SERVICE_REQUEST);
+	buf_putstring(ses->writepayload, servicename, strlen(servicename));
 
 	encrypt_packet();
 	TRACE(("leave send_msg_service_request"))
@@ -209,15 +209,15 @@
 
 	TRACE2(("enter cli_sessionloop"))
 
-	if (ses.lastpacket == 0) {
+	if (ses->lastpacket == 0) {
 		TRACE2(("exit cli_sessionloop: no real packets yet"))
 		return;
 	}
 
-	if (ses.lastpacket == SSH_MSG_KEXINIT && cli_ses.kex_state == KEX_NOTHING) {
+	if (ses->lastpacket == SSH_MSG_KEXINIT && cli_ses.kex_state == KEX_NOTHING) {
 		/* We initiate the KEXDH. If DH wasn't the correct type, the KEXINIT
 		 * negotiation would have failed. */
-		if (!ses.kexstate.our_first_follows_matches) {
+		if (!ses->kexstate.our_first_follows_matches) {
 			send_msg_kexdh_init();
 		}
 		cli_ses.kex_state = KEXDH_INIT_SENT;			
@@ -226,7 +226,7 @@
 	}
 
 	/* A KEX has finished, so we should go back to our KEX_NOTHING state */
-	if (cli_ses.kex_state != KEX_NOTHING && ses.kexstate.sentnewkeys) {
+	if (cli_ses.kex_state != KEX_NOTHING && ses->kexstate.sentnewkeys) {
 		cli_ses.kex_state = KEX_NOTHING;
 	}
 
@@ -236,7 +236,7 @@
 		return;
 	}
 
-	if (ses.kexstate.donefirstkex == 0) {
+	if (ses->kexstate.donefirstkex == 0) {
 		/* We might reach here if we have partial packet reads or have
 		 * received SSG_MSG_IGNORE etc. Just skip it */
 		TRACE2(("donefirstkex false\n"))
@@ -271,7 +271,7 @@
 
 		case USERAUTH_SUCCESS_RCVD:
 #ifndef DISABLE_SYSLOG
-			if (opts.usingsyslog) {
+			if (opts->usingsyslog) {
 				dropbear_log(LOG_INFO, "Authentication succeeded.");
 			}
 #endif
@@ -313,7 +313,7 @@
 			return;
 
 		case SESSION_RUNNING:
-			if (ses.chancount < 1 && !cli_opts.no_cmd) {
+			if (ses->chancount < 1 && !cli_opts.no_cmd) {
 				cli_finished();
 			}
 
@@ -346,7 +346,7 @@
 
 static void cli_session_cleanup(void) {
 
-	if (!ses.init_done) {
+	if (!ses->init_done) {
 		return;
 	}
 
@@ -385,10 +385,10 @@
 
 	/* XXX TODO perhaps print a friendlier message if we get this but have
 	 * already sent/received disconnect message(s) ??? */
-	m_close(ses.sock_in);
-	m_close(ses.sock_out);
-	ses.sock_in = -1;
-	ses.sock_out = -1;
+	m_close(ses->sock_in);
+	m_close(ses->sock_out);
+	ses->sock_in = -1;
+	ses->sock_out = -1;
 	dropbear_exit("Remote closed the connection");
 }
 
@@ -417,8 +417,8 @@
 static void recv_msg_global_request_cli(void) {
 	unsigned int wantreply = 0;
 
-	buf_eatstring(ses.payload);
-	wantreply = buf_getbool(ses.payload);
+	buf_eatstring(ses->payload);
+	wantreply = buf_getbool(ses->payload);
 
 	TRACE(("recv_msg_global_request_cli: want_reply: %u", wantreply));
 
@@ -439,7 +439,7 @@
 	TRACE(("Exited, cleaning up: %s", exitmsg))
 
 	/* Add the prefix depending on session/auth state */
-	if (!ses.init_done) {
+	if (!ses->init_done) {
 		snprintf(fullmsg, sizeof(fullmsg), "Exited: %s", exitmsg);
 	} else {
 		snprintf(fullmsg, sizeof(fullmsg), 
@@ -478,7 +478,7 @@
 	vsnprintf(printbuf, sizeof(printbuf), format, param);
 
 #ifndef DISABLE_SYSLOG
-	if (opts.usingsyslog) {
+	if (opts->usingsyslog) {
 		syslog(priority, "%s", printbuf);
 	}
 #endif
diff -aur dropbear-2022.83/cli-tcpfwd.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-tcpfwd.c
--- dropbear-2022.83/cli-tcpfwd.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/cli-tcpfwd.c	2023-08-09 16:05:01.040016228 +0600
@@ -124,7 +124,7 @@
 	}
 	else
 	{
-		if (opts.listen_fwd_all) {
+		if (opts->listen_fwd_all) {
 			tcpinfo->listenaddr = m_strdup("");
 		} else {
 			tcpinfo->listenaddr = m_strdup("localhost");
@@ -151,11 +151,11 @@
 	TRACE(("enter send_msg_global_request_remotetcp"))
 
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_GLOBAL_REQUEST);
-	buf_putstring(ses.writepayload, "tcpip-forward", 13);
-	buf_putbyte(ses.writepayload, 1); /* want_reply */
-	buf_putstring(ses.writepayload, addr, strlen(addr));
-	buf_putint(ses.writepayload, port);
+	buf_putbyte(ses->writepayload, SSH_MSG_GLOBAL_REQUEST);
+	buf_putstring(ses->writepayload, "tcpip-forward", 13);
+	buf_putbyte(ses->writepayload, 1); /* want_reply */
+	buf_putstring(ses->writepayload, addr, strlen(addr));
+	buf_putint(ses->writepayload, port);
 
 	encrypt_packet();
 
@@ -179,7 +179,7 @@
 			fwd->have_reply = 1;
 			if (fwd->listenport == 0) {
 				/* The server should let us know which port was allocated if we requested port 0 */
-				int allocport = buf_getint(ses.payload);
+				int allocport = buf_getint(ses->payload);
 				if (allocport > 0) {
 					fwd->listenport = allocport;
 					dropbear_log(LOG_INFO, "Allocated port %d for remote forward to %s:%d", 
@@ -216,7 +216,7 @@
 		{
 			/* we store the addresses so that we can compare them
 			   when the server sends them back */
-			if (opts.listen_fwd_all) {
+			if (opts->listen_fwd_all) {
 				fwd->listenaddr = m_strdup("");
 			} else {
 				fwd->listenaddr = m_strdup("localhost");
@@ -237,8 +237,8 @@
 	char portstring[NI_MAXSERV];
 	int err = SSH_OPEN_ADMINISTRATIVELY_PROHIBITED;
 
-	origaddr = buf_getstring(ses.payload, NULL);
-	origport = buf_getint(ses.payload);
+	origaddr = buf_getstring(ses->payload, NULL);
+	origport = buf_getint(ses->payload);
 
 	/* Find which port corresponds. First try and match address as well as port,
 	in case they want to forward different ports separately ... */
diff -aur dropbear-2022.83/common-channel.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-channel.c
--- dropbear-2022.83/common-channel.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-channel.c	2023-08-09 16:05:01.040016228 +0600
@@ -70,12 +70,12 @@
 void chaninitialise(const struct ChanType *chantypes[]) {
 
 	/* may as well create space for a single channel */
-	ses.channels = (struct Channel**)m_malloc(sizeof(struct Channel*));
-	ses.chansize = 1;
-	ses.channels[0] = NULL;
-	ses.chancount = 0;
+	ses->channels = (struct Channel**)m_malloc(sizeof(struct Channel*));
+	ses->chansize = 1;
+	ses->channels[0] = NULL;
+	ses->chancount = 0;
 
-	ses.chantypes = chantypes;
+	ses->chantypes = chantypes;
 
 #if DROPBEAR_LISTENERS
 	listeners_initialise();
@@ -89,13 +89,13 @@
 	unsigned int i;
 
 	TRACE(("enter chancleanup"))
-	for (i = 0; i < ses.chansize; i++) {
-		if (ses.channels[i] != NULL) {
+	for (i = 0; i < ses->chansize; i++) {
+		if (ses->channels[i] != NULL) {
 			TRACE(("channel %d closing", i))
-			remove_channel(ses.channels[i]);
+			remove_channel(ses->channels[i]);
 		}
 	}
-	m_free(ses.channels);
+	m_free(ses->channels);
 	TRACE(("leave chancleanup"))
 }
 
@@ -113,28 +113,28 @@
 	TRACE(("enter newchannel"))
 	
 	/* first see if we can use existing channels */
-	for (i = 0; i < ses.chansize; i++) {
-		if (ses.channels[i] == NULL) {
+	for (i = 0; i < ses->chansize; i++) {
+		if (ses->channels[i] == NULL) {
 			break;
 		}
 	}
 
 	/* otherwise extend the list */
-	if (i == ses.chansize) {
-		if (ses.chansize >= MAX_CHANNELS) {
+	if (i == ses->chansize) {
+		if (ses->chansize >= MAX_CHANNELS) {
 			TRACE(("leave newchannel: max chans reached"))
 			return NULL;
 		}
 
 		/* extend the channels */
-		ses.channels = (struct Channel**)m_realloc(ses.channels,
-				(ses.chansize+CHAN_EXTEND_SIZE)*sizeof(struct Channel*));
+		ses->channels = (struct Channel**)m_realloc(ses->channels,
+				(ses->chansize+CHAN_EXTEND_SIZE)*sizeof(struct Channel*));
 
-		ses.chansize += CHAN_EXTEND_SIZE;
+		ses->chansize += CHAN_EXTEND_SIZE;
 
 		/* set the new channels to null */
-		for (j = i; j < ses.chansize; j++) {
-			ses.channels[j] = NULL;
+		for (j = i; j < ses->chansize; j++) {
+			ses->channels[j] = NULL;
 		}
 
 	}
@@ -155,8 +155,8 @@
 	newchan->errfd = FD_CLOSED; /* this isn't always set to start with */
 	newchan->await_open = 0;
 
-	newchan->writebuf = cbuf_new(opts.recv_window);
-	newchan->recvwindow = opts.recv_window;
+	newchan->writebuf = cbuf_new(opts->recv_window);
+	newchan->recvwindow = opts->recv_window;
 
 	newchan->extrabuf = NULL; /* The user code can set it up */
 	newchan->recvdonelen = 0;
@@ -164,8 +164,8 @@
 
 	newchan->prio = DROPBEAR_PRIO_NORMAL;
 
-	ses.channels[i] = newchan;
-	ses.chancount++;
+	ses->channels[i] = newchan;
+	ses->chancount++;
 
 	TRACE(("leave newchannel"))
 
@@ -173,22 +173,22 @@
 }
 
 /* Returns the channel structure corresponding to the channel in the current
- * data packet (ses.payload must be positioned appropriately).
+ * data packet (ses->payload must be positioned appropriately).
  * A valid channel is always returns, it will fail fatally with an unknown
  * channel */
 static struct Channel* getchannel_msg(const char* kind) {
 
 	unsigned int chan;
 
-	chan = buf_getint(ses.payload);
-	if (chan >= ses.chansize || ses.channels[chan] == NULL) {
+	chan = buf_getint(ses->payload);
+	if (chan >= ses->chansize || ses->channels[chan] == NULL) {
 		if (kind) {
 			dropbear_exit("%s for unknown channel %d", kind, chan);
 		} else {
 			dropbear_exit("Unknown channel %d", chan);
 		}
 	}
-	return ses.channels[chan];
+	return ses->channels[chan];
 }
 
 struct Channel* getchannel() {
@@ -203,11 +203,11 @@
 	unsigned int i;
 
 	/* foreach channel */
-	for (i = 0; i < ses.chansize; i++) {
+	for (i = 0; i < ses->chansize; i++) {
 		/* Close checking only needs to occur for channels that had IO events */
 		int do_check_close = 0;
 
-		channel = ses.channels[i];
+		channel = ses->channels[i];
 		if (channel == NULL) {
 			/* only process in-use channels */
 			continue;
@@ -241,7 +241,7 @@
 			do_check_close = 1;
 		}
 
-		if (ses.channel_signal_pending) {
+		if (ses->channel_signal_pending) {
 			/* SIGCHLD can change channel state for server sessions */
 			do_check_close = 1;
 		}
@@ -378,8 +378,8 @@
 	
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_CLOSE);
-	buf_putint(ses.writepayload, channel->remotechan);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_CLOSE);
+	buf_putint(ses->writepayload, channel->remotechan);
 
 	encrypt_packet();
 
@@ -397,8 +397,8 @@
 	TRACE(("enter send_msg_channel_eof"))
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_EOF);
-	buf_putint(ses.writepayload, channel->remotechan);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_EOF);
+	buf_putint(ses->writepayload, channel->remotechan);
 
 	encrypt_packet();
 
@@ -526,7 +526,7 @@
 		channel->recvdonelen = 0;
 	}
 
-	dropbear_assert(channel->recvwindow <= opts.recv_window);
+	dropbear_assert(channel->recvwindow <= opts->recv_window);
 	dropbear_assert(channel->recvwindow <= cbuf_getavail(channel->writebuf));
 	dropbear_assert(channel->extrabuf == NULL ||
 			channel->recvwindow <= cbuf_getavail(channel->extrabuf));
@@ -543,9 +543,9 @@
 	unsigned int i;
 	struct Channel * channel;
 	
-	for (i = 0; i < ses.chansize; i++) {
+	for (i = 0; i < ses->chansize; i++) {
 
-		channel = ses.channels[i];
+		channel = ses->channels[i];
 		if (channel == NULL) {
 			continue;
 		}
@@ -556,7 +556,7 @@
 		FD if there's the possibility of "~."" to kill an 
 		interactive session (the read_mangler) */
 		if (channel->transwindow > 0
-		   && ((ses.dataallowed && allow_reads) || channel->read_mangler)) {
+		   && ((ses->dataallowed && allow_reads) || channel->read_mangler)) {
 
 			if (channel->readfd >= 0) {
 				FD_SET(channel->readfd, readfds);
@@ -654,9 +654,9 @@
 		cancel_connect(channel->conn_pending);
 	}
 
-	ses.channels[channel->index] = NULL;
+	ses->channels[channel->index] = NULL;
 	m_free(channel);
-	ses.chancount--;
+	ses->chancount--;
 
 	update_channel_prio();
 
@@ -677,8 +677,8 @@
 		channel->type->reqhandler(channel);
 	} else {
 		int wantreply;
-		buf_eatstring(ses.payload);
-		wantreply = buf_getbool(ses.payload);
+		buf_eatstring(ses->payload);
+		wantreply = buf_getbool(ses->payload);
 		if (wantreply) {
 			send_msg_channel_failure(channel);
 		}
@@ -716,25 +716,25 @@
 	/* -(1+4+4) is SSH_MSG_CHANNEL_DATA, channel number, string length, and 
 	 * exttype if is extended */
 	maxlen = MIN(maxlen, 
-			ses.writepayload->size - 1 - 4 - 4 - (isextended ? 4 : 0));
+			ses->writepayload->size - 1 - 4 - 4 - (isextended ? 4 : 0));
 	TRACE(("maxlen %zd", maxlen))
 	if (maxlen == 0) {
 		TRACE(("leave send_msg_channel_data: no window"))
 		return;
 	}
 
-	buf_putbyte(ses.writepayload, 
+	buf_putbyte(ses->writepayload, 
 			isextended ? SSH_MSG_CHANNEL_EXTENDED_DATA : SSH_MSG_CHANNEL_DATA);
-	buf_putint(ses.writepayload, channel->remotechan);
+	buf_putint(ses->writepayload, channel->remotechan);
 	if (isextended) {
-		buf_putint(ses.writepayload, SSH_EXTENDED_DATA_STDERR);
+		buf_putint(ses->writepayload, SSH_EXTENDED_DATA_STDERR);
 	}
 	/* a dummy size first ...*/
-	size_pos = ses.writepayload->pos;
-	buf_putint(ses.writepayload, 0);
+	size_pos = ses->writepayload->pos;
+	buf_putint(ses->writepayload, 0);
 
 	/* read the data */
-	len = read(fd, buf_getwriteptr(ses.writepayload, maxlen), maxlen);
+	len = read(fd, buf_getwriteptr(ses->writepayload, maxlen), maxlen);
 
 	if (len <= 0) {
 		if (len == 0 || errno != EINTR) {
@@ -743,27 +743,27 @@
 			in which case it can be treated the same as EOF */
 			close_chan_fd(channel, fd, SHUT_RD);
 		}
-		buf_setpos(ses.writepayload, 0);
-		buf_setlen(ses.writepayload, 0);
+		buf_setpos(ses->writepayload, 0);
+		buf_setlen(ses->writepayload, 0);
 		TRACE(("leave send_msg_channel_data: len %d read err %d or EOF for fd %d", 
 					len, errno, fd))
 		return;
 	}
 
 	if (channel->read_mangler) {
-		channel->read_mangler(channel, buf_getwriteptr(ses.writepayload, len), &len);
+		channel->read_mangler(channel, buf_getwriteptr(ses->writepayload, len), &len);
 		if (len == 0) {
-			buf_setpos(ses.writepayload, 0);
-			buf_setlen(ses.writepayload, 0);
+			buf_setpos(ses->writepayload, 0);
+			buf_setlen(ses->writepayload, 0);
 			return;
 		}
 	}
 
 	TRACE(("send_msg_channel_data: len %d fd %d", len, fd))
-	buf_incrwritepos(ses.writepayload, len);
+	buf_incrwritepos(ses->writepayload, len);
 	/* ... real size here */
-	buf_setpos(ses.writepayload, size_pos);
-	buf_putint(ses.writepayload, len);
+	buf_setpos(ses->writepayload, size_pos);
+	buf_putint(ses->writepayload, len);
 
 	channel->transwindow -= len;
 
@@ -806,7 +806,7 @@
 		return;
 	}
 
-	datalen = buf_getint(ses.payload);
+	datalen = buf_getint(ses->payload);
 	TRACE(("length %d", datalen))
 
 	maxdata = cbuf_getavail(cbuf);
@@ -820,14 +820,14 @@
 
 	dropbear_assert(channel->recvwindow >= datalen);
 	channel->recvwindow -= datalen;
-	dropbear_assert(channel->recvwindow <= opts.recv_window);
+	dropbear_assert(channel->recvwindow <= opts->recv_window);
 
 	/* Attempt to write the data immediately without having to put it in the circular buffer */
 	consumed = datalen;
-	res = writechannel(channel, fd, cbuf, buf_getptr(ses.payload, datalen), &consumed);
+	res = writechannel(channel, fd, cbuf, buf_getptr(ses->payload, datalen), &consumed);
 
 	datalen -= consumed;
-	buf_incrpos(ses.payload, consumed);
+	buf_incrpos(ses->payload, consumed);
 
 
 	/* We may have to run throught twice, if the buffer wraps around. Can't
@@ -841,9 +841,9 @@
 			buflen = MIN(buflen, len);
 
 			memcpy(cbuf_writeptr(cbuf, buflen), 
-					buf_getptr(ses.payload, buflen), buflen);
+					buf_getptr(ses->payload, buflen), buflen);
 			cbuf_incrwrite(cbuf, buflen);
-			buf_incrpos(ses.payload, buflen);
+			buf_incrpos(ses->payload, buflen);
 			len -= buflen;
 		}
 	}
@@ -861,7 +861,7 @@
 	
 	channel = getchannel();
 	
-	incr = buf_getint(ses.payload);
+	incr = buf_getint(ses->payload);
 	TRACE(("received window increment %d", incr))
 	incr = MIN(incr, TRANS_MAX_WIN_INCR);
 	
@@ -878,9 +878,9 @@
 	TRACE(("sending window adjust %d", incr))
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_WINDOW_ADJUST);
-	buf_putint(ses.writepayload, channel->remotechan);
-	buf_putint(ses.writepayload, incr);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_WINDOW_ADJUST);
+	buf_putint(ses->writepayload, channel->remotechan);
+	buf_putint(ses->writepayload, incr);
 
 	encrypt_packet();
 }
@@ -901,12 +901,12 @@
 	TRACE(("enter recv_msg_channel_open"))
 
 	/* get the packet contents */
-	type = buf_getstring(ses.payload, &typelen);
+	type = buf_getstring(ses->payload, &typelen);
 
-	remotechan = buf_getint(ses.payload);
-	transwindow = buf_getint(ses.payload);
+	remotechan = buf_getint(ses->payload);
+	transwindow = buf_getint(ses->payload);
 	transwindow = MIN(transwindow, TRANS_MAX_WINDOW);
-	transmaxpacket = buf_getint(ses.payload);
+	transmaxpacket = buf_getint(ses->payload);
 	transmaxpacket = MIN(transmaxpacket, TRANS_MAX_PAYLOAD_LEN);
 
 	/* figure what type of packet it is */
@@ -915,9 +915,9 @@
 	}
 
 	/* Get the channel type. Client and server style invokation will set up a
-	 * different list for ses.chantypes at startup. We just iterate through
+	 * different list for ses->chantypes at startup. We just iterate through
 	 * this list and find the matching name */
-	for (cp = &ses.chantypes[0], chantype = (*cp); 
+	for (cp = &ses->chantypes[0], chantype = (*cp); 
 			chantype != NULL;
 			cp++, chantype = (*cp)) {
 		if (strcmp(type, chantype->name) == 0) {
@@ -983,8 +983,8 @@
 	}
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_FAILURE);
-	buf_putint(ses.writepayload, channel->remotechan);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_FAILURE);
+	buf_putint(ses->writepayload, channel->remotechan);
 
 	encrypt_packet();
 	TRACE(("leave send_msg_channel_failure"))
@@ -1000,8 +1000,8 @@
 	}
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_SUCCESS);
-	buf_putint(ses.writepayload, channel->remotechan);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_SUCCESS);
+	buf_putint(ses->writepayload, channel->remotechan);
 
 	encrypt_packet();
 	TRACE(("leave send_msg_channel_success"))
@@ -1015,11 +1015,11 @@
 	TRACE(("enter send_msg_channel_open_failure"))
 	CHECKCLEARTOWRITE();
 	
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_OPEN_FAILURE);
-	buf_putint(ses.writepayload, remotechan);
-	buf_putint(ses.writepayload, reason);
-	buf_putstring(ses.writepayload, text, strlen(text));
-	buf_putstring(ses.writepayload, lang, strlen(lang));
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_OPEN_FAILURE);
+	buf_putint(ses->writepayload, remotechan);
+	buf_putint(ses->writepayload, reason);
+	buf_putstring(ses->writepayload, text, strlen(text));
+	buf_putstring(ses->writepayload, lang, strlen(lang));
 
 	encrypt_packet();
 	TRACE(("leave send_msg_channel_open_failure"))
@@ -1034,11 +1034,11 @@
 	TRACE(("enter send_msg_channel_open_confirmation"))
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
-	buf_putint(ses.writepayload, channel->remotechan);
-	buf_putint(ses.writepayload, channel->index);
-	buf_putint(ses.writepayload, recvwindow);
-	buf_putint(ses.writepayload, recvmaxpacket);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_OPEN_CONFIRMATION);
+	buf_putint(ses->writepayload, channel->remotechan);
+	buf_putint(ses->writepayload, channel->index);
+	buf_putint(ses->writepayload, recvwindow);
+	buf_putint(ses->writepayload, recvmaxpacket);
 
 	encrypt_packet();
 	TRACE(("leave send_msg_channel_open_confirmation"))
@@ -1111,7 +1111,7 @@
 	setnonblocking(fd);
 
 	chan->writefd = chan->readfd = fd;
-	ses.maxfd = MAX(ses.maxfd, fd);
+	ses->maxfd = MAX(ses->maxfd, fd);
 	chan->bidir_fd = 1;
 
 	chan->await_open = 1;
@@ -1119,11 +1119,11 @@
 	/* now open the channel connection */
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_OPEN);
-	buf_putstring(ses.writepayload, type->name, strlen(type->name));
-	buf_putint(ses.writepayload, chan->index);
-	buf_putint(ses.writepayload, opts.recv_window);
-	buf_putint(ses.writepayload, RECV_MAX_CHANNEL_DATA_LEN);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_OPEN);
+	buf_putstring(ses->writepayload, type->name, strlen(type->name));
+	buf_putint(ses->writepayload, chan->index);
+	buf_putint(ses->writepayload, opts->recv_window);
+	buf_putint(ses->writepayload, RECV_MAX_CHANNEL_DATA_LEN);
 
 	TRACE(("leave send_msg_channel_open_init()"))
 	return DROPBEAR_SUCCESS;
@@ -1145,9 +1145,9 @@
 	}
 	channel->await_open = 0;
 
-	channel->remotechan =  buf_getint(ses.payload);
-	channel->transwindow = buf_getint(ses.payload);
-	channel->transmaxpacket = buf_getint(ses.payload);
+	channel->remotechan =  buf_getint(ses->payload);
+	channel->transwindow = buf_getint(ses->payload);
+	channel->transmaxpacket = buf_getint(ses->payload);
 	
 	TRACE(("new chan remote %d local %d", 
 				channel->remotechan, channel->index))
@@ -1185,23 +1185,23 @@
 
 void send_msg_request_success() {
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_REQUEST_SUCCESS);
+	buf_putbyte(ses->writepayload, SSH_MSG_REQUEST_SUCCESS);
 	encrypt_packet();
 }
 
 void send_msg_request_failure() {
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_REQUEST_FAILURE);
+	buf_putbyte(ses->writepayload, SSH_MSG_REQUEST_FAILURE);
 	encrypt_packet();
 }
 
 struct Channel* get_any_ready_channel() {
 	size_t i;
-	if (ses.chancount == 0) {
+	if (ses->chancount == 0) {
 		return NULL;
 	}
-	for (i = 0; i < ses.chansize; i++) {
-		struct Channel *chan = ses.channels[i];
+	for (i = 0; i < ses->chansize; i++) {
+		struct Channel *chan = ses->channels[i];
 		if (chan
 				&& !(chan->sent_eof || chan->recv_eof)
 				&& !(chan->await_open)) {
@@ -1215,9 +1215,9 @@
 		const char *type) {
 
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_REQUEST);
-	buf_putint(ses.writepayload, channel->remotechan);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_REQUEST);
+	buf_putint(ses->writepayload, channel->remotechan);
 
-	buf_putstring(ses.writepayload, type, strlen(type));
+	buf_putstring(ses->writepayload, type, strlen(type));
 
 }
diff -aur dropbear-2022.83/common-kex.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-kex.c
--- dropbear-2022.83/common-kex.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-kex.c	2023-08-09 16:05:01.044016161 +0600
@@ -55,65 +55,65 @@
 void send_msg_kexinit() {
 
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_KEXINIT);
+	buf_putbyte(ses->writepayload, SSH_MSG_KEXINIT);
 
 	/* cookie */
-	genrandom(buf_getwriteptr(ses.writepayload, 16), 16);
-	buf_incrwritepos(ses.writepayload, 16);
+	genrandom(buf_getwriteptr(ses->writepayload, 16), 16);
+	buf_incrwritepos(ses->writepayload, 16);
 
 	/* kex algos */
-	buf_put_algolist(ses.writepayload, sshkex);
+	buf_put_algolist(ses->writepayload, sshkex);
 
 	/* server_host_key_algorithms */
-	buf_put_algolist(ses.writepayload, sigalgs);
+	buf_put_algolist(ses->writepayload, sigalgs);
 
 	/* encryption_algorithms_client_to_server */
-	buf_put_algolist(ses.writepayload, sshciphers);
+	buf_put_algolist(ses->writepayload, sshciphers);
 
 	/* encryption_algorithms_server_to_client */
-	buf_put_algolist(ses.writepayload, sshciphers);
+	buf_put_algolist(ses->writepayload, sshciphers);
 
 	/* mac_algorithms_client_to_server */
-	buf_put_algolist(ses.writepayload, sshhashes);
+	buf_put_algolist(ses->writepayload, sshhashes);
 
 	/* mac_algorithms_server_to_client */
-	buf_put_algolist(ses.writepayload, sshhashes);
+	buf_put_algolist(ses->writepayload, sshhashes);
 
 
 	/* compression_algorithms_client_to_server */
-	buf_put_algolist(ses.writepayload, ses.compress_algos);
+	buf_put_algolist(ses->writepayload, ses->compress_algos);
 
 	/* compression_algorithms_server_to_client */
-	buf_put_algolist(ses.writepayload, ses.compress_algos);
+	buf_put_algolist(ses->writepayload, ses->compress_algos);
 
 	/* languages_client_to_server */
-	buf_putstring(ses.writepayload, "", 0);
+	buf_putstring(ses->writepayload, "", 0);
 
 	/* languages_server_to_client */
-	buf_putstring(ses.writepayload, "", 0);
+	buf_putstring(ses->writepayload, "", 0);
 
 	/* first_kex_packet_follows */
-	buf_putbyte(ses.writepayload, (ses.send_kex_first_guess != NULL));
+	buf_putbyte(ses->writepayload, (ses->send_kex_first_guess != NULL));
 
 	/* reserved unit32 */
-	buf_putint(ses.writepayload, 0);
+	buf_putint(ses->writepayload, 0);
 
 	/* set up transmitted kex packet buffer for hashing. 
 	 * This is freed after the end of the kex */
-	ses.transkexinit = buf_newcopy(ses.writepayload);
+	ses->transkexinit = buf_newcopy(ses->writepayload);
 
 	encrypt_packet();
-	ses.dataallowed = 0; /* don't send other packets during kex */
+	ses->dataallowed = 0; /* don't send other packets during kex */
 
-	ses.kexstate.sentkexinit = 1;
+	ses->kexstate.sentkexinit = 1;
 
-	ses.newkeys = (struct key_context*)m_malloc(sizeof(struct key_context));
+	ses->newkeys = (struct key_context*)m_malloc(sizeof(struct key_context));
 
-	if (ses.send_kex_first_guess) {
-		ses.newkeys->algo_kex = first_usable_algo(sshkex)->data;
-		ses.newkeys->algo_signature = first_usable_algo(sigalgs)->val;
-		ses.newkeys->algo_hostkey = signkey_type_from_signature(ses.newkeys->algo_signature);
-		ses.send_kex_first_guess();
+	if (ses->send_kex_first_guess) {
+		ses->newkeys->algo_kex = first_usable_algo(sshkex)->data;
+		ses->newkeys->algo_signature = first_usable_algo(sigalgs)->val;
+		ses->newkeys->algo_hostkey = signkey_type_from_signature(ses->newkeys->algo_signature);
+		ses->send_kex_first_guess();
 	}
 
 	TRACE(("DATAALLOWED=0"))
@@ -123,40 +123,40 @@
 
 static void switch_keys() {
 	TRACE2(("enter switch_keys"))
-	if (!(ses.kexstate.sentkexinit && ses.kexstate.recvkexinit)) {
+	if (!(ses->kexstate.sentkexinit && ses->kexstate.recvkexinit)) {
 		dropbear_exit("Unexpected newkeys message");
 	}
 
-	if (!ses.keys) {
-		ses.keys = m_malloc(sizeof(*ses.newkeys));
+	if (!ses->keys) {
+		ses->keys = m_malloc(sizeof(*ses->newkeys));
 	}
-	if (ses.kexstate.recvnewkeys && ses.newkeys->recv.valid) {
+	if (ses->kexstate.recvnewkeys && ses->newkeys->recv.valid) {
 		TRACE(("switch_keys recv"))
 #ifndef DISABLE_ZLIB
 		gen_new_zstream_recv();
 #endif
-		ses.keys->recv = ses.newkeys->recv;
-		m_burn(&ses.newkeys->recv, sizeof(ses.newkeys->recv));
-		ses.newkeys->recv.valid = 0;
+		ses->keys->recv = ses->newkeys->recv;
+		m_burn(&ses->newkeys->recv, sizeof(ses->newkeys->recv));
+		ses->newkeys->recv.valid = 0;
 	}
-	if (ses.kexstate.sentnewkeys && ses.newkeys->trans.valid) {
+	if (ses->kexstate.sentnewkeys && ses->newkeys->trans.valid) {
 		TRACE(("switch_keys trans"))
 #ifndef DISABLE_ZLIB
 		gen_new_zstream_trans();
 #endif
-		ses.keys->trans = ses.newkeys->trans;
-		m_burn(&ses.newkeys->trans, sizeof(ses.newkeys->trans));
-		ses.newkeys->trans.valid = 0;
+		ses->keys->trans = ses->newkeys->trans;
+		m_burn(&ses->newkeys->trans, sizeof(ses->newkeys->trans));
+		ses->newkeys->trans.valid = 0;
 	}
-	if (ses.kexstate.sentnewkeys && ses.kexstate.recvnewkeys)
+	if (ses->kexstate.sentnewkeys && ses->kexstate.recvnewkeys)
 	{
 		TRACE(("switch_keys done"))
-		ses.keys->algo_kex = ses.newkeys->algo_kex;
-		ses.keys->algo_hostkey = ses.newkeys->algo_hostkey;
-		ses.keys->algo_signature = ses.newkeys->algo_signature;
-		ses.keys->allow_compress = 0;
-		m_free(ses.newkeys);
-		ses.newkeys = NULL;
+		ses->keys->algo_kex = ses->newkeys->algo_kex;
+		ses->keys->algo_hostkey = ses->newkeys->algo_hostkey;
+		ses->keys->algo_signature = ses->newkeys->algo_signature;
+		ses->keys->allow_compress = 0;
+		m_free(ses->newkeys);
+		ses->newkeys = NULL;
 		kexinitialise();
 	}
 	TRACE2(("leave switch_keys"))
@@ -169,17 +169,17 @@
 
 	/* generate the kexinit request */
 	CHECKCLEARTOWRITE();
-	buf_putbyte(ses.writepayload, SSH_MSG_NEWKEYS);
+	buf_putbyte(ses->writepayload, SSH_MSG_NEWKEYS);
 	encrypt_packet();
 
 	
 	/* set up our state */
-	ses.kexstate.sentnewkeys = 1;
-	if (ses.kexstate.donefirstkex) {
-		ses.kexstate.donesecondkex = 1;
+	ses->kexstate.sentnewkeys = 1;
+	if (ses->kexstate.donefirstkex) {
+		ses->kexstate.donesecondkex = 1;
 	}
-	ses.kexstate.donefirstkex = 1;
-	ses.dataallowed = 1; /* we can send other packets again now */
+	ses->kexstate.donefirstkex = 1;
+	ses->dataallowed = 1; /* we can send other packets again now */
 	gen_new_keys();
 	switch_keys();
 
@@ -191,7 +191,7 @@
 
 	TRACE(("enter recv_msg_newkeys"))
 
-	ses.kexstate.recvnewkeys = 1;
+	ses->kexstate.recvnewkeys = 1;
 	switch_keys();
 	
 	TRACE(("leave recv_msg_newkeys"))
@@ -201,20 +201,20 @@
 /* Set up the kex for the first time */
 void kexfirstinitialise() {
 #ifdef DISABLE_ZLIB
-	ses.compress_algos = ssh_nocompress;
+	ses->compress_algos = ssh_nocompress;
 #else
-	switch (opts.compress_mode)
+	switch (opts->compress_mode)
 	{
 		case DROPBEAR_COMPRESS_DELAYED:
-			ses.compress_algos = ssh_delaycompress;
+			ses->compress_algos = ssh_delaycompress;
 			break;
 
 		case DROPBEAR_COMPRESS_ON:
-			ses.compress_algos = ssh_compress;
+			ses->compress_algos = ssh_compress;
 			break;
 
 		case DROPBEAR_COMPRESS_OFF:
-			ses.compress_algos = ssh_nocompress;
+			ses->compress_algos = ssh_nocompress;
 			break;
 	}
 #endif
@@ -227,22 +227,22 @@
 	TRACE(("kexinitialise()"))
 
 	/* sent/recv'd MSG_KEXINIT */
-	ses.kexstate.sentkexinit = 0;
-	ses.kexstate.recvkexinit = 0;
+	ses->kexstate.sentkexinit = 0;
+	ses->kexstate.recvkexinit = 0;
 
 	/* sent/recv'd MSG_NEWKEYS */
-	ses.kexstate.recvnewkeys = 0;
-	ses.kexstate.sentnewkeys = 0;
+	ses->kexstate.recvnewkeys = 0;
+	ses->kexstate.sentnewkeys = 0;
 
 	/* first_packet_follows */
-	ses.kexstate.them_firstfollows = 0;
+	ses->kexstate.them_firstfollows = 0;
 
-	ses.kexstate.datatrans = 0;
-	ses.kexstate.datarecv = 0;
+	ses->kexstate.datatrans = 0;
+	ses->kexstate.datarecv = 0;
 
-	ses.kexstate.our_first_follows_matches = 0;
+	ses->kexstate.our_first_follows_matches = 0;
 
-	ses.kexstate.lastkextime = monotonic_now();
+	ses->kexstate.lastkextime = monotonic_now();
 
 }
 
@@ -255,14 +255,14 @@
 static void hashkeys(unsigned char *out, unsigned int outlen, 
 		const hash_state * hs, const unsigned char X) {
 
-	const struct ltc_hash_descriptor *hash_desc = ses.newkeys->algo_kex->hash_desc;
+	const struct ltc_hash_descriptor *hash_desc = ses->newkeys->algo_kex->hash_desc;
 	hash_state hs2;
 	unsigned int offset;
 	unsigned char tmpout[MAX_HASH_SIZE];
 
 	memcpy(&hs2, hs, sizeof(hash_state));
 	hash_desc->process(&hs2, &X, 1);
-	hash_desc->process(&hs2, ses.session_id->data, ses.session_id->len);
+	hash_desc->process(&hs2, ses->session_id->data, ses->session_id->len);
 	hash_desc->done(&hs2, tmpout);
 	memcpy(out, tmpout, MIN(hash_desc->hashsize, outlen));
 	for (offset = hash_desc->hashsize; 
@@ -282,7 +282,7 @@
  * key exchange, as specified in section 7.2 of the transport rfc 4253.
  * This occurs after the DH key-exchange.
  *
- * ses.newkeys is the new set of keys which are generated, these are only
+ * ses->newkeys is the new set of keys which are generated, these are only
  * taken into use after both sides have sent a newkeys message */
 
 static void gen_new_keys() {
@@ -295,19 +295,19 @@
 	unsigned char *trans_IV, *trans_key, *recv_IV, *recv_key;
 
 	hash_state hs;
-	const struct ltc_hash_descriptor *hash_desc = ses.newkeys->algo_kex->hash_desc;
+	const struct ltc_hash_descriptor *hash_desc = ses->newkeys->algo_kex->hash_desc;
 	char mactransletter, macrecvletter; /* Client or server specific */
 
 	TRACE(("enter gen_new_keys"))
 	/* the dh_K and hash are the start of all hashes, we make use of that */
 
 	hash_desc->init(&hs);
-	hash_process_mp(hash_desc, &hs, ses.dh_K);
-	mp_clear(ses.dh_K);
-	m_free(ses.dh_K);
-	hash_desc->process(&hs, ses.hash->data, ses.hash->len);
-	buf_burn_free(ses.hash);
-	ses.hash = NULL;
+	hash_process_mp(hash_desc, &hs, ses->dh_K);
+	mp_clear(ses->dh_K);
+	m_free(ses->dh_K);
+	hash_desc->process(&hs, ses->hash->data, ses->hash->len);
+	buf_burn_free(ses->hash);
+	ses->hash = NULL;
 
 	if (IS_DROPBEAR_CLIENT) {
 		trans_IV	= C2S_IV;
@@ -330,53 +330,53 @@
 	hashkeys(C2S_key, sizeof(C2S_key), &hs, 'C');
 	hashkeys(S2C_key, sizeof(S2C_key), &hs, 'D');
 
-	if (ses.newkeys->recv.algo_crypt->cipherdesc != NULL) {
+	if (ses->newkeys->recv.algo_crypt->cipherdesc != NULL) {
 		int recv_cipher = -1;
-		if (ses.newkeys->recv.algo_crypt->cipherdesc->name != NULL) {
-			recv_cipher = find_cipher(ses.newkeys->recv.algo_crypt->cipherdesc->name);
+		if (ses->newkeys->recv.algo_crypt->cipherdesc->name != NULL) {
+			recv_cipher = find_cipher(ses->newkeys->recv.algo_crypt->cipherdesc->name);
 			if (recv_cipher < 0) {
 				dropbear_exit("Crypto error");
 			}
 		}
-		if (ses.newkeys->recv.crypt_mode->start(recv_cipher, 
+		if (ses->newkeys->recv.crypt_mode->start(recv_cipher, 
 				recv_IV, recv_key, 
-				ses.newkeys->recv.algo_crypt->keysize, 0, 
-				&ses.newkeys->recv.cipher_state) != CRYPT_OK) {
+				ses->newkeys->recv.algo_crypt->keysize, 0, 
+				&ses->newkeys->recv.cipher_state) != CRYPT_OK) {
 			dropbear_exit("Crypto error");
 		}
 	}
 
-	if (ses.newkeys->trans.algo_crypt->cipherdesc != NULL) {
+	if (ses->newkeys->trans.algo_crypt->cipherdesc != NULL) {
 		int trans_cipher = -1;
-		if (ses.newkeys->trans.algo_crypt->cipherdesc->name != NULL) {
-			trans_cipher = find_cipher(ses.newkeys->trans.algo_crypt->cipherdesc->name);
+		if (ses->newkeys->trans.algo_crypt->cipherdesc->name != NULL) {
+			trans_cipher = find_cipher(ses->newkeys->trans.algo_crypt->cipherdesc->name);
 			if (trans_cipher < 0) {
 				dropbear_exit("Crypto error");
 			}
 		}
-		if (ses.newkeys->trans.crypt_mode->start(trans_cipher, 
+		if (ses->newkeys->trans.crypt_mode->start(trans_cipher, 
 				trans_IV, trans_key, 
-				ses.newkeys->trans.algo_crypt->keysize, 0, 
-				&ses.newkeys->trans.cipher_state) != CRYPT_OK) {
+				ses->newkeys->trans.algo_crypt->keysize, 0, 
+				&ses->newkeys->trans.cipher_state) != CRYPT_OK) {
 			dropbear_exit("Crypto error");
 		}
 	}
 
-	if (ses.newkeys->trans.algo_mac->hash_desc != NULL) {
-		hashkeys(ses.newkeys->trans.mackey, 
-				ses.newkeys->trans.algo_mac->keysize, &hs, mactransletter);
-		ses.newkeys->trans.hash_index = find_hash(ses.newkeys->trans.algo_mac->hash_desc->name);
+	if (ses->newkeys->trans.algo_mac->hash_desc != NULL) {
+		hashkeys(ses->newkeys->trans.mackey, 
+				ses->newkeys->trans.algo_mac->keysize, &hs, mactransletter);
+		ses->newkeys->trans.hash_index = find_hash(ses->newkeys->trans.algo_mac->hash_desc->name);
 	}
 
-	if (ses.newkeys->recv.algo_mac->hash_desc != NULL) {
-		hashkeys(ses.newkeys->recv.mackey, 
-				ses.newkeys->recv.algo_mac->keysize, &hs, macrecvletter);
-		ses.newkeys->recv.hash_index = find_hash(ses.newkeys->recv.algo_mac->hash_desc->name);
+	if (ses->newkeys->recv.algo_mac->hash_desc != NULL) {
+		hashkeys(ses->newkeys->recv.mackey, 
+				ses->newkeys->recv.algo_mac->keysize, &hs, macrecvletter);
+		ses->newkeys->recv.hash_index = find_hash(ses->newkeys->recv.algo_mac->hash_desc->name);
 	}
 
 	/* Ready to switch over */
-	ses.newkeys->trans.valid = 1;
-	ses.newkeys->recv.valid = 1;
+	ses->newkeys->trans.valid = 1;
+	ses->newkeys->recv.valid = 1;
 
 	m_burn(C2S_IV, sizeof(C2S_IV));
 	m_burn(C2S_key, sizeof(C2S_key));
@@ -390,15 +390,15 @@
 #ifndef DISABLE_ZLIB
 
 int is_compress_trans() {
-	return ses.keys->trans.algo_comp == DROPBEAR_COMP_ZLIB
-		|| (ses.authstate.authdone
-			&& ses.keys->trans.algo_comp == DROPBEAR_COMP_ZLIB_DELAY);
+	return ses->keys->trans.algo_comp == DROPBEAR_COMP_ZLIB
+		|| (ses->authstate.authdone
+			&& ses->keys->trans.algo_comp == DROPBEAR_COMP_ZLIB_DELAY);
 }
 
 int is_compress_recv() {
-	return ses.keys->recv.algo_comp == DROPBEAR_COMP_ZLIB
-		|| (ses.authstate.authdone
-			&& ses.keys->recv.algo_comp == DROPBEAR_COMP_ZLIB_DELAY);
+	return ses->keys->recv.algo_comp == DROPBEAR_COMP_ZLIB
+		|| (ses->authstate.authdone
+			&& ses->keys->recv.algo_comp == DROPBEAR_COMP_ZLIB_DELAY);
 }
 
 static void* dropbear_zalloc(void* UNUSED(opaque), uInt items, uInt size) {
@@ -414,52 +414,52 @@
 static void gen_new_zstream_recv() {
 
 	/* create new zstreams */
-	if (ses.newkeys->recv.algo_comp == DROPBEAR_COMP_ZLIB
-			|| ses.newkeys->recv.algo_comp == DROPBEAR_COMP_ZLIB_DELAY) {
-		ses.newkeys->recv.zstream = (z_streamp)m_malloc(sizeof(z_stream));
-		ses.newkeys->recv.zstream->zalloc = dropbear_zalloc;
-		ses.newkeys->recv.zstream->zfree = dropbear_zfree;
+	if (ses->newkeys->recv.algo_comp == DROPBEAR_COMP_ZLIB
+			|| ses->newkeys->recv.algo_comp == DROPBEAR_COMP_ZLIB_DELAY) {
+		ses->newkeys->recv.zstream = (z_streamp)m_malloc(sizeof(z_stream));
+		ses->newkeys->recv.zstream->zalloc = dropbear_zalloc;
+		ses->newkeys->recv.zstream->zfree = dropbear_zfree;
 		
-		if (inflateInit(ses.newkeys->recv.zstream) != Z_OK) {
+		if (inflateInit(ses->newkeys->recv.zstream) != Z_OK) {
 			dropbear_exit("zlib error");
 		}
 	} else {
-		ses.newkeys->recv.zstream = NULL;
+		ses->newkeys->recv.zstream = NULL;
 	}
 	/* clean up old keys */
-	if (ses.keys->recv.zstream != NULL) {
-		if (inflateEnd(ses.keys->recv.zstream) == Z_STREAM_ERROR) {
+	if (ses->keys->recv.zstream != NULL) {
+		if (inflateEnd(ses->keys->recv.zstream) == Z_STREAM_ERROR) {
 			/* Z_DATA_ERROR is ok, just means that stream isn't ended */
 			dropbear_exit("Crypto error");
 		}
-		m_free(ses.keys->recv.zstream);
+		m_free(ses->keys->recv.zstream);
 	}
 }
 
 static void gen_new_zstream_trans() {
 
-	if (ses.newkeys->trans.algo_comp == DROPBEAR_COMP_ZLIB
-			|| ses.newkeys->trans.algo_comp == DROPBEAR_COMP_ZLIB_DELAY) {
-		ses.newkeys->trans.zstream = (z_streamp)m_malloc(sizeof(z_stream));
-		ses.newkeys->trans.zstream->zalloc = dropbear_zalloc;
-		ses.newkeys->trans.zstream->zfree = dropbear_zfree;
+	if (ses->newkeys->trans.algo_comp == DROPBEAR_COMP_ZLIB
+			|| ses->newkeys->trans.algo_comp == DROPBEAR_COMP_ZLIB_DELAY) {
+		ses->newkeys->trans.zstream = (z_streamp)m_malloc(sizeof(z_stream));
+		ses->newkeys->trans.zstream->zalloc = dropbear_zalloc;
+		ses->newkeys->trans.zstream->zfree = dropbear_zfree;
 	
-		if (deflateInit2(ses.newkeys->trans.zstream, Z_DEFAULT_COMPRESSION,
+		if (deflateInit2(ses->newkeys->trans.zstream, Z_DEFAULT_COMPRESSION,
 					Z_DEFLATED, DROPBEAR_ZLIB_WINDOW_BITS, 
 					DROPBEAR_ZLIB_MEM_LEVEL, Z_DEFAULT_STRATEGY)
 				!= Z_OK) {
 			dropbear_exit("zlib error");
 		}
 	} else {
-		ses.newkeys->trans.zstream = NULL;
+		ses->newkeys->trans.zstream = NULL;
 	}
 
-	if (ses.keys->trans.zstream != NULL) {
-		if (deflateEnd(ses.keys->trans.zstream) == Z_STREAM_ERROR) {
+	if (ses->keys->trans.zstream != NULL) {
+		if (deflateEnd(ses->keys->trans.zstream) == Z_STREAM_ERROR) {
 			/* Z_DATA_ERROR is ok, just means that stream isn't ended */
 			dropbear_exit("Crypto error");
 		}
-		m_free(ses.keys->trans.zstream);
+		m_free(ses->keys->trans.zstream);
 	}
 }
 #endif /* DISABLE_ZLIB */
@@ -480,7 +480,7 @@
 	TRACE(("<- KEXINIT"))
 	TRACE(("enter recv_msg_kexinit"))
 	
-	if (!ses.kexstate.sentkexinit) {
+	if (!ses->kexstate.sentkexinit) {
 		/* we need to send a kex packet */
 		send_msg_kexinit();
 		TRACE(("continue recv_msg_kexinit: sent kexinit"))
@@ -488,19 +488,19 @@
 
 	/* "Once a party has sent a SSH_MSG_KEXINIT message ...
 	further SSH_MSG_KEXINIT messages MUST NOT be sent" */
-	if (ses.kexstate.recvkexinit) {
+	if (ses->kexstate.recvkexinit) {
 		dropbear_exit("Unexpected KEXINIT");
 	}
 
 	/* start the kex hash */
 	local_ident_len = strlen(LOCAL_IDENT);
-	remote_ident_len = strlen(ses.remoteident);
+	remote_ident_len = strlen(ses->remoteident);
 
 	kexhashbuf_len = local_ident_len + remote_ident_len
-		+ ses.transkexinit->len + ses.payload->len
+		+ ses->transkexinit->len + ses->payload->len
 		+ KEXHASHBUF_MAX_INTS;
 
-	ses.kexhashbuf = buf_new(kexhashbuf_len);
+	ses->kexhashbuf = buf_new(kexhashbuf_len);
 
 	if (IS_DROPBEAR_CLIENT) {
 
@@ -508,47 +508,47 @@
 		read_kex_algos();
 
 		/* V_C, the client's version string (CR and NL excluded) */
-		buf_putstring(ses.kexhashbuf, LOCAL_IDENT, local_ident_len);
+		buf_putstring(ses->kexhashbuf, LOCAL_IDENT, local_ident_len);
 		/* V_S, the server's version string (CR and NL excluded) */
-		buf_putstring(ses.kexhashbuf, ses.remoteident, remote_ident_len);
+		buf_putstring(ses->kexhashbuf, ses->remoteident, remote_ident_len);
 
 		/* I_C, the payload of the client's SSH_MSG_KEXINIT */
-		buf_putstring(ses.kexhashbuf,
-			(const char*)ses.transkexinit->data, ses.transkexinit->len);
+		buf_putstring(ses->kexhashbuf,
+			(const char*)ses->transkexinit->data, ses->transkexinit->len);
 		/* I_S, the payload of the server's SSH_MSG_KEXINIT */
-		buf_setpos(ses.payload, ses.payload_beginning);
-		buf_putstring(ses.kexhashbuf,
-			(const char*)buf_getptr(ses.payload, ses.payload->len-ses.payload->pos),
-			ses.payload->len-ses.payload->pos);
-		ses.requirenext = SSH_MSG_KEXDH_REPLY;
+		buf_setpos(ses->payload, ses->payload_beginning);
+		buf_putstring(ses->kexhashbuf,
+			(const char*)buf_getptr(ses->payload, ses->payload->len-ses->payload->pos),
+			ses->payload->len-ses->payload->pos);
+		ses->requirenext = SSH_MSG_KEXDH_REPLY;
 	} else {
 		/* SERVER */
 
 		/* read the peer's choice of algos */
 		read_kex_algos();
 		/* V_C, the client's version string (CR and NL excluded) */
-		buf_putstring(ses.kexhashbuf, ses.remoteident, remote_ident_len);
+		buf_putstring(ses->kexhashbuf, ses->remoteident, remote_ident_len);
 		/* V_S, the server's version string (CR and NL excluded) */
-		buf_putstring(ses.kexhashbuf, LOCAL_IDENT, local_ident_len);
+		buf_putstring(ses->kexhashbuf, LOCAL_IDENT, local_ident_len);
 
 		/* I_C, the payload of the client's SSH_MSG_KEXINIT */
-		buf_setpos(ses.payload, ses.payload_beginning);
-		buf_putstring(ses.kexhashbuf, 
-			(const char*)buf_getptr(ses.payload, ses.payload->len-ses.payload->pos),
-			ses.payload->len-ses.payload->pos);
+		buf_setpos(ses->payload, ses->payload_beginning);
+		buf_putstring(ses->kexhashbuf, 
+			(const char*)buf_getptr(ses->payload, ses->payload->len-ses->payload->pos),
+			ses->payload->len-ses->payload->pos);
 
 		/* I_S, the payload of the server's SSH_MSG_KEXINIT */
-		buf_putstring(ses.kexhashbuf,
-			(const char*)ses.transkexinit->data, ses.transkexinit->len);
+		buf_putstring(ses->kexhashbuf,
+			(const char*)ses->transkexinit->data, ses->transkexinit->len);
 
-		ses.requirenext = SSH_MSG_KEXDH_INIT;
+		ses->requirenext = SSH_MSG_KEXDH_INIT;
 	}
 
-	buf_free(ses.transkexinit);
-	ses.transkexinit = NULL;
-	/* the rest of ses.kexhashbuf will be done after DH exchange */
+	buf_free(ses->transkexinit);
+	ses->transkexinit = NULL;
+	/* the rest of ses->kexhashbuf will be done after DH exchange */
 
-	ses.kexstate.recvkexinit = 1;
+	ses->kexstate.recvkexinit = 1;
 
 	TRACE(("leave recv_msg_kexinit"))
 }
@@ -556,8 +556,8 @@
 #if DROPBEAR_NORMAL_DH
 static void load_dh_p(mp_int * dh_p)
 {
-	bytes_to_mp(dh_p, ses.newkeys->algo_kex->dh_p_bytes, 
-		ses.newkeys->algo_kex->dh_p_len);
+	bytes_to_mp(dh_p, ses->newkeys->algo_kex->dh_p_bytes, 
+		ses->newkeys->algo_kex->dh_p_len);
 }
 
 /* Initialises and generate one side of the diffie-hellman key exchange values.
@@ -631,8 +631,8 @@
 	}
 	
 	/* K = e^y mod p = f^x mod p */
-	m_mp_alloc_init_multi(&ses.dh_K, NULL);
-	if (mp_exptmod(dh_pub_them, &param->priv, &dh_p, ses.dh_K) != MP_OKAY) {
+	m_mp_alloc_init_multi(&ses->dh_K, NULL);
+	if (mp_exptmod(dh_pub_them, &param->priv, &dh_p, ses->dh_K) != MP_OKAY) {
 		dropbear_exit("Diffie-Hellman error");
 	}
 
@@ -651,13 +651,13 @@
 
 	/* Create the remainder of the hash buffer, to generate the exchange hash */
 	/* K_S, the host key */
-	buf_put_pub_key(ses.kexhashbuf, hostkey, ses.newkeys->algo_hostkey);
+	buf_put_pub_key(ses->kexhashbuf, hostkey, ses->newkeys->algo_hostkey);
 	/* e, exchange value sent by the client */
-	buf_putmpint(ses.kexhashbuf, dh_e);
+	buf_putmpint(ses->kexhashbuf, dh_e);
 	/* f, exchange value sent by the server */
-	buf_putmpint(ses.kexhashbuf, dh_f);
+	buf_putmpint(ses->kexhashbuf, dh_f);
 	/* K, the shared secret */
-	buf_putmpint(ses.kexhashbuf, ses.dh_K);
+	buf_putmpint(ses->kexhashbuf, ses->dh_K);
 
 	/* calculate the hash H to sign */
 	finish_kexhashbuf();
@@ -668,7 +668,7 @@
 struct kex_ecdh_param *gen_kexecdh_param() {
 	struct kex_ecdh_param *param = m_malloc(sizeof(*param));
 	if (ecc_make_key_ex(NULL, dropbear_ltc_prng, 
-		&param->key, ses.newkeys->algo_kex->ecc_curve->dp) != CRYPT_OK) {
+		&param->key, ses->newkeys->algo_kex->ecc_curve->dp) != CRYPT_OK) {
 		dropbear_exit("ECC error");
 	}
 	return param;
@@ -681,7 +681,7 @@
 }
 void kexecdh_comb_key(struct kex_ecdh_param *param, buffer *pub_them,
 		sign_key *hostkey) {
-	const struct dropbear_kex *algo_kex = ses.newkeys->algo_kex;
+	const struct dropbear_kex *algo_kex = ses->newkeys->algo_kex;
 	/* public keys from client and server */
 	ecc_key *Q_C, *Q_S, *Q_them;
 
@@ -690,7 +690,7 @@
 		dropbear_exit("ECC error");
 	}
 
-	ses.dh_K = dropbear_ecc_shared_secret(Q_them, &param->key);
+	ses->dh_K = dropbear_ecc_shared_secret(Q_them, &param->key);
 
 	/* Create the remainder of the hash buffer, to generate the exchange hash
 	   See RFC5656 section 4 page 7 */
@@ -703,13 +703,13 @@
 	} 
 
 	/* K_S, the host key */
-	buf_put_pub_key(ses.kexhashbuf, hostkey, ses.newkeys->algo_hostkey);
+	buf_put_pub_key(ses->kexhashbuf, hostkey, ses->newkeys->algo_hostkey);
 	/* Q_C, client's ephemeral public key octet string */
-	buf_put_ecc_raw_pubkey_string(ses.kexhashbuf, Q_C);
+	buf_put_ecc_raw_pubkey_string(ses->kexhashbuf, Q_C);
 	/* Q_S, server's ephemeral public key octet string */
-	buf_put_ecc_raw_pubkey_string(ses.kexhashbuf, Q_S);
+	buf_put_ecc_raw_pubkey_string(ses->kexhashbuf, Q_S);
 	/* K, the shared secret */
-	buf_putmpint(ses.kexhashbuf, ses.dh_K);
+	buf_putmpint(ses->kexhashbuf, ses->dh_K);
 
 	ecc_free(Q_them);
 	m_free(Q_them);
@@ -754,8 +754,8 @@
 		dropbear_exit("Bad curve25519");
 	}
 
-	m_mp_alloc_init_multi(&ses.dh_K, NULL);
-	bytes_to_mp(ses.dh_K, out, CURVE25519_LEN);
+	m_mp_alloc_init_multi(&ses->dh_K, NULL);
+	bytes_to_mp(ses->dh_K, out, CURVE25519_LEN);
 	m_burn(out, sizeof(out));
 
 	/* Create the remainder of the hash buffer, to generate the exchange hash.
@@ -769,13 +769,13 @@
 	}
 
 	/* K_S, the host key */
-	buf_put_pub_key(ses.kexhashbuf, hostkey, ses.newkeys->algo_hostkey);
+	buf_put_pub_key(ses->kexhashbuf, hostkey, ses->newkeys->algo_hostkey);
 	/* Q_C, client's ephemeral public key octet string */
-	buf_putstring(ses.kexhashbuf, (const char*)Q_C, CURVE25519_LEN);
+	buf_putstring(ses->kexhashbuf, (const char*)Q_C, CURVE25519_LEN);
 	/* Q_S, server's ephemeral public key octet string */
-	buf_putstring(ses.kexhashbuf, (const char*)Q_S, CURVE25519_LEN);
+	buf_putstring(ses->kexhashbuf, (const char*)Q_S, CURVE25519_LEN);
 	/* K, the shared secret */
-	buf_putmpint(ses.kexhashbuf, ses.dh_K);
+	buf_putmpint(ses->kexhashbuf, ses->dh_K);
 
 	/* calculate the hash H to sign */
 	finish_kexhashbuf();
@@ -785,31 +785,31 @@
 
 void finish_kexhashbuf(void) {
 	hash_state hs;
-	const struct ltc_hash_descriptor *hash_desc = ses.newkeys->algo_kex->hash_desc;
+	const struct ltc_hash_descriptor *hash_desc = ses->newkeys->algo_kex->hash_desc;
 
 	hash_desc->init(&hs);
-	buf_setpos(ses.kexhashbuf, 0);
-	hash_desc->process(&hs, buf_getptr(ses.kexhashbuf, ses.kexhashbuf->len),
-			ses.kexhashbuf->len);
-	ses.hash = buf_new(hash_desc->hashsize);
-	hash_desc->done(&hs, buf_getwriteptr(ses.hash, hash_desc->hashsize));
-	buf_setlen(ses.hash, hash_desc->hashsize);
+	buf_setpos(ses->kexhashbuf, 0);
+	hash_desc->process(&hs, buf_getptr(ses->kexhashbuf, ses->kexhashbuf->len),
+			ses->kexhashbuf->len);
+	ses->hash = buf_new(hash_desc->hashsize);
+	hash_desc->done(&hs, buf_getwriteptr(ses->hash, hash_desc->hashsize));
+	buf_setlen(ses->hash, hash_desc->hashsize);
 
 #if defined(DEBUG_KEXHASH) && DEBUG_TRACE
 	if (!debug_trace) {
-		printhex("kexhashbuf", ses.kexhashbuf->data, ses.kexhashbuf->len);
-		printhex("kexhash", ses.hash->data, ses.hash->len);
+		printhex("kexhashbuf", ses->kexhashbuf->data, ses->kexhashbuf->len);
+		printhex("kexhash", ses->hash->data, ses->hash->len);
 	}
 #endif
 
-	buf_burn_free(ses.kexhashbuf);
+	buf_burn_free(ses->kexhashbuf);
 	m_burn(&hs, sizeof(hash_state));
-	ses.kexhashbuf = NULL;
+	ses->kexhashbuf = NULL;
 	
 	/* first time around, we set the session_id to H */
-	if (ses.session_id == NULL) {
+	if (ses->session_id == NULL) {
 		/* create the session_id, this never needs freeing */
-		ses.session_id = buf_newcopy(ses.hash);
+		ses->session_id = buf_newcopy(ses->hash);
 	}
 }
 
@@ -835,13 +835,13 @@
 						true after */
 	int kexguess2 = 0;
 
-	buf_incrpos(ses.payload, 16); /* start after the cookie */
+	buf_incrpos(ses->payload, 16); /* start after the cookie */
 
-	memset(ses.newkeys, 0x0, sizeof(*ses.newkeys));
+	memset(ses->newkeys, 0x0, sizeof(*ses->newkeys));
 
 	/* kex_algorithms */
 #if DROPBEAR_KEXGUESS2
-	if (buf_has_algo(ses.payload, KEXGUESS2_ALGO_NAME) == DROPBEAR_SUCCESS) {
+	if (buf_has_algo(ses->payload, KEXGUESS2_ALGO_NAME) == DROPBEAR_SUCCESS) {
 		kexguess2 = 1;
 	}
 #endif
@@ -851,15 +851,15 @@
 	Should be done for the first key exchange. Only required on server side
     for server-sig-algs */
 	if (IS_DROPBEAR_SERVER) {
-		if (!ses.kexstate.donefirstkex) {
-			if (buf_has_algo(ses.payload, SSH_EXT_INFO_C) == DROPBEAR_SUCCESS) {
-				ses.allow_ext_info = 1;
+		if (!ses->kexstate.donefirstkex) {
+			if (buf_has_algo(ses->payload, SSH_EXT_INFO_C) == DROPBEAR_SUCCESS) {
+				ses->allow_ext_info = 1;
 			}
 		}
 	}
 #endif
 
-	algo = buf_match_algo(ses.payload, sshkex, kexguess2, &goodguess);
+	algo = buf_match_algo(ses->payload, sshkex, kexguess2, &goodguess);
 	allgood &= goodguess;
 	if (algo == NULL || algo->data == NULL) {
 		/* kexguess2, ext-info-c, ext-info-s should not match negotiation */
@@ -868,21 +868,21 @@
 	}
 	TRACE(("kexguess2 %d", kexguess2))
 	DEBUG3(("kex algo %s", algo->name))
-	ses.newkeys->algo_kex = algo->data;
+	ses->newkeys->algo_kex = algo->data;
 
 	/* server_host_key_algorithms */
-	algo = buf_match_algo(ses.payload, sigalgs, kexguess2, &goodguess);
+	algo = buf_match_algo(ses->payload, sigalgs, kexguess2, &goodguess);
 	allgood &= goodguess;
 	if (algo == NULL) {
 		erralgo = "hostkey";
 		goto error;
 	}
 	DEBUG2(("hostkey algo %s", algo->name))
-	ses.newkeys->algo_signature = algo->val;
-	ses.newkeys->algo_hostkey = signkey_type_from_signature(ses.newkeys->algo_signature);
+	ses->newkeys->algo_signature = algo->val;
+	ses->newkeys->algo_hostkey = signkey_type_from_signature(ses->newkeys->algo_signature);
 
 	/* encryption_algorithms_client_to_server */
-	c2s_cipher_algo = buf_match_algo(ses.payload, sshciphers, 0, NULL);
+	c2s_cipher_algo = buf_match_algo(ses->payload, sshciphers, 0, NULL);
 	if (c2s_cipher_algo == NULL) {
 		erralgo = "enc c->s";
 		goto error;
@@ -890,7 +890,7 @@
 	DEBUG2(("enc  c2s is %s", c2s_cipher_algo->name))
 
 	/* encryption_algorithms_server_to_client */
-	s2c_cipher_algo = buf_match_algo(ses.payload, sshciphers, 0, NULL);
+	s2c_cipher_algo = buf_match_algo(ses->payload, sshciphers, 0, NULL);
 	if (s2c_cipher_algo == NULL) {
 		erralgo = "enc s->c";
 		goto error;
@@ -898,7 +898,7 @@
 	DEBUG2(("enc  s2c is %s", s2c_cipher_algo->name))
 
 	/* mac_algorithms_client_to_server */
-	c2s_hash_algo = buf_match_algo(ses.payload, sshhashes, 0, NULL);
+	c2s_hash_algo = buf_match_algo(ses->payload, sshhashes, 0, NULL);
 #if DROPBEAR_AEAD_MODE
 	if (((struct dropbear_cipher_mode*)c2s_cipher_algo->mode)->aead_crypt != NULL) {
 		c2s_hash_algo = NULL;
@@ -911,7 +911,7 @@
 	DEBUG2(("hmac c2s is %s", c2s_hash_algo ? c2s_hash_algo->name : "<implicit>"))
 
 	/* mac_algorithms_server_to_client */
-	s2c_hash_algo = buf_match_algo(ses.payload, sshhashes, 0, NULL);
+	s2c_hash_algo = buf_match_algo(ses->payload, sshhashes, 0, NULL);
 #if DROPBEAR_AEAD_MODE
 	if (((struct dropbear_cipher_mode*)s2c_cipher_algo->mode)->aead_crypt != NULL) {
 		s2c_hash_algo = NULL;
@@ -924,7 +924,7 @@
 	DEBUG2(("hmac s2c is %s", s2c_hash_algo ? s2c_hash_algo->name : "<implicit>"))
 
 	/* compression_algorithms_client_to_server */
-	c2s_comp_algo = buf_match_algo(ses.payload, ses.compress_algos, 0, NULL);
+	c2s_comp_algo = buf_match_algo(ses->payload, ses->compress_algos, 0, NULL);
 	if (c2s_comp_algo == NULL) {
 		erralgo = "comp c->s";
 		goto error;
@@ -932,7 +932,7 @@
 	DEBUG2(("comp c2s is %s", c2s_comp_algo->name))
 
 	/* compression_algorithms_server_to_client */
-	s2c_comp_algo = buf_match_algo(ses.payload, ses.compress_algos, 0, NULL);
+	s2c_comp_algo = buf_match_algo(ses->payload, ses->compress_algos, 0, NULL);
 	if (s2c_comp_algo == NULL) {
 		erralgo = "comp s->c";
 		goto error;
@@ -940,65 +940,65 @@
 	DEBUG2(("comp s2c is %s", s2c_comp_algo->name))
 
 	/* languages_client_to_server */
-	buf_eatstring(ses.payload);
+	buf_eatstring(ses->payload);
 
 	/* languages_server_to_client */
-	buf_eatstring(ses.payload);
+	buf_eatstring(ses->payload);
 
 	/* their first_kex_packet_follows */
-	if (buf_getbool(ses.payload)) {
+	if (buf_getbool(ses->payload)) {
 		TRACE(("them kex firstfollows. allgood %d", allgood))
-		ses.kexstate.them_firstfollows = 1;
+		ses->kexstate.them_firstfollows = 1;
 		/* if the guess wasn't good, we ignore the packet sent */
 		if (!allgood) {
-			ses.ignorenext = 1;
+			ses->ignorenext = 1;
 		}
 	}
 
 	/* Handle the asymmetry */
 	if (IS_DROPBEAR_CLIENT) {
-		ses.newkeys->recv.algo_crypt = 
+		ses->newkeys->recv.algo_crypt = 
 			(struct dropbear_cipher*)s2c_cipher_algo->data;
-		ses.newkeys->trans.algo_crypt = 
+		ses->newkeys->trans.algo_crypt = 
 			(struct dropbear_cipher*)c2s_cipher_algo->data;
-		ses.newkeys->recv.crypt_mode = 
+		ses->newkeys->recv.crypt_mode = 
 			(struct dropbear_cipher_mode*)s2c_cipher_algo->mode;
-		ses.newkeys->trans.crypt_mode =
+		ses->newkeys->trans.crypt_mode =
 			(struct dropbear_cipher_mode*)c2s_cipher_algo->mode;
-		ses.newkeys->recv.algo_mac = 
+		ses->newkeys->recv.algo_mac = 
 #if DROPBEAR_AEAD_MODE
-			s2c_hash_algo == NULL ? ses.newkeys->recv.crypt_mode->aead_mac :
+			s2c_hash_algo == NULL ? ses->newkeys->recv.crypt_mode->aead_mac :
 #endif
 			(struct dropbear_hash*)s2c_hash_algo->data;
-		ses.newkeys->trans.algo_mac = 
+		ses->newkeys->trans.algo_mac = 
 #if DROPBEAR_AEAD_MODE
-			c2s_hash_algo == NULL ? ses.newkeys->trans.crypt_mode->aead_mac :
+			c2s_hash_algo == NULL ? ses->newkeys->trans.crypt_mode->aead_mac :
 #endif
 			(struct dropbear_hash*)c2s_hash_algo->data;
-		ses.newkeys->recv.algo_comp = s2c_comp_algo->val;
-		ses.newkeys->trans.algo_comp = c2s_comp_algo->val;
+		ses->newkeys->recv.algo_comp = s2c_comp_algo->val;
+		ses->newkeys->trans.algo_comp = c2s_comp_algo->val;
 	} else {
 		/* SERVER */
-		ses.newkeys->recv.algo_crypt = 
+		ses->newkeys->recv.algo_crypt = 
 			(struct dropbear_cipher*)c2s_cipher_algo->data;
-		ses.newkeys->trans.algo_crypt = 
+		ses->newkeys->trans.algo_crypt = 
 			(struct dropbear_cipher*)s2c_cipher_algo->data;
-		ses.newkeys->recv.crypt_mode =
+		ses->newkeys->recv.crypt_mode =
 			(struct dropbear_cipher_mode*)c2s_cipher_algo->mode;
-		ses.newkeys->trans.crypt_mode =
+		ses->newkeys->trans.crypt_mode =
 			(struct dropbear_cipher_mode*)s2c_cipher_algo->mode;
-		ses.newkeys->recv.algo_mac = 
+		ses->newkeys->recv.algo_mac = 
 #if DROPBEAR_AEAD_MODE
-			c2s_hash_algo == NULL ? ses.newkeys->recv.crypt_mode->aead_mac :
+			c2s_hash_algo == NULL ? ses->newkeys->recv.crypt_mode->aead_mac :
 #endif
 			(struct dropbear_hash*)c2s_hash_algo->data;
-		ses.newkeys->trans.algo_mac = 
+		ses->newkeys->trans.algo_mac = 
 #if DROPBEAR_AEAD_MODE
-			s2c_hash_algo == NULL ? ses.newkeys->trans.crypt_mode->aead_mac :
+			s2c_hash_algo == NULL ? ses->newkeys->trans.crypt_mode->aead_mac :
 #endif
 			(struct dropbear_hash*)s2c_hash_algo->data;
-		ses.newkeys->recv.algo_comp = c2s_comp_algo->val;
-		ses.newkeys->trans.algo_comp = s2c_comp_algo->val;
+		ses->newkeys->recv.algo_comp = c2s_comp_algo->val;
+		ses->newkeys->trans.algo_comp = s2c_comp_algo->val;
 	}
 
 #if DROPBEAR_FUZZ
@@ -1008,11 +1008,11 @@
 #endif
 
 	/* reserved for future extensions */
-	buf_getint(ses.payload);
+	buf_getint(ses->payload);
 
-	if (ses.send_kex_first_guess && allgood) {
+	if (ses->send_kex_first_guess && allgood) {
 		TRACE(("our_first_follows_matches 1"))
-		ses.kexstate.our_first_follows_matches = 1;
+		ses->kexstate.our_first_follows_matches = 1;
 	}
 	return;
 
diff -aur dropbear-2022.83/common-runopts.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-runopts.c
--- dropbear-2022.83/common-runopts.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-runopts.c	2023-08-09 16:05:01.044016161 +0600
@@ -31,7 +31,7 @@
 #include "algo.h"
 #include "dbrandom.h"
 
-runopts opts; /* GLOBAL */
+runopts *opts; /* GLOBAL */
 
 /* returns success or failure, and the keytype in *type. If we want
  * to restrict the type, type can contain a type to return */
@@ -65,27 +65,27 @@
 void
 parse_ciphers_macs() {
 	int printed_help = 0;
-	if (opts.cipher_list) {
-		if (strcmp(opts.cipher_list, "help") == 0) {
+	if (opts->cipher_list) {
+		if (strcmp(opts->cipher_list, "help") == 0) {
 			char *ciphers = algolist_string(sshciphers);
 			dropbear_log(LOG_INFO, "Available ciphers: %s", ciphers);
 			m_free(ciphers);
 			printed_help = 1;
 		} else {
-			if (check_user_algos(opts.cipher_list, sshciphers, "cipher") == 0) {
+			if (check_user_algos(opts->cipher_list, sshciphers, "cipher") == 0) {
 				dropbear_exit("No valid ciphers specified for '-c'");
 			}
 		}
 	}
 
-	if (opts.mac_list) {
-		if (strcmp(opts.mac_list, "help") == 0) {
+	if (opts->mac_list) {
+		if (strcmp(opts->mac_list, "help") == 0) {
 			char *macs = algolist_string(sshhashes);
 			dropbear_log(LOG_INFO, "Available MACs: %s", macs);
 			m_free(macs);
 			printed_help = 1;
 		} else {
-			if (check_user_algos(opts.mac_list, sshhashes, "MAC") == 0) {
+			if (check_user_algos(opts->mac_list, sshhashes, "MAC") == 0) {
 				dropbear_exit("No valid MACs specified for '-m'");
 			}
 		}
@@ -107,12 +107,12 @@
 	ret = m_str_to_uint(recv_window_arg, &rw);
 	if (ret == DROPBEAR_FAILURE || rw == 0 || rw > MAX_RECV_WINDOW) {
 		if (rw > MAX_RECV_WINDOW) {
-			opts.recv_window = MAX_RECV_WINDOW;
+			opts->recv_window = MAX_RECV_WINDOW;
 		}
 		dropbear_log(LOG_WARNING, "Bad recv window '%s', using %d",
-			recv_window_arg, opts.recv_window);
+			recv_window_arg, opts->recv_window);
 	} else {
-		opts.recv_window = rw;
+		opts->recv_window = rw;
 	}
 
 }
diff -aur dropbear-2022.83/common-session.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-session.c
--- dropbear-2022.83/common-session.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/common-session.c	2023-08-09 16:05:01.044016161 +0600
@@ -22,6 +22,7 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE. */
 
+#include "embox_drpbr.h"
 #include "includes.h"
 #include "session.h"
 #include "dbutil.h"
@@ -41,7 +42,7 @@
 static int ident_readln(int fd, char* buf, int count);
 static void read_session_identification(void);
 
-struct sshsession ses; /* GLOBAL */
+struct sshsession *ses; /* GLOBAL */
 
 /* called only at the start of a session, set up initial state */
 void common_session_init(int sock_in, int sock_out) {
@@ -53,9 +54,11 @@
 
 	TRACE(("enter session_init"))
 
-	ses.sock_in = sock_in;
-	ses.sock_out = sock_out;
-	ses.maxfd = MAX(sock_in, sock_out);
+    /*ses = malloc(sizeof(struct sshsession));*/
+
+	ses->sock_in = sock_in;
+	ses->sock_out = sock_out;
+	ses->maxfd = MAX(sock_in, sock_out);
 
 	if (sock_in >= 0) {
 		setnonblocking(sock_in);
@@ -64,7 +67,7 @@
 		setnonblocking(sock_out);
 	}
 
-	ses.socket_prio = DROPBEAR_PRIO_NORMAL;
+	ses->socket_prio = DROPBEAR_PRIO_NORMAL;
 	/* Sets it to lowdelay */
 	update_channel_prio();
 
@@ -79,76 +82,76 @@
 #endif
 
 	now = monotonic_now();
-	ses.connect_time = now;
-	ses.last_packet_time_keepalive_recv = now;
-	ses.last_packet_time_idle = now;
-	ses.last_packet_time_any_sent = 0;
-	ses.last_packet_time_keepalive_sent = 0;
+	ses->connect_time = now;
+	ses->last_packet_time_keepalive_recv = now;
+	ses->last_packet_time_idle = now;
+	ses->last_packet_time_any_sent = 0;
+	ses->last_packet_time_keepalive_sent = 0;
 	
 #if DROPBEAR_FUZZ
 	if (!fuzz.fuzzing)
 #endif
 	{
-	if (pipe(ses.signal_pipe) < 0) {
+	if (pipe(ses->signal_pipe) < 0) {
 		dropbear_exit("Signal pipe failed");
 	}
-	setnonblocking(ses.signal_pipe[0]);
-	setnonblocking(ses.signal_pipe[1]);
-	ses.maxfd = MAX(ses.maxfd, ses.signal_pipe[0]);
-	ses.maxfd = MAX(ses.maxfd, ses.signal_pipe[1]);
+	setnonblocking(ses->signal_pipe[0]);
+	setnonblocking(ses->signal_pipe[1]);
+	ses->maxfd = MAX(ses->maxfd, ses->signal_pipe[0]);
+	ses->maxfd = MAX(ses->maxfd, ses->signal_pipe[1]);
 	}
 	
-	ses.writepayload = buf_new(TRANS_MAX_PAYLOAD_LEN);
-	ses.transseq = 0;
+	ses->writepayload = buf_new(TRANS_MAX_PAYLOAD_LEN);
+	ses->transseq = 0;
 
-	ses.readbuf = NULL;
-	ses.payload = NULL;
-	ses.recvseq = 0;
+	ses->readbuf = NULL;
+	ses->payload = NULL;
+	ses->recvseq = 0;
 
-	initqueue(&ses.writequeue);
+	initqueue(&ses->writequeue);
 
-	ses.requirenext = SSH_MSG_KEXINIT;
-	ses.dataallowed = 1; /* we can send data until we actually 
+	ses->requirenext = SSH_MSG_KEXINIT;
+	ses->dataallowed = 1; /* we can send data until we actually 
 							send the SSH_MSG_KEXINIT */
-	ses.ignorenext = 0;
-	ses.lastpacket = 0;
-	ses.reply_queue_head = NULL;
-	ses.reply_queue_tail = NULL;
+	ses->ignorenext = 0;
+	ses->lastpacket = 0;
+	ses->reply_queue_head = NULL;
+	ses->reply_queue_tail = NULL;
 
 	/* set all the algos to none */
-	ses.keys = (struct key_context*)m_malloc(sizeof(struct key_context));
-	ses.newkeys = NULL;
-	ses.keys->recv.algo_crypt = &dropbear_nocipher;
-	ses.keys->trans.algo_crypt = &dropbear_nocipher;
-	ses.keys->recv.crypt_mode = &dropbear_mode_none;
-	ses.keys->trans.crypt_mode = &dropbear_mode_none;
+	ses->keys = (struct key_context*)m_malloc(sizeof(struct key_context));
+	ses->newkeys = NULL;
+	ses->keys->recv.algo_crypt = &dropbear_nocipher;
+	ses->keys->trans.algo_crypt = &dropbear_nocipher;
+	ses->keys->recv.crypt_mode = &dropbear_mode_none;
+	ses->keys->trans.crypt_mode = &dropbear_mode_none;
 	
-	ses.keys->recv.algo_mac = &dropbear_nohash;
-	ses.keys->trans.algo_mac = &dropbear_nohash;
+	ses->keys->recv.algo_mac = &dropbear_nohash;
+	ses->keys->trans.algo_mac = &dropbear_nohash;
 
-	ses.keys->algo_kex = NULL;
-	ses.keys->algo_hostkey = -1;
-	ses.keys->recv.algo_comp = DROPBEAR_COMP_NONE;
-	ses.keys->trans.algo_comp = DROPBEAR_COMP_NONE;
+	ses->keys->algo_kex = NULL;
+	ses->keys->algo_hostkey = -1;
+	ses->keys->recv.algo_comp = DROPBEAR_COMP_NONE;
+	ses->keys->trans.algo_comp = DROPBEAR_COMP_NONE;
 
 #ifndef DISABLE_ZLIB
-	ses.keys->recv.zstream = NULL;
-	ses.keys->trans.zstream = NULL;
+	ses->keys->recv.zstream = NULL;
+	ses->keys->trans.zstream = NULL;
 #endif
 
 	/* key exchange buffers */
-	ses.session_id = NULL;
-	ses.kexhashbuf = NULL;
-	ses.transkexinit = NULL;
-	ses.dh_K = NULL;
-	ses.remoteident = NULL;
+	ses->session_id = NULL;
+	ses->kexhashbuf = NULL;
+	ses->transkexinit = NULL;
+	ses->dh_K = NULL;
+	ses->remoteident = NULL;
 
-	ses.chantypes = NULL;
+	ses->chantypes = NULL;
 
-	ses.allowprivport = 0;
+	ses->allowprivport = 0;
 
 #if DROPBEAR_PLUGIN
-        ses.plugin_session = NULL;
+        ses->plugin_session = NULL;
 #endif
 
 	TRACE(("leave session_init"))
@@ -162,14 +165,14 @@
 
 	/* main loop, select()s for all sockets in use */
 	for(;;) {
-		const int writequeue_has_space = (ses.writequeue_len <= 2*TRANS_MAX_PAYLOAD_LEN);
+		const int writequeue_has_space = (ses->writequeue_len <= 2*TRANS_MAX_PAYLOAD_LEN);
 
 		timeout.tv_sec = select_timeout();
 		timeout.tv_usec = 0;
 		DROPBEAR_FD_ZERO(&writefd);
 		DROPBEAR_FD_ZERO(&readfd);
 
-		dropbear_assert(ses.payload == NULL);
+		dropbear_assert(ses->payload == NULL);
 
 		/* We get woken up when signal handlers write to this pipe.
 		   SIGCHLD in svr-chansession is the only one currently. */
@@ -177,7 +180,7 @@
 		if (!fuzz.fuzzing) 
 #endif
 		{
-		FD_SET(ses.signal_pipe[0], &readfd);
+		FD_SET(ses->signal_pipe[0], &readfd);
 		}
 
 		/* set up for channels which can be read/written */
@@ -192,21 +195,30 @@
 		read for the remote ident.
 		We also avoid reading from the socket if the writequeue is full, that avoids
 		replies backing up */
-		if (ses.sock_in != -1 
-			&& (ses.remoteident || isempty(&ses.writequeue)) 
+		if (ses->sock_in != -1 
+			&& (ses->remoteident || isempty(&ses->writequeue)) 
 			&& writequeue_has_space) {
-			FD_SET(ses.sock_in, &readfd);
+			FD_SET(ses->sock_in, &readfd);
 		}
 
 		/* Ordering is important, this test must occur after any other function
 		might have queued packets (such as connection handlers) */
-		if (ses.sock_out != -1 && !isempty(&ses.writequeue)) {
-			FD_SET(ses.sock_out, &writefd);
+		if (ses->sock_out != -1 && !isempty(&ses->writequeue)) {
+			FD_SET(ses->sock_out, &writefd);
 		}
 
-		val = select(ses.maxfd+1, &readfd, &writefd, NULL, &timeout);
+#ifdef DROPBEAR_EMBOX_BUILD
+        /*We want to be sure in embox this process works only one instance at
+         * a time. This is why we use sched_lock/sched_unloc */
+        sched_unlock();
+#endif
+		val = select(ses->maxfd+1, &readfd, &writefd, NULL, &timeout);
+#ifdef DROPBEAR_EMBOX_BUILD
+        sched_lock();
+        dropbear_embox_switch_desc();
+#endif
 
-		if (ses.exitflag) {
+		if (ses->exitflag) {
 			dropbear_exit("Terminated by signal");
 		}
 		
@@ -226,21 +238,21 @@
 		/* We'll just empty out the pipe if required. We don't do
 		any thing with the data, since the pipe's purpose is purely to
 		wake up the select() above. */
-		ses.channel_signal_pending = 0;
-		if (FD_ISSET(ses.signal_pipe[0], &readfd)) {
+		ses->channel_signal_pending = 0;
+		if (FD_ISSET(ses->signal_pipe[0], &readfd)) {
 			char x;
 			TRACE(("signal pipe set"))
-			while (read(ses.signal_pipe[0], &x, 1) > 0) {}
-			ses.channel_signal_pending = 1;
+			while (read(ses->signal_pipe[0], &x, 1) > 0) {}
+			ses->channel_signal_pending = 1;
 		}
 
 		/* check for auth timeout, rekeying required etc */
 		checktimeouts();
 
 		/* process session socket's incoming data */
-		if (ses.sock_in != -1) {
-			if (FD_ISSET(ses.sock_in, &readfd)) {
-				if (!ses.remoteident) {
+		if (ses->sock_in != -1) {
+			if (FD_ISSET(ses->sock_in, &readfd)) {
+				if (!ses->remoteident) {
 					/* blocking read of the version string */
 					read_session_identification();
 				} else {
@@ -250,7 +262,7 @@
 			
 			/* Process the decrypted packet. After this, the read buffer
 			 * will be ready for a new packet */
-			if (ses.payload != NULL) {
+			if (ses->payload != NULL) {
 				process_packet();
 			}
 		}
@@ -265,13 +277,13 @@
 		channels on process exit */
 		loophandler();
 
-		/* process pipes etc for the channels, ses.dataallowed == 0
+		/* process pipes etc for the channels, ses->dataallowed == 0
 		 * during rekeying ) */
 		channelio(&readfd, &writefd);
 
 		/* process session socket's outgoing data */
-		if (ses.sock_out != -1) {
-			if (!isempty(&ses.writequeue)) {
+		if (ses->sock_out != -1) {
+			if (!isempty(&ses->writequeue)) {
 				write_packet();
 			}
 		}
@@ -295,8 +307,8 @@
 	TRACE(("enter session_cleanup"))
 	
 	/* we can't cleanup if we don't know the session state */
-	if (!ses.init_done) {
-		TRACE(("leave session_cleanup: !ses.init_done"))
+	if (!ses->init_done) {
+		TRACE(("leave session_cleanup: !ses->init_done"))
 		return;
 	}
 
@@ -305,8 +317,8 @@
 	/* Must be before extra_session_cleanup() */
 	chancleanup();
 
-	if (ses.extra_session_cleanup) {
-		ses.extra_session_cleanup();
+	if (ses->extra_session_cleanup) {
+		ses->extra_session_cleanup();
 	}
 
 	/* After these are freed most functions will fail */
@@ -317,42 +329,42 @@
 
 	remove_connect_pending();
 
-	while (!isempty(&ses.writequeue)) {
-		buf_free(dequeue(&ses.writequeue));
+	while (!isempty(&ses->writequeue)) {
+		buf_free(dequeue(&ses->writequeue));
 	}
 
-	m_free(ses.newkeys);
+	m_free(ses->newkeys);
 #ifndef DISABLE_ZLIB
-	if (ses.keys->recv.zstream != NULL) {
-		if (inflateEnd(ses.keys->recv.zstream) == Z_STREAM_ERROR) {
+	if (ses->keys->recv.zstream != NULL) {
+		if (inflateEnd(ses->keys->recv.zstream) == Z_STREAM_ERROR) {
 			dropbear_exit("Crypto error");
 		}
-		m_free(ses.keys->recv.zstream);
+		m_free(ses->keys->recv.zstream);
 	}
 #endif
 
-	m_free(ses.remoteident);
-	m_free(ses.authstate.pw_dir);
-	m_free(ses.authstate.pw_name);
-	m_free(ses.authstate.pw_shell);
-	m_free(ses.authstate.pw_passwd);
-	m_free(ses.authstate.username);
+	m_free(ses->remoteident);
+	m_free(ses->authstate.pw_dir);
+	m_free(ses->authstate.pw_name);
+	m_free(ses->authstate.pw_shell);
+	m_free(ses->authstate.pw_passwd);
+	m_free(ses->authstate.username);
 #endif
 
-	cleanup_buf(&ses.session_id);
-	cleanup_buf(&ses.hash);
-	cleanup_buf(&ses.payload);
-	cleanup_buf(&ses.readbuf);
-	cleanup_buf(&ses.writepayload);
-	cleanup_buf(&ses.kexhashbuf);
-	cleanup_buf(&ses.transkexinit);
-	if (ses.dh_K) {
-		mp_clear(ses.dh_K);
+	cleanup_buf(&ses->session_id);
+	cleanup_buf(&ses->hash);
+	cleanup_buf(&ses->payload);
+	cleanup_buf(&ses->readbuf);
+	cleanup_buf(&ses->writepayload);
+	cleanup_buf(&ses->kexhashbuf);
+	cleanup_buf(&ses->transkexinit);
+	if (ses->dh_K) {
+		mp_clear(ses->dh_K);
 	}
-	m_free(ses.dh_K);
+	m_free(ses->dh_K);
 
-	m_burn(ses.keys, sizeof(struct key_context));
-	m_free(ses.keys);
+	m_burn(ses->keys, sizeof(struct key_context));
+	m_free(ses->keys);
 
 	TRACE(("leave session_cleanup"))
 }
@@ -374,7 +386,7 @@
 	 * version string, client must be able to process such lines.
 	 * If they send more than 50 lines, something is wrong */
 	for (i = IS_DROPBEAR_CLIENT ? 50 : 1; i > 0; i--) {
-		len = ident_readln(ses.sock_in, linebuf, sizeof(linebuf));
+		len = ident_readln(ses->sock_in, linebuf, sizeof(linebuf));
 
 		if (len < 0 && errno != EINTR) {
 			/* It failed */
@@ -390,20 +402,20 @@
 
 	if (!done) {
 		TRACE(("error reading remote ident: %s\n", strerror(errno)))
-		ses.remoteclosed();
+		ses->remoteclosed();
 	} else {
 		/* linebuf is already null terminated */
-		ses.remoteident = m_malloc(len);
-		memcpy(ses.remoteident, linebuf, len);
+		ses->remoteident = m_malloc(len);
+		memcpy(ses->remoteident, linebuf, len);
 	}
 
 	/* Shall assume that 2.x will be backwards compatible. */
-	if (strncmp(ses.remoteident, "SSH-2.", 6) != 0
-			&& strncmp(ses.remoteident, "SSH-1.99-", 9) != 0) {
-		dropbear_exit("Incompatible remote version '%s'", ses.remoteident);
+	if (strncmp(ses->remoteident, "SSH-2.", 6) != 0
+			&& strncmp(ses->remoteident, "SSH-1.99-", 9) != 0) {
+		dropbear_exit("Incompatible remote version '%s'", ses->remoteident);
 	}
 
-	DEBUG1(("remoteident: %s", ses.remoteident))
+	DEBUG1(("remoteident: %s", ses->remoteident))
 
 }
 
@@ -492,7 +504,7 @@
 }
 
 static void send_msg_keepalive() {
-	time_t old_time_idle = ses.last_packet_time_idle;
+	time_t old_time_idle = ses->last_packet_time_idle;
 	struct Channel *chan = get_any_ready_channel();
 
 	CHECKCLEARTOWRITE();
@@ -506,17 +518,17 @@
 		TRACE(("keepalive global request"))
 		/* Some peers will reply with SSH_MSG_REQUEST_FAILURE, 
 		some will reply with SSH_MSG_UNIMPLEMENTED, some will exit. */
-		buf_putbyte(ses.writepayload, SSH_MSG_GLOBAL_REQUEST); 
-		buf_putstring(ses.writepayload, DROPBEAR_KEEPALIVE_STRING,
+		buf_putbyte(ses->writepayload, SSH_MSG_GLOBAL_REQUEST); 
+		buf_putstring(ses->writepayload, DROPBEAR_KEEPALIVE_STRING,
 			strlen(DROPBEAR_KEEPALIVE_STRING));
 	}
-	buf_putbyte(ses.writepayload, 1); /* want_reply */
+	buf_putbyte(ses->writepayload, 1); /* want_reply */
 	encrypt_packet();
 
-	ses.last_packet_time_keepalive_sent = monotonic_now();
+	ses->last_packet_time_keepalive_sent = monotonic_now();
 
 	/* keepalives shouldn't update idle timeout, reset it back */
-	ses.last_packet_time_idle = old_time_idle;
+	ses->last_packet_time_idle = old_time_idle;
 }
 
 /* Check all timeouts which are required. Currently these are the time for
@@ -526,47 +538,47 @@
 	time_t now;
 	now = monotonic_now();
 	
-	if (IS_DROPBEAR_SERVER && ses.connect_time != 0
-		&& now - ses.connect_time >= AUTH_TIMEOUT) {
+	if (IS_DROPBEAR_SERVER && ses->connect_time != 0
+		&& now - ses->connect_time >= AUTH_TIMEOUT) {
 			dropbear_close("Timeout before auth");
 	}
 
 	/* we can't rekey if we haven't done remote ident exchange yet */
-	if (ses.remoteident == NULL) {
+	if (ses->remoteident == NULL) {
 		return;
 	}
 
-	if (!ses.kexstate.sentkexinit
-			&& (now - ses.kexstate.lastkextime >= KEX_REKEY_TIMEOUT
-			|| ses.kexstate.datarecv+ses.kexstate.datatrans >= KEX_REKEY_DATA)) {
+	if (!ses->kexstate.sentkexinit
+			&& (now - ses->kexstate.lastkextime >= KEX_REKEY_TIMEOUT
+			|| ses->kexstate.datarecv+ses->kexstate.datatrans >= KEX_REKEY_DATA)) {
 		TRACE(("rekeying after timeout or max data reached"))
 		send_msg_kexinit();
 	}
 	
-	if (opts.keepalive_secs > 0 && ses.authstate.authdone) {
+	if (opts->keepalive_secs > 0 && ses->authstate.authdone) {
 		/* Avoid sending keepalives prior to auth - those are
 		not valid pre-auth packet types */
 
 		/* Send keepalives if we've been idle */
-		if (now - ses.last_packet_time_any_sent >= opts.keepalive_secs) {
+		if (now - ses->last_packet_time_any_sent >= opts->keepalive_secs) {
 			send_msg_keepalive();
 		}
 
 		/* Also send an explicit keepalive message to trigger a response
 		if the remote end hasn't sent us anything */
-		if (now - ses.last_packet_time_keepalive_recv >= opts.keepalive_secs
-			&& now - ses.last_packet_time_keepalive_sent >= opts.keepalive_secs) {
+		if (now - ses->last_packet_time_keepalive_recv >= opts->keepalive_secs
+			&& now - ses->last_packet_time_keepalive_sent >= opts->keepalive_secs) {
 			send_msg_keepalive();
 		}
 
-		if (now - ses.last_packet_time_keepalive_recv 
-			>= opts.keepalive_secs * DEFAULT_KEEPALIVE_LIMIT) {
+		if (now - ses->last_packet_time_keepalive_recv 
+			>= opts->keepalive_secs * DEFAULT_KEEPALIVE_LIMIT) {
 			dropbear_exit("Keepalive timeout");
 		}
 	}
 
-	if (opts.idle_timeout_secs > 0 
-			&& now - ses.last_packet_time_idle >= opts.idle_timeout_secs) {
+	if (opts->idle_timeout_secs > 0 
+			&& now - ses->last_packet_time_idle >= opts->idle_timeout_secs) {
 		dropbear_close("Idle timeout");
 	}
 }
@@ -586,22 +598,22 @@
 	long timeout = KEX_REKEY_TIMEOUT;
 	long now = monotonic_now();
 
-	if (!ses.kexstate.sentkexinit) {
-		update_timeout(KEX_REKEY_TIMEOUT, now, ses.kexstate.lastkextime, &timeout);
+	if (!ses->kexstate.sentkexinit) {
+		update_timeout(KEX_REKEY_TIMEOUT, now, ses->kexstate.lastkextime, &timeout);
 	}
 
-	if (ses.authstate.authdone != 1 && IS_DROPBEAR_SERVER) {
+	if (ses->authstate.authdone != 1 && IS_DROPBEAR_SERVER) {
 		/* AUTH_TIMEOUT is only relevant before authdone */
-		update_timeout(AUTH_TIMEOUT, now, ses.connect_time, &timeout);
+		update_timeout(AUTH_TIMEOUT, now, ses->connect_time, &timeout);
 	}
 
-	if (ses.authstate.authdone) {
-		update_timeout(opts.keepalive_secs, now, 
-			MAX(ses.last_packet_time_keepalive_recv, ses.last_packet_time_keepalive_sent),
+	if (ses->authstate.authdone) {
+		update_timeout(opts->keepalive_secs, now, 
+			MAX(ses->last_packet_time_keepalive_recv, ses->last_packet_time_keepalive_sent),
 			&timeout);
 	}
 
-	update_timeout(opts.idle_timeout_secs, now, ses.last_packet_time_idle,
+	update_timeout(opts->idle_timeout_secs, now, ses->last_packet_time_idle,
 		&timeout);
 
 	/* clamp negative timeouts to zero - event has already triggered */
@@ -610,37 +622,37 @@
 
 const char* get_user_shell() {
 	/* an empty shell should be interpreted as "/bin/sh" */
-	if (ses.authstate.pw_shell[0] == '\0') {
+	if (ses->authstate.pw_shell[0] == '\0') {
 		return "/bin/sh";
 	} else {
-		return ses.authstate.pw_shell;
+		return ses->authstate.pw_shell;
 	}
 }
 void fill_passwd(const char* username) {
 	struct passwd *pw = NULL;
-	if (ses.authstate.pw_name)
-		m_free(ses.authstate.pw_name);
-	if (ses.authstate.pw_dir)
-		m_free(ses.authstate.pw_dir);
-	if (ses.authstate.pw_shell)
-		m_free(ses.authstate.pw_shell);
-	if (ses.authstate.pw_passwd)
-		m_free(ses.authstate.pw_passwd);
+	if (ses->authstate.pw_name)
+		m_free(ses->authstate.pw_name);
+	if (ses->authstate.pw_dir)
+		m_free(ses->authstate.pw_dir);
+	if (ses->authstate.pw_shell)
+		m_free(ses->authstate.pw_shell);
+	if (ses->authstate.pw_passwd)
+		m_free(ses->authstate.pw_passwd);
 
 	pw = getpwnam(username);
 	if (!pw) {
 		return;
 	}
-	ses.authstate.pw_uid = pw->pw_uid;
-	ses.authstate.pw_gid = pw->pw_gid;
-	ses.authstate.pw_name = m_strdup(pw->pw_name);
-	ses.authstate.pw_dir = m_strdup(pw->pw_dir);
-	ses.authstate.pw_shell = m_strdup(pw->pw_shell);
+	ses->authstate.pw_uid = pw->pw_uid;
+	ses->authstate.pw_gid = pw->pw_gid;
+	ses->authstate.pw_name = m_strdup(pw->pw_name);
+	ses->authstate.pw_dir = m_strdup(pw->pw_dir);
+	ses->authstate.pw_shell = m_strdup(pw->pw_shell);
 	{
 		char *passwd_crypt = pw->pw_passwd;
 #ifdef HAVE_SHADOW_H
 		/* get the shadow password if possible */
-		struct spwd *spasswd = getspnam(ses.authstate.pw_name);
+		struct spwd *spasswd = getspnam(ses->authstate.pw_name);
 		if (spasswd && spasswd->sp_pwdp) {
 			passwd_crypt = spasswd->sp_pwdp;
 		}
@@ -649,7 +661,7 @@
 			/* android supposedly returns NULL */
 			passwd_crypt = "!!";
 		}
-		ses.authstate.pw_passwd = m_strdup(passwd_crypt);
+		ses->authstate.pw_passwd = m_strdup(passwd_crypt);
 	}
 }
 
@@ -661,14 +673,14 @@
 
 	TRACE(("update_channel_prio"))
 
-	if (ses.sock_out < 0) {
+	if (ses->sock_out < 0) {
 		TRACE(("leave update_channel_prio: no socket"))
 		return;
 	}
 
 	new_prio = DROPBEAR_PRIO_NORMAL;
-	for (i = 0; i < ses.chansize; i++) {
-		struct Channel *channel = ses.channels[i];
+	for (i = 0; i < ses->chansize; i++) {
+		struct Channel *channel = ses->channels[i];
 		if (!channel) {
 			continue;
 		}
@@ -685,10 +697,10 @@
 		new_prio = DROPBEAR_PRIO_LOWDELAY;
 	}
 
-	if (new_prio != ses.socket_prio) {
-		TRACE(("Dropbear priority transitioning %d -> %d", ses.socket_prio, new_prio))
-		set_sock_priority(ses.sock_out, new_prio);
-		ses.socket_prio = new_prio;
+	if (new_prio != ses->socket_prio) {
+		TRACE(("Dropbear priority transitioning %d -> %d", ses->socket_prio, new_prio))
+		set_sock_priority(ses->sock_out, new_prio);
+		ses->socket_prio = new_prio;
 	}
 }
 
diff -aur dropbear-2022.83/debug.h ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/debug.h
--- dropbear-2022.83/debug.h	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/debug.h	2023-08-09 16:05:01.044016161 +0600
@@ -36,8 +36,8 @@
 /* All functions writing to the cleartext payload buffer call
  * CHECKCLEARTOWRITE() before writing. This is only really useful if you're
  * attempting to track down a problem */
-/*#define CHECKCLEARTOWRITE() assert(ses.writepayload->len == 0 && \
-		ses.writepayload->pos == 0)*/
+/*#define CHECKCLEARTOWRITE() assert(ses->writepayload->len == 0 && \
+		ses->writepayload->pos == 0)*/
 
 #ifndef CHECKCLEARTOWRITE
 #define CHECKCLEARTOWRITE()
diff -aur dropbear-2022.83/fuzz/fuzz-common.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzz-common.c
--- dropbear-2022.83/fuzz/fuzz-common.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzz-common.c	2023-08-09 16:05:01.044016161 +0600
@@ -104,7 +104,7 @@
 
 void fuzz_svr_hook_preloop() {
     if (fuzz.svr_postauth) {
-        ses.authstate.authdone = 1;
+        ses->authstate.authdone = 1;
         fill_passwd("root");
     }
 }
@@ -157,13 +157,13 @@
 
     TRACE(("load fixed hostkeys"))
 
-    svr_opts.hostkey = new_sign_key();
+    svr_opts->hostkey = new_sign_key();
 
     buf_setlen(b, 0);
     buf_putbytes(b, keyr, keyr_len);
     buf_setpos(b, 0);
     type = DROPBEAR_SIGNKEY_RSA;
-    if (buf_get_priv_key(b, svr_opts.hostkey, &type) == DROPBEAR_FAILURE) {
+    if (buf_get_priv_key(b, svr_opts->hostkey, &type) == DROPBEAR_FAILURE) {
         dropbear_exit("failed fixed rsa hostkey");
     }
 
@@ -171,7 +171,7 @@
     buf_putbytes(b, keyd, keyd_len);
     buf_setpos(b, 0);
     type = DROPBEAR_SIGNKEY_DSS;
-    if (buf_get_priv_key(b, svr_opts.hostkey, &type) == DROPBEAR_FAILURE) {
+    if (buf_get_priv_key(b, svr_opts->hostkey, &type) == DROPBEAR_FAILURE) {
         dropbear_exit("failed fixed dss hostkey");
     }
 
@@ -179,7 +179,7 @@
     buf_putbytes(b, keye, keye_len);
     buf_setpos(b, 0);
     type = DROPBEAR_SIGNKEY_ECDSA_NISTP256;
-    if (buf_get_priv_key(b, svr_opts.hostkey, &type) == DROPBEAR_FAILURE) {
+    if (buf_get_priv_key(b, svr_opts->hostkey, &type) == DROPBEAR_FAILURE) {
         dropbear_exit("failed fixed ecdsa hostkey");
     }
 
@@ -187,7 +187,7 @@
     buf_putbytes(b, keyed25519, keyed25519_len);
     buf_setpos(b, 0);
     type = DROPBEAR_SIGNKEY_ED25519;
-    if (buf_get_priv_key(b, svr_opts.hostkey, &type) == DROPBEAR_FAILURE) {
+    if (buf_get_priv_key(b, svr_opts->hostkey, &type) == DROPBEAR_FAILURE) {
         dropbear_exit("failed fixed ed25519 hostkey");
     }
 
@@ -195,8 +195,8 @@
 }
 
 void fuzz_kex_fakealgos(void) {
-    ses.newkeys->recv.crypt_mode = &dropbear_mode_none;
-    ses.newkeys->recv.algo_mac = &dropbear_nohash;
+    ses->newkeys->recv.crypt_mode = &dropbear_mode_none;
+    ses->newkeys->recv.algo_mac = &dropbear_nohash;
 }
 
 void fuzz_get_socket_address(int UNUSED(fd), char **local_host, char **local_port,
@@ -217,9 +217,9 @@
 
 /* cut down version of svr_send_msg_kexdh_reply() that skips slow maths. Still populates structures */
 void fuzz_fake_send_kexdh_reply(void) {
-    assert(!ses.dh_K);
-    m_mp_alloc_init_multi(&ses.dh_K, NULL);
-    mp_set_ul(ses.dh_K, 12345678uL);
+    assert(!ses->dh_K);
+    m_mp_alloc_init_multi(&ses->dh_K, NULL);
+    mp_set_ul(ses->dh_K, 12345678uL);
     finish_kexhashbuf();
 }
 
@@ -309,7 +309,7 @@
     }
 
     // Allow to proceed sooner
-    ses.kexstate.donefirstkex = 1;
+    ses->kexstate.donefirstkex = 1;
 
     uint32_t wrapseed;
     genrandom((void*)&wrapseed, sizeof(wrapseed));
diff -aur dropbear-2022.83/fuzz/fuzzer-kexcurve25519.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzzer-kexcurve25519.c
--- dropbear-2022.83/fuzz/fuzzer-kexcurve25519.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzzer-kexcurve25519.c	2023-08-09 16:05:01.044016161 +0600
@@ -20,7 +20,7 @@
 	keep_newkeys = (struct key_context*)m_malloc(sizeof(struct key_context));
 	keep_newkeys->algo_kex = fuzz_get_algo(sshkex, "curve25519-sha256");
 	keep_newkeys->algo_hostkey = DROPBEAR_SIGNKEY_ED25519;
-	ses.newkeys = keep_newkeys;
+	ses->newkeys = keep_newkeys;
 
 	/* Pre-generate parameters */
 	int i;
@@ -39,7 +39,7 @@
 	if (setjmp(fuzz.jmp) == 0) {
 		/* Based on recv_msg_kexdh_init()/send_msg_kexdh_reply() 
 		with DROPBEAR_KEX_CURVE25519 */
-		ses.newkeys = keep_newkeys;
+		ses->newkeys = keep_newkeys;
 
 		/* Choose from the collection of curve25519 params */
 		unsigned int e = buf_getint(fuzz.input);
@@ -47,15 +47,15 @@
 
 		buffer * ecdh_qs = buf_getstringbuf(fuzz.input);
 
-		ses.kexhashbuf = buf_new(KEXHASHBUF_MAX_INTS);
-		kexcurve25519_comb_key(curve25519_param, ecdh_qs, svr_opts.hostkey);
+		ses->kexhashbuf = buf_new(KEXHASHBUF_MAX_INTS);
+		kexcurve25519_comb_key(curve25519_param, ecdh_qs, svr_opts->hostkey);
 
-		mp_clear(ses.dh_K);
-		m_free(ses.dh_K);
+		mp_clear(ses->dh_K);
+		m_free(ses->dh_K);
 		buf_free(ecdh_qs);
 
-		buf_free(ses.hash);
-		buf_free(ses.session_id);
+		buf_free(ses->hash);
+		buf_free(ses->session_id);
 		/* kexhashbuf is freed in kexdh_comb_key */
 
 		m_malloc_free_epoch(1, 0);
diff -aur dropbear-2022.83/fuzz/fuzzer-kexdh.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzzer-kexdh.c
--- dropbear-2022.83/fuzz/fuzzer-kexdh.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzzer-kexdh.c	2023-08-09 16:05:01.044016161 +0600
@@ -19,7 +19,7 @@
 	keep_newkeys = (struct key_context*)m_malloc(sizeof(struct key_context));
 	keep_newkeys->algo_kex = fuzz_get_algo(sshkex, "diffie-hellman-group14-sha256");
 	keep_newkeys->algo_hostkey = DROPBEAR_SIGNKEY_ECDSA_NISTP256;
-	ses.newkeys = keep_newkeys;
+	ses->newkeys = keep_newkeys;
 
 	/* Pre-generate parameters */
 	int i;
@@ -38,7 +38,7 @@
 	if (setjmp(fuzz.jmp) == 0) {
 		/* Based on recv_msg_kexdh_init()/send_msg_kexdh_reply() 
 		with DROPBEAR_KEX_NORMAL_DH */
-		ses.newkeys = keep_newkeys;
+		ses->newkeys = keep_newkeys;
 
 		/* Choose from the collection of ecdh params */
 		unsigned int e = buf_getint(fuzz.input);
@@ -50,15 +50,15 @@
 			dropbear_exit("Bad kex value");
 		}
 
-		ses.kexhashbuf = buf_new(KEXHASHBUF_MAX_INTS);
-		kexdh_comb_key(dh_param, &dh_e, svr_opts.hostkey);
+		ses->kexhashbuf = buf_new(KEXHASHBUF_MAX_INTS);
+		kexdh_comb_key(dh_param, &dh_e, svr_opts->hostkey);
 
-		mp_clear(ses.dh_K);
-		m_free(ses.dh_K);
+		mp_clear(ses->dh_K);
+		m_free(ses->dh_K);
 		mp_clear(&dh_e);
 
-		buf_free(ses.hash);
-		buf_free(ses.session_id);
+		buf_free(ses->hash);
+		buf_free(ses->session_id);
 		/* kexhashbuf is freed in kexdh_comb_key */
 
 		m_malloc_free_epoch(1, 0);
diff -aur dropbear-2022.83/fuzz/fuzzer-kexecdh.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzzer-kexecdh.c
--- dropbear-2022.83/fuzz/fuzzer-kexecdh.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/fuzz/fuzzer-kexecdh.c	2023-08-09 16:05:01.044016161 +0600
@@ -27,12 +27,12 @@
 	assert(ecdh[1]);
 	assert(ecdh[2]);
 	keep_newkeys->algo_hostkey = DROPBEAR_SIGNKEY_ECDSA_NISTP256;
-	ses.newkeys = keep_newkeys;
+	ses->newkeys = keep_newkeys;
 
 	/* Pre-generate parameters */
 	int i;
 	for (i = 0; i < NUM_PARAMS; i++) {
-		ses.newkeys->algo_kex = ecdh[i % 3];
+		ses->newkeys->algo_kex = ecdh[i % 3];
 		ecdh_params[i] = gen_kexecdh_param();
 	}
 }
@@ -48,11 +48,11 @@
 	if (setjmp(fuzz.jmp) == 0) {
 		/* Based on recv_msg_kexdh_init()/send_msg_kexdh_reply() 
 		with DROPBEAR_KEX_ECDH */
-		ses.newkeys = keep_newkeys;
+		ses->newkeys = keep_newkeys;
 
 		/* random choice of ecdh 256, 384, 521 */
 		unsigned char b = buf_getbyte(fuzz.input);
-		ses.newkeys->algo_kex = ecdh[b % 3];
+		ses->newkeys->algo_kex = ecdh[b % 3];
 
 		/* Choose from the collection of ecdh params */
 		unsigned int e = buf_getint(fuzz.input);
@@ -60,15 +60,15 @@
 
 		buffer * ecdh_qs = buf_getstringbuf(fuzz.input);
 
-		ses.kexhashbuf = buf_new(KEXHASHBUF_MAX_INTS);
-		kexecdh_comb_key(ecdh_param, ecdh_qs, svr_opts.hostkey);
+		ses->kexhashbuf = buf_new(KEXHASHBUF_MAX_INTS);
+		kexecdh_comb_key(ecdh_param, ecdh_qs, svr_opts->hostkey);
 
-		mp_clear(ses.dh_K);
-		m_free(ses.dh_K);
+		mp_clear(ses->dh_K);
+		m_free(ses->dh_K);
 		buf_free(ecdh_qs);
 
-		buf_free(ses.hash);
-		buf_free(ses.session_id);
+		buf_free(ses->hash);
+		buf_free(ses->session_id);
 		/* kexhashbuf is freed in kexdh_comb_key */
 
 		m_malloc_free_epoch(1, 0);
diff -aur dropbear-2022.83/includes.h ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/includes.h
--- dropbear-2022.83/includes.h	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/includes.h	2023-08-09 16:05:01.048016094 +0600
@@ -28,9 +28,15 @@
 #include "options.h"
 #include "debug.h"
 
+#ifdef DROPBEAR_EMBOX_BUILD
+#include "stubs.h"
+#endif
+
 #include <sys/types.h>
 #include <sys/ioctl.h>
+#ifndef DROPBEAR_EMBOX_BUILD
 #include <sys/param.h> /* required for BSD4_4 define */
+#endif
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/time.h>
@@ -49,7 +55,9 @@
 #include <string.h>
 #include <termios.h>
 #include <unistd.h>
+#ifndef DROPBEAR_EMBOX_BUILD
 #include <syslog.h>
+#endif
 #include <netdb.h>
 #include <ctype.h>
 #include <stdarg.h>
@@ -85,7 +93,9 @@
 #include <netinet/in_systm.h>
 #endif
 
+#ifndef DROPBEAR_EMBOX_BUILD
 #include <netinet/ip.h>
+#endif
 
 #ifdef HAVE_NETINET_TCP_H
 #include <netinet/tcp.h>
diff -aur dropbear-2022.83/listener.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/listener.c
--- dropbear-2022.83/listener.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/listener.c	2023-08-09 16:05:01.048016094 +0600
@@ -30,9 +30,9 @@
 void listeners_initialise() {
 
 	/* just one slot to start with */
-	ses.listeners = (struct Listener**)m_malloc(sizeof(struct Listener*));
-	ses.listensize = 1;
-	ses.listeners[0] = NULL;
+	ses->listeners = (struct Listener**)m_malloc(sizeof(struct Listener*));
+	ses->listensize = 1;
+	ses->listeners[0] = NULL;
 
 }
 
@@ -42,8 +42,8 @@
 	struct Listener *listener;
 
 	/* check each in turn */
-	for (i = 0; i < ses.listensize; i++) {
-		listener = ses.listeners[i];
+	for (i = 0; i < ses->listensize; i++) {
+		listener = ses->listeners[i];
 		if (listener != NULL) {
 			for (j = 0; j < listener->nsocks; j++) {
 				FD_SET(listener->socks[j], readfds);
@@ -60,8 +60,8 @@
 	int sock;
 
 	/* check each in turn */
-	for (i = 0; i < ses.listensize; i++) {
-		listener = ses.listeners[i];
+	for (i = 0; i < ses->listensize; i++) {
+		listener = ses->listeners[i];
 		if (listener != NULL) {
 			for (j = 0; j < listener->nsocks; j++) {
 				sock = listener->socks[j];
@@ -84,15 +84,15 @@
 	unsigned int i, j;
 	struct Listener *newlisten = NULL;
 	/* try get a new structure to hold it */
-	for (i = 0; i < ses.listensize; i++) {
-		if (ses.listeners[i] == NULL) {
+	for (i = 0; i < ses->listensize; i++) {
+		if (ses->listeners[i] == NULL) {
 			break;
 		}
 	}
 
 	/* or create a new one */
-	if (i == ses.listensize) {
-		if (ses.listensize > MAX_LISTENERS) {
+	if (i == ses->listensize) {
+		if (ses->listensize > MAX_LISTENERS) {
 			TRACE(("leave newlistener: too many already"))
 			for (j = 0; j < nsocks; j++) {
 				close(socks[i]);
@@ -100,19 +100,19 @@
 			return NULL;
 		}
 		
-		ses.listeners = (struct Listener**)m_realloc(ses.listeners,
-				(ses.listensize+LISTENER_EXTEND_SIZE)
+		ses->listeners = (struct Listener**)m_realloc(ses->listeners,
+				(ses->listensize+LISTENER_EXTEND_SIZE)
 				*sizeof(struct Listener*));
 
-		ses.listensize += LISTENER_EXTEND_SIZE;
+		ses->listensize += LISTENER_EXTEND_SIZE;
 
-		for (j = i; j < ses.listensize; j++) {
-			ses.listeners[j] = NULL;
+		for (j = i; j < ses->listensize; j++) {
+			ses->listeners[j] = NULL;
 		}
 	}
 
 	for (j = 0; j < nsocks; j++) {
-		ses.maxfd = MAX(ses.maxfd, socks[j]);
+		ses->maxfd = MAX(ses->maxfd, socks[j]);
 	}
 
 	TRACE(("new listener num %d ", i))
@@ -126,7 +126,7 @@
 	newlisten->acceptor = acceptor;
 	newlisten->cleanup = cleanup;
 
-	ses.listeners[i] = newlisten;
+	ses->listeners[i] = newlisten;
 	return newlisten;
 }
 
@@ -138,7 +138,7 @@
 	unsigned int i;
 	struct Listener* listener;
 
-	for (i = 0, listener = ses.listeners[i]; i < ses.listensize; i++) {
+	for (i = 0, listener = ses->listeners[i]; i < ses->listensize; i++) {
 		if (listener && listener->type == type
 				&& match(typedata, listener->typedata)) {
 			return listener;
@@ -159,16 +159,16 @@
 	for (j = 0; j < listener->nsocks; j++) {
 		close(listener->socks[j]);
 	}
-	ses.listeners[listener->index] = NULL;
+	ses->listeners[listener->index] = NULL;
 	m_free(listener);
 }
 
 void remove_all_listeners(void) {
 	unsigned int i;
-	for (i = 0; i < ses.listensize; i++) {
-		if (ses.listeners[i]) {
-			remove_listener(ses.listeners[i]);
+	for (i = 0; i < ses->listensize; i++) {
+		if (ses->listeners[i]) {
+			remove_listener(ses->listeners[i]);
 		}
 	}
-	m_free(ses.listeners);
+	m_free(ses->listeners);
 }
diff -aur dropbear-2022.83/netio.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/netio.c
--- dropbear-2022.83/netio.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/netio.c	2023-08-09 16:05:01.048016094 +0600
@@ -110,7 +110,7 @@
 			}
 		}
 
-		ses.maxfd = MAX(ses.maxfd, c->sock);
+		ses->maxfd = MAX(ses->maxfd, c->sock);
 		set_sock_nodelay(c->sock);
 		set_sock_priority(c->sock, c->prio);
 		setnonblocking(c->sock);
@@ -190,7 +190,7 @@
 	c->cb_data = cb_data;
 	c->prio = prio;
 
-	list_append(&ses.conn_pending, c);
+	list_append(&ses->conn_pending, c);
 
 #if DROPBEAR_FUZZ
 	if (fuzz.fuzzing) {
@@ -226,16 +226,16 @@
 }
 
 void remove_connect_pending() {
-	while (ses.conn_pending.first) {
-		struct dropbear_progress_connection *c = ses.conn_pending.first->item;
-		remove_connect(c, ses.conn_pending.first);
+	while (ses->conn_pending.first) {
+		struct dropbear_progress_connection *c = ses->conn_pending.first->item;
+		remove_connect(c, ses->conn_pending.first);
 	}
 }
 
 
 void set_connect_fds(fd_set *writefd) {
 	m_list_elem *iter;
-	iter = ses.conn_pending.first;
+	iter = ses->conn_pending.first;
 	while (iter) {
 		m_list_elem *next_iter = iter->next;
 		struct dropbear_progress_connection *c = iter->item;
@@ -259,7 +259,7 @@
 
 void handle_connect_fds(const fd_set *writefd) {
 	m_list_elem *iter;
-	for (iter = ses.conn_pending.first; iter; iter = iter->next) {
+	for (iter = ses->conn_pending.first; iter; iter = iter->next) {
 		int val;
 		socklen_t vallen = sizeof(val);
 		struct dropbear_progress_connection *c = iter->item;
@@ -378,7 +378,7 @@
 	/* Don't log ENOTSOCK errors so that this can harmlessly be called
 	 * on a client '-J' proxy pipe */
 
-	if (opts.disable_ip_tos == 0) {
+	if (opts->disable_ip_tos == 0) {
 #ifdef IP_TOS
 	/* Set the DSCP field for outbound IP packet priority.
 	rfc4594 has some guidance to meanings.
diff -aur dropbear-2022.83/packet.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/packet.c
--- dropbear-2022.83/packet.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/packet.c	2023-08-09 16:05:01.048016094 +0600
@@ -68,11 +68,11 @@
 #endif
 	
 	TRACE2(("enter write_packet"))
-	dropbear_assert(!isempty(&ses.writequeue));
+	dropbear_assert(!isempty(&ses->writequeue));
 
 #if defined(HAVE_WRITEV) && (defined(IOV_MAX) || defined(UIO_MAXIOV))
 
-	packet_queue_to_iovec(&ses.writequeue, iov, &iov_count);
+	packet_queue_to_iovec(&ses->writequeue, iov, &iov_count);
 	/* This may return EAGAIN. The main loop sometimes
 	calls write_packet() without bothering to test with select() since
 	it's likely to be necessary */
@@ -85,7 +85,7 @@
 	else
 #endif
 	{
-	written = writev(ses.sock_out, iov, iov_count);
+	written = writev(ses->sock_out, iov, iov_count);
 	if (written < 0) {
 		if (errno == EINTR || errno == EAGAIN) {
 			TRACE2(("leave write_packet: EINTR"))
@@ -96,11 +96,11 @@
 	}
 	}
 
-	packet_queue_consume(&ses.writequeue, written);
-	ses.writequeue_len -= written;
+	packet_queue_consume(&ses->writequeue, written);
+	ses->writequeue_len -= written;
 
 	if (written == 0) {
-		ses.remoteclosed();
+		ses->remoteclosed();
 	}
 
 #else /* No writev () */
@@ -108,12 +108,12 @@
 	_Static_assert(0, "No fuzzing code for no-writev writes");
 #endif
 	/* Get the next buffer in the queue of encrypted packets to write*/
-	writebuf = (buffer*)examine(&ses.writequeue);
+	writebuf = (buffer*)examine(&ses->writequeue);
 
 	len = writebuf->len - writebuf->pos;
 	dropbear_assert(len > 0);
 	/* Try to write as much as possible */
-	written = write(ses.sock_out, buf_getptr(writebuf, len), len);
+	written = write(ses->sock_out, buf_getptr(writebuf, len), len);
 
 	if (written < 0) {
 		if (errno == EINTR || errno == EAGAIN) {
@@ -125,14 +125,14 @@
 	} 
 
 	if (written == 0) {
-		ses.remoteclosed();
+		ses->remoteclosed();
 	}
 
-	ses.writequeue_len -= written;
+	ses->writequeue_len -= written;
 
 	if (written == len) {
 		/* We've finished with the packet, free it */
-		dequeue(&ses.writequeue);
+		dequeue(&ses->writequeue);
 		buf_free(writebuf);
 		writebuf = NULL;
 	} else {
@@ -154,9 +154,9 @@
 	unsigned char blocksize;
 
 	TRACE2(("enter read_packet"))
-	blocksize = ses.keys->recv.algo_crypt->blocksize;
+	blocksize = ses->keys->recv.algo_crypt->blocksize;
 	
-	if (ses.readbuf == NULL || ses.readbuf->len < blocksize) {
+	if (ses->readbuf == NULL || ses->readbuf->len < blocksize) {
 		int ret;
 		/* In the first blocksize of a packet */
 
@@ -173,17 +173,17 @@
 
 	/* Attempt to read the remainder of the packet, note that there
 	 * mightn't be any available (EAGAIN) */
-	maxlen = ses.readbuf->len - ses.readbuf->pos;
+	maxlen = ses->readbuf->len - ses->readbuf->pos;
 	if (maxlen == 0) {
 		/* Occurs when the packet is only a single block long and has all
 		 * been read in read_packet_init().  Usually means that MAC is disabled
 		 */
 		len = 0;
 	} else {
-		len = read(ses.sock_in, buf_getptr(ses.readbuf, maxlen), maxlen);
+		len = read(ses->sock_in, buf_getptr(ses->readbuf, maxlen), maxlen);
 
 		if (len == 0) {
-			ses.remoteclosed();
+			ses->remoteclosed();
 		}
 
 		if (len < 0) {
@@ -195,7 +195,7 @@
 			}
 		}
 
-		buf_incrpos(ses.readbuf, len);
+		buf_incrpos(ses->readbuf, len);
 	}
 
 	if ((unsigned int)len == maxlen) {
@@ -220,21 +220,21 @@
 	unsigned int macsize;
 
 
-	blocksize = ses.keys->recv.algo_crypt->blocksize;
-	macsize = ses.keys->recv.algo_mac->hashsize;
+	blocksize = ses->keys->recv.algo_crypt->blocksize;
+	macsize = ses->keys->recv.algo_mac->hashsize;
 
-	if (ses.readbuf == NULL) {
+	if (ses->readbuf == NULL) {
 		/* start of a new packet */
-		ses.readbuf = buf_new(INIT_READBUF);
+		ses->readbuf = buf_new(INIT_READBUF);
 	}
 
-	maxlen = blocksize - ses.readbuf->pos;
+	maxlen = blocksize - ses->readbuf->pos;
 			
 	/* read the rest of the packet if possible */
-	slen = read(ses.sock_in, buf_getwriteptr(ses.readbuf, maxlen),
+	slen = read(ses->sock_in, buf_getwriteptr(ses->readbuf, maxlen),
 			maxlen);
 	if (slen == 0) {
-		ses.remoteclosed();
+		ses->remoteclosed();
 	}
 	if (slen < 0) {
 		if (errno == EINTR || errno == EAGAIN) {
@@ -244,7 +244,7 @@
 		dropbear_exit("Error reading: %s", strerror(errno));
 	}
 
-	buf_incrwritepos(ses.readbuf, slen);
+	buf_incrwritepos(ses->readbuf, slen);
 
 	if ((unsigned int)slen != maxlen) {
 		/* don't have enough bytes to determine length, get next time */
@@ -253,26 +253,26 @@
 
 	/* now we have the first block, need to get packet length, so we decrypt
 	 * the first block (only need first 4 bytes) */
-	buf_setpos(ses.readbuf, 0);
+	buf_setpos(ses->readbuf, 0);
 #if DROPBEAR_AEAD_MODE
-	if (ses.keys->recv.crypt_mode->aead_crypt) {
-		if (ses.keys->recv.crypt_mode->aead_getlength(ses.recvseq,
-					buf_getptr(ses.readbuf, blocksize), &plen,
+	if (ses->keys->recv.crypt_mode->aead_crypt) {
+		if (ses->keys->recv.crypt_mode->aead_getlength(ses->recvseq,
+					buf_getptr(ses->readbuf, blocksize), &plen,
 					blocksize,
-					&ses.keys->recv.cipher_state) != CRYPT_OK) {
+					&ses->keys->recv.cipher_state) != CRYPT_OK) {
 			dropbear_exit("Error decrypting");
 		}
 		len = plen + 4 + macsize;
 	} else
 #endif
 	{
-		if (ses.keys->recv.crypt_mode->decrypt(buf_getptr(ses.readbuf, blocksize), 
-					buf_getwriteptr(ses.readbuf, blocksize),
+		if (ses->keys->recv.crypt_mode->decrypt(buf_getptr(ses->readbuf, blocksize), 
+					buf_getwriteptr(ses->readbuf, blocksize),
 					blocksize,
-					&ses.keys->recv.cipher_state) != CRYPT_OK) {
+					&ses->keys->recv.cipher_state) != CRYPT_OK) {
 			dropbear_exit("Error decrypting");
 		}
-		plen = buf_getint(ses.readbuf) + 4;
+		plen = buf_getint(ses->readbuf) + 4;
 		len = plen + macsize;
 	}
 
@@ -286,11 +286,11 @@
 		dropbear_exit("Integrity error (bad packet size %u)", len);
 	}
 
-	if (len > ses.readbuf->size) {
-		ses.readbuf = buf_resize(ses.readbuf, len);		
+	if (len > ses->readbuf->size) {
+		ses->readbuf = buf_resize(ses->readbuf, len);		
 	}
-	buf_setlen(ses.readbuf, len);
-	buf_setpos(ses.readbuf, blocksize);
+	buf_setlen(ses->readbuf, len);
+	buf_setpos(ses->readbuf, blocksize);
 	return DROPBEAR_SUCCESS;
 }
 
@@ -303,42 +303,42 @@
 	unsigned int len;
 
 	TRACE2(("enter decrypt_packet"))
-	blocksize = ses.keys->recv.algo_crypt->blocksize;
-	macsize = ses.keys->recv.algo_mac->hashsize;
+	blocksize = ses->keys->recv.algo_crypt->blocksize;
+	macsize = ses->keys->recv.algo_mac->hashsize;
 
-	ses.kexstate.datarecv += ses.readbuf->len;
+	ses->kexstate.datarecv += ses->readbuf->len;
 
 #if DROPBEAR_AEAD_MODE
-	if (ses.keys->recv.crypt_mode->aead_crypt) {
+	if (ses->keys->recv.crypt_mode->aead_crypt) {
 		/* first blocksize is not decrypted yet */
-		buf_setpos(ses.readbuf, 0);
+		buf_setpos(ses->readbuf, 0);
 
 		/* decrypt it in-place */
-		len = ses.readbuf->len - macsize - ses.readbuf->pos;
-		if (ses.keys->recv.crypt_mode->aead_crypt(ses.recvseq,
-					buf_getptr(ses.readbuf, len + macsize),
-					buf_getwriteptr(ses.readbuf, len),
+		len = ses->readbuf->len - macsize - ses->readbuf->pos;
+		if (ses->keys->recv.crypt_mode->aead_crypt(ses->recvseq,
+					buf_getptr(ses->readbuf, len + macsize),
+					buf_getwriteptr(ses->readbuf, len),
 					len, macsize,
-					&ses.keys->recv.cipher_state, LTC_DECRYPT) != CRYPT_OK) {
+					&ses->keys->recv.cipher_state, LTC_DECRYPT) != CRYPT_OK) {
 			dropbear_exit("Error decrypting");
 		}
-		buf_incrpos(ses.readbuf, len);
+		buf_incrpos(ses->readbuf, len);
 	} else
 #endif
 	{
 		/* we've already decrypted the first blocksize in read_packet_init */
-		buf_setpos(ses.readbuf, blocksize);
+		buf_setpos(ses->readbuf, blocksize);
 
 		/* decrypt it in-place */
-		len = ses.readbuf->len - macsize - ses.readbuf->pos;
-		if (ses.keys->recv.crypt_mode->decrypt(
-					buf_getptr(ses.readbuf, len), 
-					buf_getwriteptr(ses.readbuf, len),
+		len = ses->readbuf->len - macsize - ses->readbuf->pos;
+		if (ses->keys->recv.crypt_mode->decrypt(
+					buf_getptr(ses->readbuf, len), 
+					buf_getwriteptr(ses->readbuf, len),
 					len,
-					&ses.keys->recv.cipher_state) != CRYPT_OK) {
+					&ses->keys->recv.cipher_state) != CRYPT_OK) {
 			dropbear_exit("Error decrypting");
 		}
-		buf_incrpos(ses.readbuf, len);
+		buf_incrpos(ses->readbuf, len);
 
 		/* check the hmac */
 		if (checkmac() != DROPBEAR_SUCCESS) {
@@ -348,39 +348,39 @@
 	}
 	
 #if DROPBEAR_FUZZ
-	fuzz_dump(ses.readbuf->data, ses.readbuf->len);
+	fuzz_dump(ses->readbuf->data, ses->readbuf->len);
 #endif
 
 	/* get padding length */
-	buf_setpos(ses.readbuf, PACKET_PADDING_OFF);
-	padlen = buf_getbyte(ses.readbuf);
+	buf_setpos(ses->readbuf, PACKET_PADDING_OFF);
+	padlen = buf_getbyte(ses->readbuf);
 		
 	/* payload length */
 	/* - 4 - 1 is for LEN and PADLEN values */
-	len = ses.readbuf->len - padlen - 4 - 1 - macsize;
+	len = ses->readbuf->len - padlen - 4 - 1 - macsize;
 	if ((len > RECV_MAX_PAYLOAD_LEN+ZLIB_COMPRESS_EXPANSION) || (len < 1)) {
 		dropbear_exit("Bad packet size %u", len);
 	}
 
-	buf_setpos(ses.readbuf, PACKET_PAYLOAD_OFF);
+	buf_setpos(ses->readbuf, PACKET_PAYLOAD_OFF);
 
 #ifndef DISABLE_ZLIB
 	if (is_compress_recv()) {
 		/* decompress */
-		ses.payload = buf_decompress(ses.readbuf, len);
-		buf_setpos(ses.payload, 0);
-		ses.payload_beginning = 0;
-		buf_free(ses.readbuf);
+		ses->payload = buf_decompress(ses->readbuf, len);
+		buf_setpos(ses->payload, 0);
+		ses->payload_beginning = 0;
+		buf_free(ses->readbuf);
 	} else 
 #endif
 	{
-		ses.payload = ses.readbuf;
-		ses.payload_beginning = ses.payload->pos;
-		buf_setlen(ses.payload, ses.payload->pos + len);
+		ses->payload = ses->readbuf;
+		ses->payload_beginning = ses->payload->pos;
+		buf_setlen(ses->payload, ses->payload->pos + len);
 	}
-	ses.readbuf = NULL;
+	ses->readbuf = NULL;
 
-	ses.recvseq++;
+	ses->recvseq++;
 
 	TRACE2(("leave decrypt_packet"))
 }
@@ -392,11 +392,11 @@
 	unsigned char mac_bytes[MAX_MAC_LEN];
 	unsigned int mac_size, contents_len;
 	
-	mac_size = ses.keys->recv.algo_mac->hashsize;
-	contents_len = ses.readbuf->len - mac_size;
+	mac_size = ses->keys->recv.algo_mac->hashsize;
+	contents_len = ses->readbuf->len - mac_size;
 
-	buf_setpos(ses.readbuf, 0);
-	make_mac(ses.recvseq, &ses.keys->recv, ses.readbuf, contents_len, mac_bytes);
+	buf_setpos(ses->readbuf, 0);
+	make_mac(ses->recvseq, &ses->keys->recv, ses->readbuf, contents_len, mac_bytes);
 
 #if DROPBEAR_FUZZ
 	if (fuzz.fuzzing) {
@@ -413,8 +413,8 @@
 #endif
 
 	/* compare the hash */
-	buf_setpos(ses.readbuf, contents_len);
-	if (constant_time_memcmp(mac_bytes, buf_getptr(ses.readbuf, mac_size), mac_size) != 0) {
+	buf_setpos(ses->readbuf, contents_len);
+	if (constant_time_memcmp(mac_bytes, buf_getptr(ses->readbuf, mac_size), mac_size) != 0) {
 		return DROPBEAR_FAILURE;
 	} else {
 		return DROPBEAR_SUCCESS;
@@ -429,7 +429,7 @@
 	buffer * ret;
 	z_streamp zstream;
 
-	zstream = ses.keys->recv.zstream;
+	zstream = ses->keys->recv.zstream;
 	/* We use RECV_MAX_PAYLOAD_LEN+1 here to ensure that
 	   we can detect an oversized payload after inflate() */
 	ret = buf_new(RECV_MAX_PAYLOAD_LEN+1);
@@ -480,29 +480,29 @@
 	new_item = m_malloc(sizeof(struct packetlist));
 	new_item->next = NULL;
 	
-	new_item->payload = buf_newcopy(ses.writepayload);
-	buf_setpos(ses.writepayload, 0);
-	buf_setlen(ses.writepayload, 0);
+	new_item->payload = buf_newcopy(ses->writepayload);
+	buf_setpos(ses->writepayload, 0);
+	buf_setlen(ses->writepayload, 0);
 	
-	if (ses.reply_queue_tail) {
-		ses.reply_queue_tail->next = new_item;
+	if (ses->reply_queue_tail) {
+		ses->reply_queue_tail->next = new_item;
 	} else {
-		ses.reply_queue_head = new_item;
+		ses->reply_queue_head = new_item;
 	}
-	ses.reply_queue_tail = new_item;
+	ses->reply_queue_tail = new_item;
 }
 
 void maybe_flush_reply_queue() {
 	struct packetlist *tmp_item = NULL, *curr_item = NULL;
-	if (!ses.dataallowed)
+	if (!ses->dataallowed)
 	{
 		TRACE(("maybe_empty_reply_queue - no data allowed"))
 		return;
 	}
 		
-	for (curr_item = ses.reply_queue_head; curr_item; ) {
+	for (curr_item = ses->reply_queue_head; curr_item; ) {
 		CHECKCLEARTOWRITE();
-		buf_putbytes(ses.writepayload,
+		buf_putbytes(ses->writepayload,
 			curr_item->payload->data, curr_item->payload->len);
 			
 		buf_free(curr_item->payload);
@@ -511,7 +511,7 @@
 		m_free(tmp_item);
 		encrypt_packet();
 	}
-	ses.reply_queue_head = ses.reply_queue_tail = NULL;
+	ses->reply_queue_head = ses->reply_queue_tail = NULL;
 }
 	
 /* encrypt the writepayload, putting into writebuf, ready for write_packet()
@@ -530,13 +530,13 @@
 	
 	TRACE2(("enter encrypt_packet()"))
 
-	buf_setpos(ses.writepayload, 0);
-	packet_type = buf_getbyte(ses.writepayload);
-	buf_setpos(ses.writepayload, 0);
+	buf_setpos(ses->writepayload, 0);
+	packet_type = buf_getbyte(ses->writepayload);
+	buf_setpos(ses->writepayload, 0);
 
 	TRACE2(("encrypt_packet type is %d", packet_type))
 	
-	if ((!ses.dataallowed && !packet_is_okay_kex(packet_type))) {
+	if ((!ses->dataallowed && !packet_is_okay_kex(packet_type))) {
 		/* During key exchange only particular packets are allowed.
 			Since this packet_type isn't OK we just enqueue it to send 
 			after the KEX, see maybe_flush_reply_queue */
@@ -544,13 +544,13 @@
 		return;
 	}
 		
-	blocksize = ses.keys->trans.algo_crypt->blocksize;
-	mac_size = ses.keys->trans.algo_mac->hashsize;
+	blocksize = ses->keys->trans.algo_crypt->blocksize;
+	mac_size = ses->keys->trans.algo_mac->hashsize;
 
 	/* Encrypted packet len is payload+5. We need to then make sure
 	 * there is enough space for padding or MIN_PACKET_LEN. 
 	 * Add extra 3 since we need at least 4 bytes of padding */
-	encrypt_buf_size = (ses.writepayload->len+4+1) 
+	encrypt_buf_size = (ses->writepayload->len+4+1) 
 		+ MAX(MIN_PACKET_LEN, blocksize) + 3
 	/* add space for the MAC at the end */
 				+ mac_size
@@ -569,26 +569,26 @@
 #ifndef DISABLE_ZLIB
 	/* compression */
 	if (is_compress_trans()) {
-		buf_compress(writebuf, ses.writepayload, ses.writepayload->len);
+		buf_compress(writebuf, ses->writepayload, ses->writepayload->len);
 	} else
 #endif
 	{
-		memcpy(buf_getwriteptr(writebuf, ses.writepayload->len),
-				buf_getptr(ses.writepayload, ses.writepayload->len),
-				ses.writepayload->len);
-		buf_incrwritepos(writebuf, ses.writepayload->len);
+		memcpy(buf_getwriteptr(writebuf, ses->writepayload->len),
+				buf_getptr(ses->writepayload, ses->writepayload->len),
+				ses->writepayload->len);
+		buf_incrwritepos(writebuf, ses->writepayload->len);
 	}
 
 	/* finished with payload */
-	buf_setpos(ses.writepayload, 0);
-	buf_setlen(ses.writepayload, 0);
+	buf_setpos(ses->writepayload, 0);
+	buf_setlen(ses->writepayload, 0);
 
 	/* length of padding - packet length excluding the packetlength uint32
 	 * field in aead mode must be a multiple of blocksize, with a minimum of
 	 * 4 bytes of padding */
 	len = writebuf->len;
 #if DROPBEAR_AEAD_MODE
-	if (ses.keys->trans.crypt_mode->aead_crypt) {
+	if (ses->keys->trans.crypt_mode->aead_crypt) {
 		len -= 4;
 	}
 #endif
@@ -613,34 +613,34 @@
 	genrandom(buf_getptr(writebuf, padlen), padlen);
 
 #if DROPBEAR_AEAD_MODE
-	if (ses.keys->trans.crypt_mode->aead_crypt) {
+	if (ses->keys->trans.crypt_mode->aead_crypt) {
 		/* do the actual encryption, in-place */
 		buf_setpos(writebuf, 0);
 		/* encrypt it in-place*/
 		len = writebuf->len;
 		buf_incrlen(writebuf, mac_size);
-		if (ses.keys->trans.crypt_mode->aead_crypt(ses.transseq,
+		if (ses->keys->trans.crypt_mode->aead_crypt(ses->transseq,
 					buf_getptr(writebuf, len),
 					buf_getwriteptr(writebuf, len + mac_size),
 					len, mac_size,
-					&ses.keys->trans.cipher_state, LTC_ENCRYPT) != CRYPT_OK) {
+					&ses->keys->trans.cipher_state, LTC_ENCRYPT) != CRYPT_OK) {
 			dropbear_exit("Error encrypting");
 		}
 		buf_incrpos(writebuf, len + mac_size);
 	} else
 #endif
 	{
-		make_mac(ses.transseq, &ses.keys->trans, writebuf, writebuf->len, mac_bytes);
+		make_mac(ses->transseq, &ses->keys->trans, writebuf, writebuf->len, mac_bytes);
 
 		/* do the actual encryption, in-place */
 		buf_setpos(writebuf, 0);
 		/* encrypt it in-place*/
 		len = writebuf->len;
-		if (ses.keys->trans.crypt_mode->encrypt(
+		if (ses->keys->trans.crypt_mode->encrypt(
 					buf_getptr(writebuf, len),
 					buf_getwriteptr(writebuf, len),
 					len,
-					&ses.keys->trans.cipher_state) != CRYPT_OK) {
+					&ses->keys->trans.cipher_state) != CRYPT_OK) {
 			dropbear_exit("Error encrypting");
 		}
 		buf_incrpos(writebuf, len);
@@ -650,22 +650,22 @@
 	}
 
 	/* Update counts */
-	ses.kexstate.datatrans += writebuf->len;
+	ses->kexstate.datatrans += writebuf->len;
 
 	writebuf_enqueue(writebuf);
 
 	/* Update counts */
-	ses.transseq++;
+	ses->transseq++;
 
 	now = monotonic_now();
-	ses.last_packet_time_any_sent = now;
+	ses->last_packet_time_any_sent = now;
 	/* idle timeout shouldn't be affected by responses to keepalives.
 	send_msg_keepalive() itself also does tricks with 
-	ses.last_packet_idle_time - read that if modifying this code */
+	ses->last_packet_idle_time - read that if modifying this code */
 	if (packet_type != SSH_MSG_REQUEST_FAILURE
 		&& packet_type != SSH_MSG_UNIMPLEMENTED
 		&& packet_type != SSH_MSG_IGNORE) {
-		ses.last_packet_time_idle = now;
+		ses->last_packet_time_idle = now;
 
 	}
 
@@ -675,13 +675,13 @@
 void writebuf_enqueue(buffer * writebuf) {
 	/* enqueue the packet for sending. It will get freed after transmission. */
 	buf_setpos(writebuf, 0);
-	enqueue(&ses.writequeue, (void*)writebuf);
-	ses.writequeue_len += writebuf->len;
+	enqueue(&ses->writequeue, (void*)writebuf);
+	ses->writequeue_len += writebuf->len;
 }
 
 
 /* Create the packet mac, and append H(seqno|clearbuf) to the output */
-/* output_mac must have ses.keys->trans.algo_mac->hashsize bytes. */
+/* output_mac must have ses->keys->trans.algo_mac->hashsize bytes. */
 static void make_mac(unsigned int seqno, const struct key_context_directional * key_state,
 		buffer * clear_buf, unsigned int clear_len, 
 		unsigned char *output_mac) {
@@ -733,18 +733,18 @@
 
 	dropbear_assert(dest->size - dest->pos >= len+ZLIB_COMPRESS_EXPANSION);
 
-	ses.keys->trans.zstream->avail_in = endpos - src->pos;
-	ses.keys->trans.zstream->next_in = 
-		buf_getptr(src, ses.keys->trans.zstream->avail_in);
-
-	ses.keys->trans.zstream->avail_out = dest->size - dest->pos;
-	ses.keys->trans.zstream->next_out =
-		buf_getwriteptr(dest, ses.keys->trans.zstream->avail_out);
+	ses->keys->trans.zstream->avail_in = endpos - src->pos;
+	ses->keys->trans.zstream->next_in = 
+		buf_getptr(src, ses->keys->trans.zstream->avail_in);
+
+	ses->keys->trans.zstream->avail_out = dest->size - dest->pos;
+	ses->keys->trans.zstream->next_out =
+		buf_getwriteptr(dest, ses->keys->trans.zstream->avail_out);
 
-	result = deflate(ses.keys->trans.zstream, Z_SYNC_FLUSH);
+	result = deflate(ses->keys->trans.zstream, Z_SYNC_FLUSH);
 
-	buf_setpos(src, endpos - ses.keys->trans.zstream->avail_in);
-	buf_setlen(dest, dest->size - ses.keys->trans.zstream->avail_out);
+	buf_setpos(src, endpos - ses->keys->trans.zstream->avail_in);
+	buf_setlen(dest, dest->size - ses->keys->trans.zstream->avail_out);
 	buf_setpos(dest, dest->len);
 
 	if (result != Z_OK) {
@@ -752,7 +752,7 @@
 	}
 
 	/* fails if destination buffer wasn't large enough */
-	dropbear_assert(ses.keys->trans.zstream->avail_in == 0);
+	dropbear_assert(ses->keys->trans.zstream->avail_in == 0);
 	TRACE2(("leave buf_compress"))
 }
 #endif
diff -aur dropbear-2022.83/process-packet.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/process-packet.c
--- dropbear-2022.83/process-packet.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/process-packet.c	2023-08-09 16:05:01.048016094 +0600
@@ -48,11 +48,11 @@
 
 	TRACE2(("enter process_packet"))
 
-	type = buf_getbyte(ses.payload);
-	TRACE(("process_packet: packet type = %d,  len %d", type, ses.payload->len))
+	type = buf_getbyte(ses->payload);
+	TRACE(("process_packet: packet type = %d,  len %d", type, ses->payload->len))
 
 	now = monotonic_now();
-	ses.last_packet_time_keepalive_recv = now;
+	ses->last_packet_time_keepalive_recv = now;
 
 	/* These packets we can receive at any time */
 	switch(type) {
@@ -79,13 +79,13 @@
 	if (!(type == SSH_MSG_GLOBAL_REQUEST 
 		|| type == SSH_MSG_REQUEST_FAILURE
 		|| type == SSH_MSG_CHANNEL_FAILURE)) {
-		ses.last_packet_time_idle = now;
+		ses->last_packet_time_idle = now;
 	}
 
 	/* This applies for KEX, where the spec says the next packet MUST be
 	 * NEWKEYS */
-	if (ses.requirenext != 0) {
-		if (ses.requirenext == type)
+	if (ses->requirenext != 0) {
+		if (ses->requirenext == type)
 		{
 			/* Got what we expected */
 			TRACE(("got expected packet %d during kexinit", type))
@@ -108,23 +108,23 @@
 			{
 				TRACE(("disallowed packet during kexinit"))
 				dropbear_exit("Unexpected packet type %d, expected %d", type,
-						ses.requirenext);
+						ses->requirenext);
 			}
 		}
 	}
 
 	/* Check if we should ignore this packet. Used currently only for
 	 * KEX code, with first_kex_packet_follows */
-	if (ses.ignorenext) {
+	if (ses->ignorenext) {
 		TRACE(("Ignoring packet, type = %d", type))
-		ses.ignorenext = 0;
+		ses->ignorenext = 0;
 		goto out;
 	}
 
 	/* Only clear the flag after we have checked ignorenext */
-	if (ses.requirenext != 0 && ses.requirenext == type)
+	if (ses->requirenext != 0 && ses->requirenext == type)
 	{
-		ses.requirenext = 0;
+		ses->requirenext = 0;
 	}
 
 
@@ -132,18 +132,18 @@
 	 * less-than-or-equal-to 60 ( == MAX_UNAUTH_PACKET_TYPE ).
 	 * NOTE: if the protocol changes and new types are added, revisit this 
 	 * assumption */
-	if ( !ses.authstate.authdone && type > MAX_UNAUTH_PACKET_TYPE ) {
+	if ( !ses->authstate.authdone && type > MAX_UNAUTH_PACKET_TYPE ) {
 		dropbear_exit("Received message %d before userauth", type);
 	}
 
 	for (i = 0; ; i++) {
-		if (ses.packettypes[i].type == 0) {
+		if (ses->packettypes[i].type == 0) {
 			/* end of list */
 			break;
 		}
 
-		if (ses.packettypes[i].type == type) {
-			ses.packettypes[i].handler();
+		if (ses->packettypes[i].type == type) {
+			ses->packettypes[i].handler();
 			goto out;
 		}
 	}
@@ -154,9 +154,9 @@
 	recv_unimplemented();
 
 out:
-	ses.lastpacket = type;
-	buf_free(ses.payload);
-	ses.payload = NULL;
+	ses->lastpacket = type;
+	buf_free(ses->payload);
+	ses->payload = NULL;
 
 	TRACE2(("leave process_packet"))
 }
@@ -165,16 +165,16 @@
 
 /* This must be called directly after receiving the unimplemented packet.
  * Isn't the most clean implementation, it relies on packet processing
- * occurring directly after decryption (direct use of ses.recvseq).
+ * occurring directly after decryption (direct use of ses->recvseq).
  * This is reasonably valid, since there is only a single decryption buffer */
 static void recv_unimplemented() {
 
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_UNIMPLEMENTED);
+	buf_putbyte(ses->writepayload, SSH_MSG_UNIMPLEMENTED);
 	/* the decryption routine increments the sequence number, we must
 	 * decrement */
-	buf_putint(ses.writepayload, ses.recvseq - 1);
+	buf_putint(ses->writepayload, ses->recvseq - 1);
 
 	encrypt_packet();
 }
diff -aur dropbear-2022.83/runopts.h ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/runopts.h
--- dropbear-2022.83/runopts.h	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/runopts.h	2023-08-09 16:05:01.048016094 +0600
@@ -61,7 +61,7 @@
 
 } runopts;
 
-extern runopts opts;
+extern runopts *opts;
 
 int readhostkey(const char * filename, sign_key * hostkey, 
 	enum signkey_type *type);
@@ -140,7 +140,7 @@
 
 } svr_runopts;
 
-extern svr_runopts svr_opts;
+extern svr_runopts *svr_opts;
 
 void svr_getopts(int argc, char ** argv);
 void loadhostkeys(void);
diff -aur dropbear-2022.83/session.h ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/session.h
--- dropbear-2022.83/session.h	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/session.h	2023-08-09 16:05:01.048016094 +0600
@@ -339,10 +339,10 @@
 };
 
 /* Global structs storing the state */
-extern struct sshsession ses;
+extern struct sshsession *ses;
 
 #if DROPBEAR_SERVER
-extern struct serversession svr_ses;
+extern struct serversession *svr_ses;
 #endif /* DROPBEAR_SERVER */
 
 #if DROPBEAR_CLIENT
diff -aur dropbear-2022.83/svr-agentfwd.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-agentfwd.c
--- dropbear-2022.83/svr-agentfwd.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-agentfwd.c	2023-08-09 16:05:01.052016027 +0600
@@ -156,8 +156,8 @@
 		 * for themselves */
 		uid = getuid();
 		gid = getgid();
-		if ((setegid(ses.authstate.pw_gid)) < 0 ||
-			(seteuid(ses.authstate.pw_uid)) < 0) {
+		if ((setegid(ses->authstate.pw_gid)) < 0 ||
+			(seteuid(ses->authstate.pw_uid)) < 0) {
 			dropbear_exit("Failed to set euid");
 		}
 #endif
@@ -223,8 +223,8 @@
 	/* drop to user privs to make the dir/file */
 	uid = getuid();
 	gid = getgid();
-	if ((setegid(ses.authstate.pw_gid)) < 0 ||
-		(seteuid(ses.authstate.pw_uid)) < 0) {
+	if ((setegid(ses->authstate.pw_gid)) < 0 ||
+		(seteuid(ses->authstate.pw_uid)) < 0) {
 		dropbear_exit("Failed to set euid");
 	}
 #endif
diff -aur dropbear-2022.83/svr-auth.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-auth.c
--- dropbear-2022.83/svr-auth.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-auth.c	2023-08-09 16:13:57.942000560 +0600
@@ -40,13 +40,13 @@
 
 /* initialise the first time for a session, resetting all parameters */
 void svr_authinitialise() {
-	memset(&ses.authstate, 0, sizeof(ses.authstate));
+	memset(&ses->authstate, 0, sizeof(ses->authstate));
 #if DROPBEAR_SVR_PUBKEY_AUTH
-	ses.authstate.authtypes |= AUTH_TYPE_PUBKEY;
+	ses->authstate.authtypes |= AUTH_TYPE_PUBKEY;
 #endif
 #if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
-	if (!svr_opts.noauthpass) {
-		ses.authstate.authtypes |= AUTH_TYPE_PASSWORD;
+	if (!svr_opts->noauthpass) {
+		ses->authstate.authtypes |= AUTH_TYPE_PASSWORD;
 	}
 #endif
 }
@@ -59,9 +59,9 @@
 
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_BANNER);
-	buf_putbufstring(ses.writepayload, banner);
-	buf_putstring(ses.writepayload, "en", 2);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_BANNER);
+	buf_putbufstring(ses->writepayload, banner);
+	buf_putstring(ses->writepayload, "en", 2);
 
 	encrypt_packet();
 
@@ -79,24 +79,24 @@
 	TRACE(("enter recv_msg_userauth_request"))
 
 	/* for compensating failure delay */
-	gettime_wrapper(&ses.authstate.auth_starttime);
+	gettime_wrapper(&ses->authstate.auth_starttime);
 
 	/* ignore packets if auth is already done */
-	if (ses.authstate.authdone == 1) {
+	if (ses->authstate.authdone == 1) {
 		TRACE(("leave recv_msg_userauth_request: authdone already"))
 		return;
 	}
 
 	/* send the banner if it exists, it will only exist once */
-	if (svr_opts.banner) {
-		send_msg_userauth_banner(svr_opts.banner);
-		buf_free(svr_opts.banner);
-		svr_opts.banner = NULL;
+	if (svr_opts->banner) {
+		send_msg_userauth_banner(svr_opts->banner);
+		buf_free(svr_opts->banner);
+		svr_opts->banner = NULL;
 	}
 
-	username = buf_getstring(ses.payload, &userlen);
-	servicename = buf_getstring(ses.payload, &servicelen);
-	methodname = buf_getstring(ses.payload, &methodlen);
+	username = buf_getstring(ses->payload, &userlen);
+	servicename = buf_getstring(ses->payload, &servicelen);
+	methodname = buf_getstring(ses->payload, &methodlen);
 
 	/* only handle 'ssh-connection' currently */
 	if (servicelen != SSH_SERVICE_CONNECTION_LEN
@@ -124,15 +124,15 @@
 				AUTH_METHOD_NONE_LEN) == 0) {
 		TRACE(("recv_msg_userauth_request: 'none' request"))
 		if (valid_user
-				&& svr_opts.allowblankpass
-				&& !svr_opts.noauthpass
-				&& !(svr_opts.norootpass && ses.authstate.pw_uid == 0) 
-				&& ses.authstate.pw_passwd[0] == '\0') 
+				&& svr_opts->allowblankpass
+				&& !svr_opts->noauthpass
+				&& !(svr_opts->norootpass && ses->authstate.pw_uid == 0) 
+				&& ses->authstate.pw_passwd[0] == '\0') 
 		{
 			dropbear_log(LOG_NOTICE, 
 					"Auth succeeded with blank password for '%s' from %s",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
+					ses->authstate.pw_name,
+					svr_ses->addrstring);
 			send_msg_userauth_success();
 			goto out;
 		}
@@ -145,8 +145,8 @@
 	}
 	
 #if DROPBEAR_SVR_PASSWORD_AUTH
-	if (!svr_opts.noauthpass &&
-			!(svr_opts.norootpass && ses.authstate.pw_uid == 0) ) {
+	if (!svr_opts->noauthpass &&
+			!(svr_opts->norootpass && ses->authstate.pw_uid == 0) ) {
 		/* user wants to try password auth */
 		if (methodlen == AUTH_METHOD_PASSWORD_LEN &&
 				strncmp(methodname, AUTH_METHOD_PASSWORD,
@@ -158,8 +158,8 @@
 #endif
 
 #if DROPBEAR_SVR_PAM_AUTH
-	if (!svr_opts.noauthpass &&
-			!(svr_opts.norootpass && ses.authstate.pw_uid == 0) ) {
+	if (!svr_opts->noauthpass &&
+			!(svr_opts->norootpass && ses->authstate.pw_uid == 0) ) {
 		/* user wants to try password auth */
 		if (methodlen == AUTH_METHOD_PASSWORD_LEN &&
 				strncmp(methodname, AUTH_METHOD_PASSWORD,
@@ -243,70 +243,70 @@
 		dropbear_exit("Attempted username with a null byte");
 	}
 
-	if (ses.authstate.username == NULL) {
+	if (ses->authstate.username == NULL) {
 		/* first request */
 		fill_passwd(username);
-		ses.authstate.username = m_strdup(username);
+		ses->authstate.username = m_strdup(username);
 	} else {
 		/* check username hasn't changed */
-		if (strcmp(username, ses.authstate.username) != 0) {
+		if (strcmp(username, ses->authstate.username) != 0) {
 			dropbear_exit("Client trying multiple usernames");
 		}
 	}
 
 	/* avoids cluttering logs with repeated failure messages from
 	consecutive authentication requests in a sesssion */
-	if (ses.authstate.checkusername_failed) {
+	if (ses->authstate.checkusername_failed) {
 		TRACE(("checkusername: returning cached failure"))
 		return DROPBEAR_FAILURE;
 	}
 
 	/* check that user exists */
-	if (!ses.authstate.pw_name) {
+	if (!ses->authstate.pw_name) {
 		TRACE(("leave checkusername: user '%s' doesn't exist", username))
 		dropbear_log(LOG_WARNING,
 				"Login attempt for nonexistent user");
-		ses.authstate.checkusername_failed = 1;
+		ses->authstate.checkusername_failed = 1;
 		return DROPBEAR_FAILURE;
 	}
 
 	/* check if we are running as non-root, and login user is different from the server */
 	uid = geteuid();
-	if (!(DROPBEAR_SVR_MULTIUSER && uid == 0) && uid != ses.authstate.pw_uid) {
+	if (!(DROPBEAR_SVR_MULTIUSER && uid == 0) && uid != ses->authstate.pw_uid) {
 		TRACE(("running as nonroot, only server uid is allowed"))
 		dropbear_log(LOG_WARNING,
 				"Login attempt with wrong user %s",
-				ses.authstate.pw_name);
-		ses.authstate.checkusername_failed = 1;
+				ses->authstate.pw_name);
+		ses->authstate.checkusername_failed = 1;
 		return DROPBEAR_FAILURE;
 	}
 
 	/* check for non-root if desired */
-	if (svr_opts.norootlogin && ses.authstate.pw_uid == 0) {
+	if (svr_opts->norootlogin && ses->authstate.pw_uid == 0) {
 		TRACE(("leave checkusername: root login disabled"))
 		dropbear_log(LOG_WARNING, "root login rejected");
-		ses.authstate.checkusername_failed = 1;
+		ses->authstate.checkusername_failed = 1;
 		return DROPBEAR_FAILURE;
 	}
 
 	/* check for login restricted to certain group if desired */
 #ifdef HAVE_GETGROUPLIST
-	if (svr_opts.restrict_group) {
-		if (check_group_membership(svr_opts.restrict_group_gid,
-				ses.authstate.pw_name, ses.authstate.pw_gid) == DROPBEAR_FAILURE) {
+	if (svr_opts->restrict_group) {
+		if (check_group_membership(svr_opts->restrict_group_gid,
+				ses->authstate.pw_name, ses->authstate.pw_gid) == DROPBEAR_FAILURE) {
 			dropbear_log(LOG_WARNING,
 				"Logins are restricted to the group %s but user '%s' is not a member",
-				svr_opts.restrict_group, ses.authstate.pw_name);
-			ses.authstate.checkusername_failed = 1;
+				svr_opts->restrict_group, ses->authstate.pw_name);
+			ses->authstate.checkusername_failed = 1;
 			return DROPBEAR_FAILURE;
 		}
 	}
 #endif /* HAVE_GETGROUPLIST */
 
-	TRACE(("shell is %s", ses.authstate.pw_shell))
+	TRACE(("shell is %s", ses->authstate.pw_shell))
 
 	/* check that the shell is set */
-	usershell = ses.authstate.pw_shell;
+	usershell = ses->authstate.pw_shell;
 	if (usershell[0] == '\0') {
 		/* empty shell in /etc/passwd means /bin/sh according to passwd(5) */
 		usershell = "/bin/sh";
@@ -326,16 +326,16 @@
 	/* no matching shell */
 	endusershell();
 	TRACE(("no matching shell"))
-	ses.authstate.checkusername_failed = 1;
+	ses->authstate.checkusername_failed = 1;
 	dropbear_log(LOG_WARNING, "User '%s' has invalid shell, rejected",
-				ses.authstate.pw_name);
+				ses->authstate.pw_name);
 	return DROPBEAR_FAILURE;
 	
 goodshell:
 	endusershell();
 	TRACE(("matching shell"))
 
-	TRACE(("uid = %d", ses.authstate.pw_uid))
+	TRACE(("uid = %d", ses->authstate.pw_uid))
 	TRACE(("leave checkusername"))
 	return DROPBEAR_SUCCESS;
 }
@@ -353,37 +353,37 @@
 
 	CHECKCLEARTOWRITE();
 	
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_FAILURE);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_FAILURE);
 
 	/* put a list of allowed types */
 	typebuf = buf_new(30); /* long enough for PUBKEY and PASSWORD */
 
-	if (ses.authstate.authtypes & AUTH_TYPE_PUBKEY) {
+	if (ses->authstate.authtypes & AUTH_TYPE_PUBKEY) {
 		buf_putbytes(typebuf, (const unsigned char *)AUTH_METHOD_PUBKEY, AUTH_METHOD_PUBKEY_LEN);
-		if (ses.authstate.authtypes & AUTH_TYPE_PASSWORD) {
+		if (ses->authstate.authtypes & AUTH_TYPE_PASSWORD) {
 			buf_putbyte(typebuf, ',');
 		}
 	}
 	
-	if (ses.authstate.authtypes & AUTH_TYPE_PASSWORD) {
+	if (ses->authstate.authtypes & AUTH_TYPE_PASSWORD) {
 		buf_putbytes(typebuf, (const unsigned char *)AUTH_METHOD_PASSWORD, AUTH_METHOD_PASSWORD_LEN);
 	}
 
-	buf_putbufstring(ses.writepayload, typebuf);
+	buf_putbufstring(ses->writepayload, typebuf);
 
-	TRACE(("auth fail: methods %d, '%.*s'", ses.authstate.authtypes,
+	TRACE(("auth fail: methods %d, '%.*s'", ses->authstate.authtypes,
 				typebuf->len, typebuf->data))
 
 	buf_free(typebuf);
 
-	buf_putbyte(ses.writepayload, partial ? 1 : 0);
+	buf_putbyte(ses->writepayload, partial ? 1 : 0);
 	encrypt_packet();
 
 	if (incrfail) {
 		/* The SSH_MSG_AUTH_FAILURE response is delayed to attempt to
 		avoid user enumeration and slow brute force attempts.
 		The delay is adjusted by the time already spent in processing
-		authentication (ses.authstate.auth_starttime timestamp). */
+		authentication (ses->authstate.auth_starttime timestamp). */
 
 		/* Desired total delay 300ms +-50ms (in nanoseconds).
 		Beware of integer overflow if increasing these values */
@@ -393,8 +393,8 @@
 		struct timespec delay;
 
 		gettime_wrapper(&delay);
-		delay.tv_sec -= ses.authstate.auth_starttime.tv_sec;
-		delay.tv_nsec -= ses.authstate.auth_starttime.tv_nsec;
+		delay.tv_sec -= ses->authstate.auth_starttime.tv_sec;
+		delay.tv_nsec -= ses->authstate.auth_starttime.tv_nsec;
 
 		/* carry */
 		if (delay.tv_nsec < 0) {
@@ -422,18 +422,18 @@
 			while (nanosleep(&delay, &delay) == -1 && errno == EINTR) { /* Go back to sleep */ }
 		}
 
-		ses.authstate.failcount++;
+		ses->authstate.failcount++;
 	}
 
-	if (ses.authstate.failcount >= svr_opts.maxauthtries) {
+	if (ses->authstate.failcount >= svr_opts->maxauthtries) {
 		char * userstr;
 		/* XXX - send disconnect ? */
 		TRACE(("Max auth tries reached, exiting"))
 
-		if (ses.authstate.pw_name == NULL) {
+		if (ses->authstate.pw_name == NULL) {
 			userstr = "is invalid";
 		} else {
-			userstr = ses.authstate.pw_name;
+			userstr = ses->authstate.pw_name;
 		}
 		dropbear_exit("Max auth tries reached - user '%s'",
 				userstr);
@@ -449,23 +449,23 @@
 
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_SUCCESS);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_SUCCESS);
 	encrypt_packet();
 
 	/* authdone must be set after encrypt_packet() for 
 	 * delayed-zlib mode */
-	ses.authstate.authdone = 1;
-	ses.connect_time = 0;
+	ses->authstate.authdone = 1;
+	ses->connect_time = 0;
 
 
-	if (ses.authstate.pw_uid == 0) {
-		ses.allowprivport = 1;
+	if (ses->authstate.pw_uid == 0) {
+		ses->allowprivport = 1;
 	}
 
 	/* Remove from the list of pre-auth sockets. Should be m_close(), since if
 	 * we fail, we might end up leaking connection slots, and disallow new
 	 * logins - a nasty situation. */							
-	m_close(svr_ses.childpipe);
+	m_close(svr_ses->childpipe);
 
 	TRACE(("leave send_msg_userauth_success"))
 
diff -aur dropbear-2022.83/svr-authpam.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpam.c
--- dropbear-2022.83/svr-authpam.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpam.c	2023-08-09 16:05:01.052016027 +0600
@@ -197,28 +197,28 @@
 	unsigned char changepw;
 
 	/* check if client wants to change password */
-	changepw = buf_getbool(ses.payload);
+	changepw = buf_getbool(ses->payload);
 	if (changepw) {
 		/* not implemented by this server */
 		send_msg_userauth_failure(0, 1);
 		goto cleanup;
 	}
 
-	password = buf_getstring(ses.payload, &passwordlen);
+	password = buf_getstring(ses->payload, &passwordlen);
 
 	/* We run the PAM conversation regardless of whether the username is valid
 	in case the conversation function has an inherent delay.
-	Use ses.authstate.username rather than ses.authstate.pw_name.
+	Use ses->authstate.username rather than ses->authstate.pw_name.
 	After PAM succeeds we then check the valid_user flag too */
 
 	/* used to pass data to the PAM conversation function - don't bother with
 	 * strdup() etc since these are touched only by our own conversation
 	 * function (above) which takes care of it */
-	userData.user = ses.authstate.username;
+	userData.user = ses->authstate.username;
 	userData.passwd = password;
 
-	if (ses.authstate.pw_name) {
-		printable_user = ses.authstate.pw_name;
+	if (ses->authstate.pw_name) {
+		printable_user = ses->authstate.pw_name;
 	} else {
 		printable_user = "<invalid username>";
 	}
@@ -237,7 +237,7 @@
 		goto cleanup;
 	}
 
-	if ((rc = pam_set_item(pamHandlep, PAM_RHOST, svr_ses.remotehost)) != PAM_SUCCESS) {
+	if ((rc = pam_set_item(pamHandlep, PAM_RHOST, svr_ses->remotehost)) != PAM_SUCCESS) {
 		dropbear_log(LOG_WARNING, "pam_set_item() failed, rc=%d, %s",
 				rc, pam_strerror(pamHandlep, rc));
 		goto cleanup;
@@ -256,7 +256,7 @@
 		dropbear_log(LOG_WARNING,
 				"Bad PAM password attempt for '%s' from %s",
 				printable_user,
-				svr_ses.addrstring);
+				svr_ses->addrstring);
 		send_msg_userauth_failure(0, 1);
 		goto cleanup;
 	}
@@ -267,7 +267,7 @@
 		dropbear_log(LOG_WARNING,
 				"Bad PAM password attempt for '%s' from %s",
 				printable_user,
-				svr_ses.addrstring);
+				svr_ses->addrstring);
 		send_msg_userauth_failure(0, 1);
 		goto cleanup;
 	}
@@ -279,19 +279,19 @@
 		goto cleanup;
 	}
 
-	if (svr_opts.multiauthmethod && (ses.authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
+	if (svr_opts->multiauthmethod && (ses->authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
 			/* successful PAM password authentication, but extra auth required */
 			dropbear_log(LOG_NOTICE,
 					"PAM password auth succeeded for '%s' from %s, extra auth required",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
-			ses.authstate.authtypes &= ~AUTH_TYPE_PASSWORD; /* PAM password auth ok, delete the method flag */
+					ses->authstate.pw_name,
+					svr_ses->addrstring);
+			ses->authstate.authtypes &= ~AUTH_TYPE_PASSWORD; /* PAM password auth ok, delete the method flag */
 			send_msg_userauth_failure(1, 0);  /* Send partial success */
 		} else {
 			/* successful authentication */
 			dropbear_log(LOG_NOTICE, "PAM password auth succeeded for '%s' from %s",
-				ses.authstate.pw_name,
-				svr_ses.addrstring);
+				ses->authstate.pw_name,
+				svr_ses->addrstring);
 			send_msg_userauth_success();
 		}
 		
diff -aur dropbear-2022.83/svr-authpasswd.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpasswd.c
--- dropbear-2022.83/svr-authpasswd.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpasswd.c	2023-08-09 16:05:01.052016027 +0600
@@ -57,17 +57,17 @@
 	unsigned int changepw;
 
 	/* check if client wants to change password */
-	changepw = buf_getbool(ses.payload);
+	changepw = buf_getbool(ses->payload);
 	if (changepw) {
 		/* not implemented by this server */
 		send_msg_userauth_failure(0, 1);
 		return;
 	}
 
-	password = buf_getstring(ses.payload, &passwordlen);
+	password = buf_getstring(ses->payload, &passwordlen);
 	if (valid_user && passwordlen <= DROPBEAR_MAX_PASSWORD_LEN) {
 		/* the first bytes of passwdcrypt are the salt */
-		passwdcrypt = ses.authstate.pw_passwd;
+		passwdcrypt = ses->authstate.pw_passwd;
 		testcrypt = crypt(password, passwdcrypt);
 	}
 	m_burn(password, passwordlen);
@@ -83,8 +83,8 @@
 	if (passwordlen > DROPBEAR_MAX_PASSWORD_LEN) {
 		dropbear_log(LOG_WARNING,
 				"Too-long password attempt for '%s' from %s",
-				ses.authstate.pw_name,
-				svr_ses.addrstring);
+				ses->authstate.pw_name,
+				svr_ses->addrstring);
 		send_msg_userauth_failure(0, 1);
 		return;
 	}
@@ -92,7 +92,7 @@
 	if (testcrypt == NULL) {
 		/* crypt() with an invalid salt like "!!" */
 		dropbear_log(LOG_WARNING, "User account '%s' is locked",
-				ses.authstate.pw_name);
+				ses->authstate.pw_name);
 		send_msg_userauth_failure(0, 1);
 		return;
 	}
@@ -100,33 +100,33 @@
 	/* check for empty password */
 	if (passwdcrypt[0] == '\0') {
 		dropbear_log(LOG_WARNING, "User '%s' has blank password, rejected",
-				ses.authstate.pw_name);
+				ses->authstate.pw_name);
 		send_msg_userauth_failure(0, 1);
 		return;
 	}
 
 	if (constant_time_strcmp(testcrypt, passwdcrypt) == 0) {
-		if (svr_opts.multiauthmethod && (ses.authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
+		if (svr_opts->multiauthmethod && (ses->authstate.authtypes & ~AUTH_TYPE_PASSWORD)) {
 			/* successful password authentication, but extra auth required */
 			dropbear_log(LOG_NOTICE,
 					"Password auth succeeded for '%s' from %s, extra auth required",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
-			ses.authstate.authtypes &= ~AUTH_TYPE_PASSWORD; /* password auth ok, delete the method flag */
+					ses->authstate.pw_name,
+					svr_ses->addrstring);
+			ses->authstate.authtypes &= ~AUTH_TYPE_PASSWORD; /* password auth ok, delete the method flag */
 			send_msg_userauth_failure(1, 0);  /* Send partial success */
 		} else {
 			/* successful authentication */
 			dropbear_log(LOG_NOTICE, 
 					"Password auth succeeded for '%s' from %s",
-					ses.authstate.pw_name,
-					svr_ses.addrstring);
+					ses->authstate.pw_name,
+					svr_ses->addrstring);
 			send_msg_userauth_success();
 		}
 	} else {
 		dropbear_log(LOG_WARNING,
 				"Bad password attempt for '%s' from %s",
-				ses.authstate.pw_name,
-				svr_ses.addrstring);
+				ses->authstate.pw_name,
+				svr_ses->addrstring);
 		send_msg_userauth_failure(0, 1);
 	}
 }
diff -aur dropbear-2022.83/svr-authpubkey.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpubkey.c
--- dropbear-2022.83/svr-authpubkey.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpubkey.c	2023-08-09 16:05:01.052016027 +0600
@@ -101,11 +101,11 @@
 
 	/* 0 indicates user just wants to check if key can be used, 1 is an
 	 * actual attempt*/
-	testkey = (buf_getbool(ses.payload) == 0);
+	testkey = (buf_getbool(ses->payload) == 0);
 
-	sigalgo = buf_getstring(ses.payload, &sigalgolen);
-	keybloblen = buf_getint(ses.payload);
-	keyblob = buf_getptr(ses.payload, keybloblen);
+	sigalgo = buf_getstring(ses->payload, &sigalgolen);
+	keybloblen = buf_getint(ses->payload);
+	keyblob = buf_getptr(ses->payload, keybloblen);
 
 	if (!valid_user) {
 		/* Return failure once we have read the contents of the packet
@@ -126,21 +126,21 @@
 	keyalgo = signkey_name_from_type(keytype, &keyalgolen);
 
 #if DROPBEAR_PLUGIN
-        if (svr_ses.plugin_instance != NULL) {
+        if (svr_ses->plugin_instance != NULL) {
             char *options_buf;
-            if (svr_ses.plugin_instance->checkpubkey(
-                        svr_ses.plugin_instance,
-                        &ses.plugin_session,
+            if (svr_ses->plugin_instance->checkpubkey(
+                        svr_ses->plugin_instance,
+                        &ses->plugin_session,
                         keyalgo,
                         keyalgolen,
                         keyblob,
                         keybloblen,
-                        ses.authstate.username) == DROPBEAR_SUCCESS) {
+                        ses->authstate.username) == DROPBEAR_SUCCESS) {
                 /* Success */
                 auth_failure = 0;
 
                 /* Options provided? */
-                options_buf = ses.plugin_session->get_options(ses.plugin_session);
+                options_buf = ses->plugin_session->get_options(ses->plugin_session);
                 if (options_buf) {
                     struct buf temp_buf = {
                         .data = (unsigned char *)options_buf,
@@ -178,68 +178,68 @@
 
 	/* get the key */
 	key = new_sign_key();
-	if (buf_get_pub_key(ses.payload, key, &keytype) == DROPBEAR_FAILURE) {
+	if (buf_get_pub_key(ses->payload, key, &keytype) == DROPBEAR_FAILURE) {
 		send_msg_userauth_failure(0, 1);
 		goto out;
 	}
 
 #if DROPBEAR_SK_ECDSA || DROPBEAR_SK_ED25519
 	key->sk_flags_mask = SSH_SK_USER_PRESENCE_REQD;
-	if (ses.authstate.pubkey_options && ses.authstate.pubkey_options->no_touch_required_flag) {
+	if (ses->authstate.pubkey_options && ses->authstate.pubkey_options->no_touch_required_flag) {
 		key->sk_flags_mask &= ~SSH_SK_USER_PRESENCE_REQD;
 	}
-	if (ses.authstate.pubkey_options && ses.authstate.pubkey_options->verify_required_flag) {
+	if (ses->authstate.pubkey_options && ses->authstate.pubkey_options->verify_required_flag) {
 		key->sk_flags_mask |= SSH_SK_USER_VERIFICATION_REQD;
 	}
 #endif
 
 	/* create the data which has been signed - this a string containing
 	 * session_id, concatenated with the payload packet up to the signature */
-	assert(ses.payload_beginning <= ses.payload->pos);
-	sign_payload_length = ses.payload->pos - ses.payload_beginning;
-	signbuf = buf_new(ses.payload->pos + 4 + ses.session_id->len);
-	buf_putbufstring(signbuf, ses.session_id);
+	assert(ses->payload_beginning <= ses->payload->pos);
+	sign_payload_length = ses->payload->pos - ses->payload_beginning;
+	signbuf = buf_new(ses->payload->pos + 4 + ses->session_id->len);
+	buf_putbufstring(signbuf, ses->session_id);
 
 	/* The entire contents of the payload prior. */
-	buf_setpos(ses.payload, ses.payload_beginning);
+	buf_setpos(ses->payload, ses->payload_beginning);
 	buf_putbytes(signbuf,
-		buf_getptr(ses.payload, sign_payload_length),
+		buf_getptr(ses->payload, sign_payload_length),
 		sign_payload_length);
-	buf_incrpos(ses.payload, sign_payload_length);
+	buf_incrpos(ses->payload, sign_payload_length);
 
 	buf_setpos(signbuf, 0);
 
 	/* ... and finally verify the signature */
 	fp = sign_key_fingerprint(keyblob, keybloblen);
-	if (buf_verify(ses.payload, key, sigtype, signbuf) == DROPBEAR_SUCCESS) {
-		if (svr_opts.multiauthmethod && (ses.authstate.authtypes & ~AUTH_TYPE_PUBKEY)) {
+	if (buf_verify(ses->payload, key, sigtype, signbuf) == DROPBEAR_SUCCESS) {
+		if (svr_opts->multiauthmethod && (ses->authstate.authtypes & ~AUTH_TYPE_PUBKEY)) {
 			/* successful pubkey authentication, but extra auth required */
 			dropbear_log(LOG_NOTICE,
 					"Pubkey auth succeeded for '%s' with %s key %s from %s, extra auth required",
-					ses.authstate.pw_name,
+					ses->authstate.pw_name,
 					signkey_name_from_type(keytype, NULL), fp,
-					svr_ses.addrstring);
-			ses.authstate.authtypes &= ~AUTH_TYPE_PUBKEY; /* pubkey auth ok, delete the method flag */
+					svr_ses->addrstring);
+			ses->authstate.authtypes &= ~AUTH_TYPE_PUBKEY; /* pubkey auth ok, delete the method flag */
 			send_msg_userauth_failure(1, 0); /* Send partial success */
 		} else {
 			/* successful authentication */
 			dropbear_log(LOG_NOTICE,
 					"Pubkey auth succeeded for '%s' with %s key %s from %s",
-					ses.authstate.pw_name,
+					ses->authstate.pw_name,
 					signkey_name_from_type(keytype, NULL), fp,
-					svr_ses.addrstring);
+					svr_ses->addrstring);
 			send_msg_userauth_success();
 		}
 #if DROPBEAR_PLUGIN
-                if ((ses.plugin_session != NULL) && (svr_ses.plugin_instance->auth_success != NULL)) {
+                if ((ses->plugin_session != NULL) && (svr_ses->plugin_instance->auth_success != NULL)) {
                     /* Was authenticated through the external plugin. tell plugin that signature verification was ok */
-                    svr_ses.plugin_instance->auth_success(ses.plugin_session);
+                    svr_ses->plugin_instance->auth_success(ses->plugin_session);
                 }
 #endif
 	} else {
 		dropbear_log(LOG_WARNING,
 				"Pubkey auth bad signature for '%s' with key %s from %s",
-				ses.authstate.pw_name, fp, svr_ses.addrstring);
+				ses->authstate.pw_name, fp, svr_ses->addrstring);
 		send_msg_userauth_failure(0, 1);
 	}
 	m_free(fp);
@@ -257,7 +257,7 @@
 		key = NULL;
 	}
 	/* Retain pubkey options only if auth succeeded */
-	if (!ses.authstate.authdone) {
+	if (!ses->authstate.authdone) {
 		svr_pubkey_options_cleanup();
 	}
 	TRACE(("leave pubkeyauth"))
@@ -272,9 +272,9 @@
 	TRACE(("enter send_msg_userauth_pk_ok"))
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_PK_OK);
-	buf_putstring(ses.writepayload, sigalgo, sigalgolen);
-	buf_putstring(ses.writepayload, (const char*)keyblob, keybloblen);
+	buf_putbyte(ses->writepayload, SSH_MSG_USERAUTH_PK_OK);
+	buf_putstring(ses->writepayload, sigalgo, sigalgolen);
+	buf_putstring(ses->writepayload, (const char*)keyblob, keybloblen);
 
 	encrypt_packet();
 	TRACE(("leave send_msg_userauth_pk_ok"))
@@ -453,8 +453,8 @@
 	/* access the file as the authenticating user. */
 	origuid = getuid();
 	origgid = getgid();
-	if ((setegid(ses.authstate.pw_gid)) < 0 ||
-		(seteuid(ses.authstate.pw_uid)) < 0) {
+	if ((setegid(ses->authstate.pw_gid)) < 0 ||
+		(seteuid(ses->authstate.pw_uid)) < 0) {
 		dropbear_exit("Failed to set euid");
 	}
 #endif
@@ -464,12 +464,12 @@
 	} else {
 		/* we don't need to check pw and pw_dir for validity, since
 		 * its been done in checkpubkeyperms. */
-		len = strlen(ses.authstate.pw_dir);
+		len = strlen(ses->authstate.pw_dir);
 		/* allocate max required pathname storage,
 		 * = path + "/.ssh/authorized_keys" + '\0' = pathlen + 22 */
 		filename = m_malloc(len + 22);
 		snprintf(filename, len + 22, "%s/.ssh/authorized_keys",
-					ses.authstate.pw_dir);
+					ses->authstate.pw_dir);
 
 		authfile = fopen(filename, "r");
 		if (!authfile) {
@@ -501,7 +501,7 @@
 		line_num++;
 
 		ret = checkpubkey_line(line, line_num, filename, keyalgo, keyalgolen,
-			keyblob, keybloblen, &ses.authstate.pubkey_info);
+			keyblob, keybloblen, &ses->authstate.pubkey_info);
 		if (ret == DROPBEAR_SUCCESS) {
 			break;
 		}
@@ -535,11 +535,11 @@
 
 	TRACE(("enter checkpubkeyperms"))
 
-	if (ses.authstate.pw_dir == NULL) {
+	if (ses->authstate.pw_dir == NULL) {
 		goto out;
 	}
 
-	if ((len = strlen(ses.authstate.pw_dir)) == 0) {
+	if ((len = strlen(ses->authstate.pw_dir)) == 0) {
 		goto out;
 	}
 
@@ -547,7 +547,7 @@
 	 * = path + "/.ssh/authorized_keys" + '\0' = pathlen + 22 */
 	len += 22;
 	filename = m_malloc(len);
-	strlcpy(filename, ses.authstate.pw_dir, len);
+	strlcpy(filename, ses->authstate.pw_dir, len);
 
 	/* check ~ */
 	if (checkfileperm(filename) != DROPBEAR_SUCCESS) {
@@ -590,7 +590,7 @@
 		return DROPBEAR_FAILURE;
 	}
 	/* check ownership - user or root only*/
-	if (filestat.st_uid != ses.authstate.pw_uid
+	if (filestat.st_uid != ses->authstate.pw_uid
 			&& filestat.st_uid != 0) {
 		badperm = 1;
 		TRACE(("wrong ownership"))
@@ -601,8 +601,8 @@
 		TRACE(("wrong perms"))
 	}
 	if (badperm) {
-		if (!ses.authstate.perm_warn) {
-			ses.authstate.perm_warn = 1;
+		if (!ses->authstate.perm_warn) {
+			ses->authstate.perm_warn = 1;
 			dropbear_log(LOG_INFO, "%s must be owned by user or root, and not writable by group or others", filename);
 		}
 		TRACE(("leave checkfileperm: failure perms/owner"))
diff -aur dropbear-2022.83/svr-authpubkeyoptions.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpubkeyoptions.c
--- dropbear-2022.83/svr-authpubkeyoptions.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-authpubkeyoptions.c	2023-08-09 16:05:01.056015960 +0600
@@ -53,8 +53,8 @@
 /* Returns 1 if pubkey allows agent forwarding,
  * 0 otherwise */
 int svr_pubkey_allows_agentfwd() {
-	if (ses.authstate.pubkey_options 
-		&& ses.authstate.pubkey_options->no_agent_forwarding_flag) {
+	if (ses->authstate.pubkey_options 
+		&& ses->authstate.pubkey_options->no_agent_forwarding_flag) {
 		return 0;
 	}
 	return 1;
@@ -63,8 +63,8 @@
 /* Returns 1 if pubkey allows tcp forwarding,
  * 0 otherwise */
 int svr_pubkey_allows_tcpfwd() {
-	if (ses.authstate.pubkey_options 
-		&& ses.authstate.pubkey_options->no_port_forwarding_flag) {
+	if (ses->authstate.pubkey_options 
+		&& ses->authstate.pubkey_options->no_port_forwarding_flag) {
 		return 0;
 	}
 	return 1;
@@ -73,8 +73,8 @@
 /* Returns 1 if pubkey allows x11 forwarding,
  * 0 otherwise */
 int svr_pubkey_allows_x11fwd() {
-	if (ses.authstate.pubkey_options 
-		&& ses.authstate.pubkey_options->no_x11_forwarding_flag) {
+	if (ses->authstate.pubkey_options 
+		&& ses->authstate.pubkey_options->no_x11_forwarding_flag) {
 		return 0;
 	}
 	return 1;
@@ -82,8 +82,8 @@
 
 /* Returns 1 if pubkey allows pty, 0 otherwise */
 int svr_pubkey_allows_pty() {
-	if (ses.authstate.pubkey_options 
-		&& ses.authstate.pubkey_options->no_pty_flag) {
+	if (ses->authstate.pubkey_options 
+		&& ses->authstate.pubkey_options->no_pty_flag) {
 		return 0;
 	}
 	return 1;
@@ -92,9 +92,9 @@
 /* Returns 1 if pubkey allows local tcp fowarding to the provided destination,
  * 0 otherwise */
 int svr_pubkey_allows_local_tcpfwd(const char *host, unsigned int port) {
-	if (ses.authstate.pubkey_options
-		&& ses.authstate.pubkey_options->permit_open_destinations) {
-		m_list_elem *iter = ses.authstate.pubkey_options->permit_open_destinations->first;
+	if (ses->authstate.pubkey_options
+		&& ses->authstate.pubkey_options->permit_open_destinations) {
+		m_list_elem *iter = ses->authstate.pubkey_options->permit_open_destinations->first;
 		while (iter) {
 			struct PermitTCPFwdEntry *entry = (struct PermitTCPFwdEntry*)iter->item;
 			if (strcmp(entry->host, host) == 0) {
@@ -115,8 +115,8 @@
 /* Set chansession command to the one forced 
  * by any 'command' public key option. */
 void svr_pubkey_set_forced_command(struct ChanSess *chansess) {
-	if (ses.authstate.pubkey_options && ses.authstate.pubkey_options->forced_command) {
-		TRACE(("Forced command '%s'", ses.authstate.pubkey_options->forced_command))
+	if (ses->authstate.pubkey_options && ses->authstate.pubkey_options->forced_command) {
+		TRACE(("Forced command '%s'", ses->authstate.pubkey_options->forced_command))
 		if (chansess->cmd) {
 			/* original_command takes ownership */
 			chansess->original_command = chansess->cmd;
@@ -124,7 +124,7 @@
 		} else {
 			chansess->original_command = m_strdup("");
 		}
-		chansess->cmd = m_strdup(ses.authstate.pubkey_options->forced_command);
+		chansess->cmd = m_strdup(ses->authstate.pubkey_options->forced_command);
 #if LOG_COMMANDS
 		dropbear_log(LOG_INFO, "Command forced to '%s'", chansess->original_command);
 #endif
@@ -133,24 +133,24 @@
 
 /* Free potential public key options */
 void svr_pubkey_options_cleanup() {
-	if (ses.authstate.pubkey_options) {
-		if (ses.authstate.pubkey_options->forced_command) {
-			m_free(ses.authstate.pubkey_options->forced_command);
+	if (ses->authstate.pubkey_options) {
+		if (ses->authstate.pubkey_options->forced_command) {
+			m_free(ses->authstate.pubkey_options->forced_command);
 		}
-		if (ses.authstate.pubkey_options->permit_open_destinations) {
-			m_list_elem *iter = ses.authstate.pubkey_options->permit_open_destinations->first;
+		if (ses->authstate.pubkey_options->permit_open_destinations) {
+			m_list_elem *iter = ses->authstate.pubkey_options->permit_open_destinations->first;
 			while (iter) {
 				struct PermitTCPFwdEntry *entry = (struct PermitTCPFwdEntry*)list_remove(iter);
 				m_free(entry->host);
 				m_free(entry);
-				iter = ses.authstate.pubkey_options->permit_open_destinations->first;
+				iter = ses->authstate.pubkey_options->permit_open_destinations->first;
 			}
-			m_free(ses.authstate.pubkey_options->permit_open_destinations);
+			m_free(ses->authstate.pubkey_options->permit_open_destinations);
 		}
-		m_free(ses.authstate.pubkey_options);
+		m_free(ses->authstate.pubkey_options);
 	}
-	if (ses.authstate.pubkey_info) {
-		m_free(ses.authstate.pubkey_info);
+	if (ses->authstate.pubkey_info) {
+		m_free(ses->authstate.pubkey_info);
 	}
 }
 
@@ -168,58 +168,58 @@
 	return DROPBEAR_FAILURE;
 }
 
-/* Parse pubkey options and set ses.authstate.pubkey_options accordingly.
+/* Parse pubkey options and set ses->authstate.pubkey_options accordingly.
  * Returns DROPBEAR_SUCCESS if key is ok for auth, DROPBEAR_FAILURE otherwise */
 int svr_add_pubkey_options(buffer *options_buf, int line_num, const char* filename) {
 	int ret = DROPBEAR_FAILURE;
 
 	TRACE(("enter addpubkeyoptions"))
 
-	ses.authstate.pubkey_options = (struct PubKeyOptions*)m_malloc(sizeof( struct PubKeyOptions ));
+	ses->authstate.pubkey_options = (struct PubKeyOptions*)m_malloc(sizeof( struct PubKeyOptions ));
 
 	buf_setpos(options_buf, 0);
 	while (options_buf->pos < options_buf->len) {
 		if (match_option(options_buf, "no-port-forwarding") == DROPBEAR_SUCCESS) {
 			dropbear_log(LOG_WARNING, "Port forwarding disabled.");
-			ses.authstate.pubkey_options->no_port_forwarding_flag = 1;
+			ses->authstate.pubkey_options->no_port_forwarding_flag = 1;
 			goto next_option;
 		}
 		if (match_option(options_buf, "no-agent-forwarding") == DROPBEAR_SUCCESS) {
 #if DROPBEAR_SVR_AGENTFWD
 			dropbear_log(LOG_WARNING, "Agent forwarding disabled.");
-			ses.authstate.pubkey_options->no_agent_forwarding_flag = 1;
+			ses->authstate.pubkey_options->no_agent_forwarding_flag = 1;
 #endif
 			goto next_option;
 		}
 		if (match_option(options_buf, "no-X11-forwarding") == DROPBEAR_SUCCESS) {
 #if DROPBEAR_X11FWD
 			dropbear_log(LOG_WARNING, "X11 forwarding disabled.");
-			ses.authstate.pubkey_options->no_x11_forwarding_flag = 1;
+			ses->authstate.pubkey_options->no_x11_forwarding_flag = 1;
 #endif
 			goto next_option;
 		}
 		if (match_option(options_buf, "no-pty") == DROPBEAR_SUCCESS) {
 			dropbear_log(LOG_WARNING, "Pty allocation disabled.");
-			ses.authstate.pubkey_options->no_pty_flag = 1;
+			ses->authstate.pubkey_options->no_pty_flag = 1;
 			goto next_option;
 		}
 		if (match_option(options_buf, "restrict") == DROPBEAR_SUCCESS) {
 			dropbear_log(LOG_WARNING, "Restrict option set");
-			ses.authstate.pubkey_options->no_port_forwarding_flag = 1;
+			ses->authstate.pubkey_options->no_port_forwarding_flag = 1;
 #if DROPBEAR_SVR_AGENTFWD
-			ses.authstate.pubkey_options->no_agent_forwarding_flag = 1;
+			ses->authstate.pubkey_options->no_agent_forwarding_flag = 1;
 #endif
 #if DROPBEAR_X11FWD
-			ses.authstate.pubkey_options->no_x11_forwarding_flag = 1;
+			ses->authstate.pubkey_options->no_x11_forwarding_flag = 1;
 #endif
-			ses.authstate.pubkey_options->no_pty_flag = 1;
+			ses->authstate.pubkey_options->no_pty_flag = 1;
 			goto next_option;
 		}
 		if (match_option(options_buf, "command=\"") == DROPBEAR_SUCCESS) {
 			int escaped = 0;
 			const unsigned char* command_start = buf_getptr(options_buf, 0);
 
-			if (ses.authstate.pubkey_options->forced_command) {
+			if (ses->authstate.pubkey_options->forced_command) {
 				/* multiple command= options */
 				goto bad_option;
 			}
@@ -228,10 +228,10 @@
 				const char c = buf_getbyte(options_buf);
 				if (!escaped && c == '"') {
 					const int command_len = buf_getptr(options_buf, 0) - command_start;
-					ses.authstate.pubkey_options->forced_command = m_malloc(command_len);
-					memcpy(ses.authstate.pubkey_options->forced_command,
+					ses->authstate.pubkey_options->forced_command = m_malloc(command_len);
+					memcpy(ses->authstate.pubkey_options->forced_command,
 							command_start, command_len-1);
-					ses.authstate.pubkey_options->forced_command[command_len-1] = '\0';
+					ses->authstate.pubkey_options->forced_command[command_len-1] = '\0';
 					goto next_option;
 				}
 				escaped = (!escaped && c == '\\');
@@ -244,8 +244,8 @@
 			int valid_option = 0;
 			const unsigned char* permitopen_start = buf_getptr(options_buf, 0);
 
-			if (!ses.authstate.pubkey_options->permit_open_destinations) {
-				ses.authstate.pubkey_options->permit_open_destinations = list_new();
+			if (!ses->authstate.pubkey_options->permit_open_destinations) {
+				ses->authstate.pubkey_options->permit_open_destinations = list_new();
 			}
 
 			while (options_buf->pos < options_buf->len) {
@@ -257,7 +257,7 @@
 					struct PermitTCPFwdEntry *entry =
 							(struct PermitTCPFwdEntry*)m_malloc(sizeof(struct PermitTCPFwdEntry));
 
-					list_append(ses.authstate.pubkey_options->permit_open_destinations, entry);
+					list_append(ses->authstate.pubkey_options->permit_open_destinations, entry);
 					spec = m_malloc(permitopen_len);
 					memcpy(spec, permitopen_start, permitopen_len - 1);
 					spec[permitopen_len - 1] = '\0';
@@ -291,14 +291,14 @@
 		if (match_option(options_buf, "no-touch-required") == DROPBEAR_SUCCESS) {
 #if DROPBEAR_SK_ECDSA || DROPBEAR_SK_ED25519
 			dropbear_log(LOG_WARNING, "No user presence check required for U2F/FIDO key.");
-			ses.authstate.pubkey_options->no_touch_required_flag = 1;
+			ses->authstate.pubkey_options->no_touch_required_flag = 1;
 #endif
 			goto next_option;
 		}
 		if (match_option(options_buf, "verify-required") == DROPBEAR_SUCCESS) {
 #if DROPBEAR_SK_ECDSA || DROPBEAR_SK_ED25519
 			dropbear_log(LOG_WARNING, "User verification required for U2F/FIDO key.");
-			ses.authstate.pubkey_options->verify_required_flag = 1;
+			ses->authstate.pubkey_options->verify_required_flag = 1;
 #endif
 			goto next_option;
 		}
diff -aur dropbear-2022.83/svr-chansession.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-chansession.c
--- dropbear-2022.83/svr-chansession.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-chansession.c	2023-08-09 16:05:01.056015960 +0600
@@ -89,14 +89,14 @@
 /* There's a particular race we have to watch out for: if the forked child
  * executes, exits, and this signal-handler is called, all before the parent
  * gets to run, then the childpids[] array won't have the pid in it. Hence we
- * use the svr_ses.lastexit struct to hold the exit, which is then compared by
+ * use the svr_ses->lastexit struct to hold the exit, which is then compared by
  * the parent when it runs. This work correctly at least in the case of a
  * single shell spawned (ie the usual case) */
 void svr_chansess_checksignal(void) {
 	int status;
 	pid_t pid;
 
-	if (!ses.channel_signal_pending) {
+	if (!ses->channel_signal_pending) {
 		return;
 	}
 
@@ -107,10 +107,10 @@
 
 		ex = NULL;
 		/* find the corresponding chansess */
-		for (i = 0; i < svr_ses.childpidsize; i++) {
-			if (svr_ses.childpids[i].pid == pid) {
+		for (i = 0; i < svr_ses->childpidsize; i++) {
+			if (svr_ses->childpids[i].pid == pid) {
 				TRACE(("found match session"));
-				ex = &svr_ses.childpids[i].chansess->exit;
+				ex = &svr_ses->childpids[i].chansess->exit;
 				break;
 			}
 		}
@@ -119,7 +119,7 @@
 		 * above. So we just store the info for the parent to deal with */
 		if (ex == NULL) {
 			TRACE(("using lastexit"));
-			ex = &svr_ses.lastexit;
+			ex = &svr_ses->lastexit;
 		}
 
 		ex->exitpid = pid;
@@ -151,7 +151,7 @@
 	while (1) {
 		/* isserver is just a random byte to write. We can't do anything
 		about an error so should just ignore it */
-		if (write(ses.signal_pipe[1], &ses.isserver, 1) == 1
+		if (write(ses->signal_pipe[1], &ses->isserver, 1) == 1
 				|| errno != EINTR) {
 			break;
 		}
@@ -189,11 +189,11 @@
 
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_REQUEST);
-	buf_putint(ses.writepayload, channel->remotechan);
-	buf_putstring(ses.writepayload, "exit-status", 11);
-	buf_putbyte(ses.writepayload, 0); /* boolean FALSE */
-	buf_putint(ses.writepayload, chansess->exit.exitstatus);
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_REQUEST);
+	buf_putint(ses->writepayload, channel->remotechan);
+	buf_putstring(ses->writepayload, "exit-status", 11);
+	buf_putbyte(ses->writepayload, 0); /* boolean FALSE */
+	buf_putint(ses->writepayload, chansess->exit.exitstatus);
 
 	encrypt_packet();
 
@@ -225,14 +225,14 @@
 		return;
 	}
 
-	buf_putbyte(ses.writepayload, SSH_MSG_CHANNEL_REQUEST);
-	buf_putint(ses.writepayload, channel->remotechan);
-	buf_putstring(ses.writepayload, "exit-signal", 11);
-	buf_putbyte(ses.writepayload, 0); /* boolean FALSE */
-	buf_putstring(ses.writepayload, signame, strlen(signame));
-	buf_putbyte(ses.writepayload, chansess->exit.exitcore);
-	buf_putstring(ses.writepayload, "", 0); /* error msg */
-	buf_putstring(ses.writepayload, "", 0); /* lang */
+	buf_putbyte(ses->writepayload, SSH_MSG_CHANNEL_REQUEST);
+	buf_putint(ses->writepayload, channel->remotechan);
+	buf_putstring(ses->writepayload, "exit-signal", 11);
+	buf_putbyte(ses->writepayload, 0); /* boolean FALSE */
+	buf_putstring(ses->writepayload, signame, strlen(signame));
+	buf_putbyte(ses->writepayload, chansess->exit.exitcore);
+	buf_putstring(ses->writepayload, "", 0); /* error msg */
+	buf_putstring(ses->writepayload, "", 0); /* lang */
 
 	encrypt_packet();
 }
@@ -284,8 +284,8 @@
 static struct logininfo* 
 chansess_login_alloc(const struct ChanSess *chansess) {
 	struct logininfo * li;
-	li = login_alloc_entry(chansess->pid, ses.authstate.username,
-			svr_ses.remotehost, chansess->tty);
+	li = login_alloc_entry(chansess->pid, ses->authstate.username,
+			svr_ses->remotehost, chansess->tty);
 	return li;
 }
 
@@ -345,13 +345,13 @@
 #endif
 
 	/* clear child pid entries */
-	for (i = 0; i < svr_ses.childpidsize; i++) {
-		if (svr_ses.childpids[i].chansess == chansess) {
-			dropbear_assert(svr_ses.childpids[i].pid > 0);
-			TRACE(("closing pid %d", svr_ses.childpids[i].pid))
+	for (i = 0; i < svr_ses->childpidsize; i++) {
+		if (svr_ses->childpids[i].chansess == chansess) {
+			dropbear_assert(svr_ses->childpids[i].pid > 0);
+			TRACE(("closing pid %d", svr_ses->childpids[i].pid))
 			TRACE(("exitpid is %d", chansess->exit.exitpid))
-			svr_ses.childpids[i].pid = -1;
-			svr_ses.childpids[i].chansess = NULL;
+			svr_ses->childpids[i].pid = -1;
+			svr_ses->childpids[i].chansess = NULL;
 		}
 	}
 				
@@ -372,8 +372,8 @@
 
 	TRACE(("enter chansessionrequest"))
 
-	type = buf_getstring(ses.payload, &typelen);
-	wantreply = buf_getbool(ses.payload);
+	type = buf_getstring(ses->payload, &typelen);
+	wantreply = buf_getbool(ses->payload);
 
 	if (typelen > MAX_NAME_LEN) {
 		TRACE(("leave chansessionrequest: type too long")) /* XXX send error?*/
@@ -437,7 +437,7 @@
 		return DROPBEAR_FAILURE;
 	}
 
-	signame = buf_getstring(ses.payload, NULL);
+	signame = buf_getstring(ses->payload, NULL);
 
 	for (i = 0; signames[i].name != NULL; i++) {
 		if (strcmp(signames[i].name, signame) == 0) {
@@ -473,10 +473,10 @@
 		return DROPBEAR_FAILURE;
 	}
 			
-	termc = buf_getint(ses.payload);
-	termr = buf_getint(ses.payload);
-	termw = buf_getint(ses.payload);
-	termh = buf_getint(ses.payload);
+	termc = buf_getint(ses->payload);
+	termr = buf_getint(ses->payload);
+	termw = buf_getint(ses->payload);
+	termh = buf_getint(ses->payload);
 	
 	pty_change_window_size(chansess->master, termr, termc, termw, termh);
 
@@ -500,10 +500,10 @@
 		return;
 	}
 
-	len = buf_getint(ses.payload);
+	len = buf_getint(ses->payload);
 	TRACE(("term mode str %d p->l %d p->p %d", 
-				len, ses.payload->len , ses.payload->pos));
-	if (len != ses.payload->len - ses.payload->pos) {
+				len, ses->payload->len , ses->payload->pos));
+	if (len != ses->payload->len - ses->payload->pos) {
 		dropbear_exit("Bad term mode string");
 	}
 
@@ -512,11 +512,11 @@
 		return;
 	}
 
-	while (((opcode = buf_getbyte(ses.payload)) != 0x00) && opcode <= 159) {
+	while (((opcode = buf_getbyte(ses->payload)) != 0x00) && opcode <= 159) {
 
 		/* must be before checking type, so that value is consumed even if
 		 * we don't use it */
-		value = buf_getint(ses.payload);
+		value = buf_getint(ses->payload);
 
 		/* handle types of code */
 		if (opcode > MAX_TERMCODE) {
@@ -590,7 +590,7 @@
 		return DROPBEAR_FAILURE;
 	}
 
-	chansess->term = buf_getstring(ses.payload, &termlen);
+	chansess->term = buf_getstring(ses->payload, &termlen);
 	if (termlen > MAX_TERM_LEN) {
 		/* TODO send disconnect ? */
 		TRACE(("leave sessionpty: term len too long"))
@@ -611,7 +611,7 @@
 		dropbear_exit("Out of memory"); /* TODO disconnect */
 	}
 
-	pw = getpwnam(ses.authstate.pw_name);
+	pw = getpwnam(ses->authstate.pw_name);
 	if (!pw)
 		dropbear_exit("getpwnam failed after succeeding previously");
 	pty_setowner(pw, chansess->tty);
@@ -630,7 +630,7 @@
 static void make_connection_string(struct ChanSess *chansess) {
 	char *local_ip, *local_port, *remote_ip, *remote_port;
 	size_t len;
-	get_socket_address(ses.sock_in, &local_ip, &local_port, &remote_ip, &remote_port, 0);
+	get_socket_address(ses->sock_in, &local_ip, &local_port, &remote_ip, &remote_port, 0);
 
 	/* "remoteip remoteport localip localport" */
 	len = strlen(local_ip) + strlen(remote_ip) + 20;
@@ -673,7 +673,7 @@
 	if (iscmd) {
 		/* "exec" */
 		if (chansess->cmd == NULL) {
-			chansess->cmd = buf_getstring(ses.payload, &cmdlen);
+			chansess->cmd = buf_getstring(ses->payload, &cmdlen);
 
 			if (cmdlen > MAX_CMD_LEN) {
 				m_free(chansess->cmd);
@@ -701,13 +701,13 @@
 	
 
 	/* take global command into account */
-	if (svr_opts.forced_command) {
+	if (svr_opts->forced_command) {
 		if (chansess->cmd) {
 			chansess->original_command = chansess->cmd;
 		} else {
 			chansess->original_command = m_strdup("");
 		}
-		chansess->cmd = m_strdup(svr_opts.forced_command);
+		chansess->cmd = m_strdup(svr_opts->forced_command);
 	} else {
 		/* take public key option 'command' into account */
 		svr_pubkey_set_forced_command(chansess);
@@ -717,10 +717,10 @@
 #if LOG_COMMANDS
 	if (chansess->cmd) {
 		dropbear_log(LOG_INFO, "User %s executing '%s'", 
-						ses.authstate.pw_name, chansess->cmd);
+						ses->authstate.pw_name, chansess->cmd);
 	} else {
 		dropbear_log(LOG_INFO, "User %s executing login shell", 
-						ses.authstate.pw_name);
+						ses->authstate.pw_name);
 	}
 #endif
 
@@ -769,24 +769,24 @@
 		return ret;
 	}
 
-	ses.maxfd = MAX(ses.maxfd, channel->writefd);
-	ses.maxfd = MAX(ses.maxfd, channel->readfd);
-	ses.maxfd = MAX(ses.maxfd, channel->errfd);
+	ses->maxfd = MAX(ses->maxfd, channel->writefd);
+	ses->maxfd = MAX(ses->maxfd, channel->readfd);
+	ses->maxfd = MAX(ses->maxfd, channel->errfd);
 	channel->bidir_fd = 0;
 
 	addchildpid(chansess, chansess->pid);
 
-	if (svr_ses.lastexit.exitpid != -1) {
+	if (svr_ses->lastexit.exitpid != -1) {
 		unsigned int i;
-		TRACE(("parent side: lastexitpid is %d", svr_ses.lastexit.exitpid))
+		TRACE(("parent side: lastexitpid is %d", svr_ses->lastexit.exitpid))
 		/* The child probably exited and the signal handler triggered
 		 * possibly before we got around to adding the childpid. So we fill
 		 * out its data manually */
-		for (i = 0; i < svr_ses.childpidsize; i++) {
-			if (svr_ses.childpids[i].pid == svr_ses.lastexit.exitpid) {
+		for (i = 0; i < svr_ses->childpidsize; i++) {
+			if (svr_ses->childpids[i].pid == svr_ses->lastexit.exitpid) {
 				TRACE(("found match for lastexitpid"))
-				svr_ses.childpids[i].chansess->exit = svr_ses.lastexit;
-				svr_ses.lastexit.exitpid = -1;
+				svr_ses->childpids[i].chansess->exit = svr_ses->lastexit;
+				svr_ses->lastexit.exitpid = -1;
 				break;
 			}
 		}
@@ -863,14 +863,14 @@
 		close(chansess->slave);
 
 #if DO_MOTD
-		if (svr_opts.domotd && !chansess->cmd) {
+		if (svr_opts->domotd && !chansess->cmd) {
 			/* don't show the motd if ~/.hushlogin exists */
 
 			/* 12 == strlen("/.hushlogin\0") */
-			len = strlen(ses.authstate.pw_dir) + 12; 
+			len = strlen(ses->authstate.pw_dir) + 12; 
 
 			hushpath = m_malloc(len);
-			snprintf(hushpath, len, "%s/.hushlogin", ses.authstate.pw_dir);
+			snprintf(hushpath, len, "%s/.hushlogin", ses->authstate.pw_dir);
 
 			if (stat(hushpath, &sb) < 0) {
 				char *expand_path = NULL;
@@ -909,7 +909,7 @@
 		channel->writefd = chansess->master;
 		channel->readfd = chansess->master;
 		/* don't need to set stderr here */
-		ses.maxfd = MAX(ses.maxfd, chansess->master);
+		ses->maxfd = MAX(ses->maxfd, chansess->master);
 		channel->bidir_fd = 1;
 
 		setnonblocking(chansess->master);
@@ -924,22 +924,22 @@
 static void addchildpid(struct ChanSess *chansess, pid_t pid) {
 
 	unsigned int i;
-	for (i = 0; i < svr_ses.childpidsize; i++) {
-		if (svr_ses.childpids[i].pid == -1) {
+	for (i = 0; i < svr_ses->childpidsize; i++) {
+		if (svr_ses->childpids[i].pid == -1) {
 			break;
 		}
 	}
 
 	/* need to increase size */
-	if (i == svr_ses.childpidsize) {
-		svr_ses.childpids = (struct ChildPid*)m_realloc(svr_ses.childpids,
-				sizeof(struct ChildPid) * (svr_ses.childpidsize+1));
-		svr_ses.childpidsize++;
+	if (i == svr_ses->childpidsize) {
+		svr_ses->childpids = (struct ChildPid*)m_realloc(svr_ses->childpids,
+				sizeof(struct ChildPid) * (svr_ses->childpidsize+1));
+		svr_ses->childpidsize++;
 	}
 	
 	TRACE(("addchildpid %d pid %d for chansess %p", i, pid, chansess))
-	svr_ses.childpids[i].pid = pid;
-	svr_ses.childpids[i].chansess = chansess;
+	svr_ses->childpids[i].pid = pid;
+	svr_ses->childpids[i].chansess = chansess;
 
 }
 
@@ -958,8 +958,8 @@
 	 * hostkey. can't think of a workaround to clear it */
 #if !DROPBEAR_VFORK
 	/* wipe the hostkey */
-	sign_key_free(svr_opts.hostkey);
-	svr_opts.hostkey = NULL;
+	sign_key_free(svr_opts->hostkey);
+	svr_opts->hostkey = NULL;
 
 	/* overwrite the prng state */
 	seedrandom();
@@ -968,7 +968,7 @@
 	/* clear environment if -e was not set */
 	/* if we're debugging using valgrind etc, we need to keep the LD_PRELOAD
 	 * etc. This is hazardous, so should only be used for debugging. */
-	if ( !svr_opts.pass_on_env) {
+	if ( !svr_opts->pass_on_env) {
 #ifndef DEBUG_VALGRIND
 #ifdef HAVE_CLEARENV
 		clearenv();
@@ -985,12 +985,12 @@
 	/* We can only change uid/gid as root ... */
 	if (getuid() == 0) {
 
-		if ((setgid(ses.authstate.pw_gid) < 0) ||
-			(initgroups(ses.authstate.pw_name, 
-						ses.authstate.pw_gid) < 0)) {
+		if ((setgid(ses->authstate.pw_gid) < 0) ||
+			(initgroups(ses->authstate.pw_name, 
+						ses->authstate.pw_gid) < 0)) {
 			dropbear_exit("Error changing user group");
 		}
-		if (setuid(ses.authstate.pw_uid) < 0) {
+		if (setuid(ses->authstate.pw_uid) < 0) {
 			dropbear_exit("Error changing user");
 		}
 	} else {
@@ -1001,16 +1001,16 @@
 		 * usernames with the same uid, but differing groups, then the
 		 * differing groups won't be set (as with initgroups()). The solution
 		 * is for the sysadmin not to give out the UID twice */
-		if (getuid() != ses.authstate.pw_uid) {
+		if (getuid() != ses->authstate.pw_uid) {
 			dropbear_exit("Couldn't	change user as non-root");
 		}
 	}
 #endif
 
 	/* set env vars */
-	addnewvar("USER", ses.authstate.pw_name);
-	addnewvar("LOGNAME", ses.authstate.pw_name);
-	addnewvar("HOME", ses.authstate.pw_dir);
+	addnewvar("USER", ses->authstate.pw_name);
+	addnewvar("LOGNAME", ses->authstate.pw_name);
+	addnewvar("HOME", ses->authstate.pw_dir);
 	addnewvar("SHELL", get_user_shell());
 	if (getuid() == 0) {
 		addnewvar("PATH", DEFAULT_ROOT_PATH);
@@ -1041,18 +1041,18 @@
 		addnewvar("SSH_ORIGINAL_COMMAND", chansess->original_command);
 	}
 #if DROPBEAR_SVR_PUBKEY_OPTIONS_BUILT
-	if (ses.authstate.pubkey_info != NULL) {
-		addnewvar("SSH_PUBKEYINFO", ses.authstate.pubkey_info);
+	if (ses->authstate.pubkey_info != NULL) {
+		addnewvar("SSH_PUBKEYINFO", ses->authstate.pubkey_info);
 	}
 #endif
 
 	/* change directory */
-	if (chdir(ses.authstate.pw_dir) < 0) {
+	if (chdir(ses->authstate.pw_dir) < 0) {
 		int e = errno;
 		if (chdir("/") < 0) {
 			dropbear_exit("chdir(\"/\") failed");
 		}
-		fprintf(stderr, "Failed chdir '%s': %s\n", ses.authstate.pw_dir, strerror(e));
+		fprintf(stderr, "Failed chdir '%s': %s\n", ses->authstate.pw_dir, strerror(e));
 	}
 
 
@@ -1066,7 +1066,7 @@
 #endif
 
 	usershell = m_strdup(get_user_shell());
-	run_shell_command(chansess->cmd, ses.maxfd, usershell);
+	run_shell_command(chansess->cmd, ses->maxfd, usershell);
 
 	/* only reached on error */
 	dropbear_exit("Child failed");
@@ -1079,11 +1079,11 @@
 	struct sigaction sa_chld;
 
 	/* single child process intially */
-	svr_ses.childpids = (struct ChildPid*)m_malloc(sizeof(struct ChildPid));
-	svr_ses.childpids[0].pid = -1; /* unused */
-	svr_ses.childpids[0].chansess = NULL;
-	svr_ses.childpidsize = 1;
-	svr_ses.lastexit.exitpid = -1; /* Nothing has exited yet */
+	svr_ses->childpids = (struct ChildPid*)m_malloc(sizeof(struct ChildPid));
+	svr_ses->childpids[0].pid = -1; /* unused */
+	svr_ses->childpids[0].chansess = NULL;
+	svr_ses->childpidsize = 1;
+	svr_ses->lastexit.exitpid = -1; /* Nothing has exited yet */
 	sa_chld.sa_handler = sesssigchild_handler;
 	sa_chld.sa_flags = SA_NOCLDSTOP;
 	sigemptyset(&sa_chld.sa_mask);
diff -aur dropbear-2022.83/svr-kex.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-kex.c
--- dropbear-2022.83/svr-kex.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-kex.c	2023-08-09 16:05:01.056015960 +0600
@@ -51,15 +51,15 @@
 	buffer *ecdh_qs = NULL;
 
 	TRACE(("enter recv_msg_kexdh_init"))
-	if (!ses.kexstate.recvkexinit) {
+	if (!ses->kexstate.recvkexinit) {
 		dropbear_exit("Premature kexdh_init message received");
 	}
 
-	switch (ses.newkeys->algo_kex->mode) {
+	switch (ses->newkeys->algo_kex->mode) {
 #if DROPBEAR_NORMAL_DH
 		case DROPBEAR_KEX_NORMAL_DH:
 			m_mp_init(&dh_e);
-			if (buf_getmpint(ses.payload, &dh_e) != DROPBEAR_SUCCESS) {
+			if (buf_getmpint(ses->payload, &dh_e) != DROPBEAR_SUCCESS) {
 				dropbear_exit("Bad kex value");
 			}
 			break;
@@ -71,11 +71,11 @@
 		case DROPBEAR_KEX_CURVE25519:
 #endif
 #if DROPBEAR_ECDH || DROPBEAR_CURVE25519
-			ecdh_qs = buf_getstringbuf(ses.payload);
+			ecdh_qs = buf_getstringbuf(ses->payload);
 			break;
 #endif
 	}
-	if (ses.payload->pos != ses.payload->len) {
+	if (ses->payload->pos != ses->payload->len) {
 		dropbear_exit("Bad kex value");
 	}
 
@@ -91,12 +91,12 @@
 
 #if DROPBEAR_EXT_INFO
 	/* Only send it following the first newkeys */
-	if (!ses.kexstate.donesecondkex && ses.allow_ext_info) {
+	if (!ses->kexstate.donesecondkex && ses->allow_ext_info) {
 		send_msg_ext_info();
 	}
 #endif
 
-	ses.requirenext = SSH_MSG_NEWKEYS;
+	ses->requirenext = SSH_MSG_NEWKEYS;
 	TRACE(("leave recv_msg_kexdh_init"))
 }
 
@@ -107,8 +107,8 @@
 
 	const char* fn = NULL;
 	char *expand_fn = NULL;
-	enum signkey_type type = ses.newkeys->algo_hostkey;
-	void **hostkey = signkey_key_ptr(svr_opts.hostkey, type);
+	enum signkey_type type = ses->newkeys->algo_hostkey;
+	void **hostkey = signkey_key_ptr(svr_opts->hostkey, type);
 	int ret = DROPBEAR_FAILURE;
 
 	if (hostkey && *hostkey) {
@@ -145,7 +145,7 @@
 
 	expand_fn = expand_homedir_path(fn);
 
-	ret = readhostkey(expand_fn, svr_opts.hostkey, &type);
+	ret = readhostkey(expand_fn, svr_opts->hostkey, &type);
 	if (ret == DROPBEAR_SUCCESS) {
 		goto out;
 	}
@@ -155,13 +155,13 @@
 	}
 	
 	/* Read what we just generated (or another process raced us) */
-	ret = readhostkey(expand_fn, svr_opts.hostkey, &type);
+	ret = readhostkey(expand_fn, svr_opts->hostkey, &type);
 
 	if (ret == DROPBEAR_SUCCESS) {
 		char *fp = NULL;
 		unsigned int len;
 		buffer *key_buf = buf_new(MAX_PUBKEY_SIZE);
-		buf_put_pub_key(key_buf, svr_opts.hostkey, type);
+		buf_put_pub_key(key_buf, svr_opts->hostkey, type);
 		buf_setpos(key_buf, 4);
 		len = key_buf->len - key_buf->pos;
 		fp = sign_key_fingerprint(buf_getptr(key_buf, len), len);
@@ -193,7 +193,7 @@
 	CHECKCLEARTOWRITE();
 
 #if DROPBEAR_DELAY_HOSTKEY
-	if (svr_opts.delay_hostkey)
+	if (svr_opts->delay_hostkey)
 	{
 		svr_ensure_hostkey();
 	}
@@ -206,19 +206,19 @@
 	}
 #endif
 
-	buf_putbyte(ses.writepayload, SSH_MSG_KEXDH_REPLY);
-	buf_put_pub_key(ses.writepayload, svr_opts.hostkey,
-			ses.newkeys->algo_hostkey);
+	buf_putbyte(ses->writepayload, SSH_MSG_KEXDH_REPLY);
+	buf_put_pub_key(ses->writepayload, svr_opts->hostkey,
+			ses->newkeys->algo_hostkey);
 
-	switch (ses.newkeys->algo_kex->mode) {
+	switch (ses->newkeys->algo_kex->mode) {
 #if DROPBEAR_NORMAL_DH
 		case DROPBEAR_KEX_NORMAL_DH:
 			{
 			struct kex_dh_param * dh_param = gen_kexdh_param();
-			kexdh_comb_key(dh_param, dh_e, svr_opts.hostkey);
+			kexdh_comb_key(dh_param, dh_e, svr_opts->hostkey);
 
 			/* put f */
-			buf_putmpint(ses.writepayload, &dh_param->pub);
+			buf_putmpint(ses->writepayload, &dh_param->pub);
 			free_kexdh_param(dh_param);
 			}
 			break;
@@ -227,9 +227,9 @@
 		case DROPBEAR_KEX_ECDH:
 			{
 			struct kex_ecdh_param *ecdh_param = gen_kexecdh_param();
-			kexecdh_comb_key(ecdh_param, ecdh_qs, svr_opts.hostkey);
+			kexecdh_comb_key(ecdh_param, ecdh_qs, svr_opts->hostkey);
 
-			buf_put_ecc_raw_pubkey_string(ses.writepayload, &ecdh_param->key);
+			buf_put_ecc_raw_pubkey_string(ses->writepayload, &ecdh_param->key);
 			free_kexecdh_param(ecdh_param);
 			}
 			break;
@@ -238,9 +238,9 @@
 		case DROPBEAR_KEX_CURVE25519:
 			{
 			struct kex_curve25519_param *param = gen_kexcurve25519_param();
-			kexcurve25519_comb_key(param, ecdh_qs, svr_opts.hostkey);
+			kexcurve25519_comb_key(param, ecdh_qs, svr_opts->hostkey);
 
-			buf_putstring(ses.writepayload, param->pub, CURVE25519_LEN);
+			buf_putstring(ses->writepayload, param->pub, CURVE25519_LEN);
 			free_kexcurve25519_param(param);
 			}
 			break;
@@ -248,8 +248,8 @@
 	}
 
 	/* calc the signature */
-	buf_put_sign(ses.writepayload, svr_opts.hostkey, 
-			ses.newkeys->algo_signature, ses.hash);
+	buf_put_sign(ses->writepayload, svr_opts->hostkey, 
+			ses->newkeys->algo_signature, ses->hash);
 
 	/* the SSH_MSG_KEXDH_REPLY is done */
 	encrypt_packet();
@@ -262,12 +262,12 @@
 static void send_msg_ext_info(void) {
 	TRACE(("enter send_msg_ext_info"))
 
-	buf_putbyte(ses.writepayload, SSH_MSG_EXT_INFO);
+	buf_putbyte(ses->writepayload, SSH_MSG_EXT_INFO);
 	/* nr-extensions */
-	buf_putint(ses.writepayload, 1);
+	buf_putint(ses->writepayload, 1);
 
-	buf_putstring(ses.writepayload, SSH_SERVER_SIG_ALGS, strlen(SSH_SERVER_SIG_ALGS));
-	buf_put_algolist_all(ses.writepayload, sigalgs, 1);
+	buf_putstring(ses->writepayload, SSH_SERVER_SIG_ALGS, strlen(SSH_SERVER_SIG_ALGS));
+	buf_put_algolist_all(ses->writepayload, sigalgs, 1);
 	
 	encrypt_packet();
 
diff -aur dropbear-2022.83/svr-main.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-main.c
--- dropbear-2022.83/svr-main.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-main.c	2023-08-09 16:05:01.056015960 +0600
@@ -22,6 +22,7 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE. */
 
+#include "embox_drpbr.h"
 #include "includes.h"
 #include "dbutil.h"
 #include "session.h"
@@ -30,6 +31,7 @@
 #include "runopts.h"
 #include "dbrandom.h"
 #include "crypto_desc.h"
+#include <string.h>
 
 static size_t listensockets(int *sock, size_t sockcount, int *maxfd);
 static void sigchld_handler(int dummy);
@@ -59,19 +61,31 @@
 		dropbear_exit("Bad argc");
 	}
 
+    sched_lock();
+
+    ses = malloc(sizeof(struct sshsession));
+    memset(ses, 0, sizeof(struct sshsession));
+    svr_ses = malloc(sizeof(struct serversession));
+    memset(svr_ses, 0, sizeof(struct serversession));
+    svr_opts = malloc(sizeof(struct svr_runopts));
+    memset(svr_opts, 0, sizeof(struct svr_runopts));
+    opts = malloc(sizeof(struct runopts));
+    memset(opts, 0, sizeof(struct runopts));
+    
+    dropbear_embox_store_ses();
 	/* get commandline options */
 	svr_getopts(argc, argv);
 
 #if INETD_MODE
 	/* service program mode */
-	if (svr_opts.inetdmode) {
+	if (svr_opts->inetdmode) {
 		main_inetd();
 		/* notreached */
 	}
 #endif
 
 #if DROPBEAR_DO_REEXEC
-	if (svr_opts.reexec_childpipe >= 0) {
+	if (svr_opts->reexec_childpipe >= 0) {
 #ifdef PR_SET_NAME
 		/* Fix the "Name:" in /proc/pid/status, otherwise it's
 		a FD number from fexecve.
@@ -102,7 +116,7 @@
 
 	seedrandom();
 
-	if (svr_opts.reexec_childpipe < 0) {
+	if (svr_opts->reexec_childpipe < 0) {
 		/* In case our inetd was lax in logging source addresses */
 		get_socket_address(0, NULL, NULL, &host, &port, 0);
 			dropbear_log(LOG_INFO, "Child connection from %s:%s", host, port);
@@ -116,7 +130,7 @@
 	}
 
 	/* -1 for childpipe in the inetd case is discarded */
-	svr_session(0, svr_opts.reexec_childpipe);
+	svr_session(0, svr_opts->reexec_childpipe);
 
 	/* notreached */
 }
@@ -131,7 +145,9 @@
 	int listensocks[MAX_LISTEN_ADDR];
 	size_t listensockcount = 0;
 	FILE *pidfile = NULL;
+#ifndef DROPBEAR_EMBOX_BUILD
 	int execfd = -1;
+#endif
 
 	int childpipes[MAX_UNAUTH_CLIENTS];
 	char * preauth_addrs[MAX_UNAUTH_CLIENTS];
@@ -165,7 +181,7 @@
 		FD_SET(listensocks[i], &fds);
 	}
 
-#if DROPBEAR_DO_REEXEC
+#if DROPBEAR_DO_REEXEC && !DROPBEAR_EMBOX_BUILD
 	if (multipath) {
 		execfd = open(multipath, O_CLOEXEC|O_RDONLY);
 	} else {
@@ -178,10 +194,10 @@
 #endif
 
 	/* fork */
-	if (svr_opts.forkbg) {
+	if (svr_opts->forkbg) {
 		int closefds = 0;
 #if !DEBUG_TRACE
-		if (!opts.usingsyslog) {
+		if (!opts->usingsyslog) {
 			closefds = 1;
 		}
 #endif
@@ -191,14 +207,14 @@
 	}
 
 	/* should be done after syslog is working */
-	if (svr_opts.forkbg) {
+	if (svr_opts->forkbg) {
 		dropbear_log(LOG_INFO, "Running in background");
 	} else {
 		dropbear_log(LOG_INFO, "Not backgrounding");
 	}
 
 	/* create a PID file so that we can be killed easily */
-	pidfile = fopen(svr_opts.pidfile, "w");
+	pidfile = fopen(svr_opts->pidfile, "w");
 	if (pidfile) {
 		fprintf(pidfile, "%d\n", getpid());
 		fclose(pidfile);
@@ -222,10 +238,19 @@
 			}
 		}
 
+#ifdef DROPBEAR_EMBOX_BUILD
+        /*We want to be sure in embox this process works only one instance at
+         * a time. This is why we use sched_lock/sched_unloc */
+        sched_unlock();
+#endif
 		val = select(maxsock+1, &fds, NULL, NULL, NULL);
+#ifdef DROPBEAR_EMBOX_BUILD
+        sched_lock();
+        dropbear_embox_switch_desc();
+#endif
 
-		if (ses.exitflag) {
-			unlink(svr_opts.pidfile);
+		if (ses->exitflag) {
+			unlink(svr_opts->pidfile);
 			dropbear_exit("Terminated by signal");
 		}
 
@@ -304,9 +329,13 @@
 
 #if DEBUG_NOFORK
 			fork_ret = 0;
-#else
+#else /* DEBUG_NOFORK*/
+#ifndef DROPBEAR_EMBOX_BUILD
 			fork_ret = fork();
-#endif
+#else /*DROPBEAR_EMBOX_BUILD*/
+            fork_ret = vfork();
+#endif  /*DROPBEAR_EMBOX_BUILD*/
+#endif /*DEBUG_NOFORK*/
 			if (fork_ret < 0) {
 				dropbear_log(LOG_WARNING, "Error forking: %s", strerror(errno));
 				goto out;
@@ -324,12 +353,12 @@
 
 			} else {
 
+#ifndef DROPBEAR_EMBOX_BUILD
 				/* child */
 				getaddrstring(&remoteaddr, NULL, &remote_port, 0);
 				dropbear_log(LOG_INFO, "Child connection from %s:%s", remote_host, remote_port);
 				m_free(remote_host);
 				m_free(remote_port);
-
 #if !DEBUG_NOFORK
 				if (setsid() < 0) {
 					dropbear_exit("setsid: %s", strerror(errno));
@@ -343,20 +372,23 @@
 
 				m_close(childpipe[0]);
 
-				if (execfd >= 0) {
+				if (execfd >= 0)
+#endif /*DROPBEAR_EMBOX_BUILD*/
+                {
 #if DROPBEAR_DO_REEXEC
 					/* Add "-2 childpipe[1]" to the args and re-execute ourself. */
 					char **new_argv = m_malloc(sizeof(char*) * (argc+4));
 					char buf[10];
 					int pos0 = 0, new_argc = argc+2;
 
+#ifndef DROPBEAR_EMBOX_BUILD
 					/* We need to specially handle "dropbearmulti dropbear". */
 					if (multipath) {
 						new_argv[0] = (char*)multipath;
 						pos0 = 1;
 						new_argc++;
 					}
-
+#endif /*DROPBEAR_EMBOX_BUILD*/
 					memcpy(&new_argv[pos0], argv, sizeof(char*) * argc);
 					new_argv[new_argc-2] = "-2";
 					snprintf(buf, sizeof(buf), "%d", childpipe[1]);
@@ -370,7 +402,11 @@
 						TRACE(("cloexec for childsock %d failed: %s", childsock, strerror(errno)))
 					}
 					/* Re-execute ourself */
+#ifndef DROPBEAR_EMBOX_BUILD
 					fexecve(execfd, new_argv, environ);
+#else
+					execve("dropbear", new_argv, environ);
+#endif  /*DROPBEAR_EMBOX_BUILD*/
 					/* Not reached on success */
 
 					/* Fall back on plain fork otherwise.
@@ -428,7 +464,7 @@
 /* catch ctrl-c or sigterm */
 static void sigintterm_handler(int UNUSED(unused)) {
 
-	ses.exitflag = 1;
+	ses->exitflag = 1;
 }
 
 /* Things used by inetd and non-inetd modes */
@@ -436,7 +472,7 @@
 
 	struct sigaction sa_chld;
 #ifndef DISABLE_SYSLOG
-	if (opts.usingsyslog) {
+	if (opts->usingsyslog) {
 		startsyslog(PROGNAME);
 	}
 #endif
@@ -476,19 +512,19 @@
 	size_t sockpos = 0;
 	int nsock;
 
-	TRACE(("listensockets: %d to try", svr_opts.portcount))
+	TRACE(("listensockets: %d to try", svr_opts->portcount))
 
-	for (i = 0; i < svr_opts.portcount; i++) {
+	for (i = 0; i < svr_opts->portcount; i++) {
 
-		TRACE(("listening on '%s:%s'", svr_opts.addresses[i], svr_opts.ports[i]))
+		TRACE(("listening on '%s:%s'", svr_opts->addresses[i], svr_opts->ports[i]))
 
-		nsock = dropbear_listen(svr_opts.addresses[i], svr_opts.ports[i], &socks[sockpos], 
+		nsock = dropbear_listen(svr_opts->addresses[i], svr_opts->ports[i], &socks[sockpos], 
 				sockcount - sockpos,
 				&errstring, maxfd);
 
 		if (nsock < 0) {
 			dropbear_log(LOG_WARNING, "Failed listening on '%s': %s", 
-							svr_opts.ports[i], errstring);
+							svr_opts->ports[i], errstring);
 			m_free(errstring);
 			continue;
 		}
diff -aur dropbear-2022.83/svr-runopts.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-runopts.c
--- dropbear-2022.83/svr-runopts.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-runopts.c	2023-08-09 16:05:01.056015960 +0600
@@ -32,7 +32,7 @@
 
 #include <grp.h>
 
-svr_runopts svr_opts; /* GLOBAL */
+svr_runopts *svr_opts; /* GLOBAL */
 
 static void printhelp(const char * progname);
 static void addportandaddress(const char* spec);
@@ -149,60 +149,60 @@
 
 
 	/* see printhelp() for options */
-	svr_opts.bannerfile = NULL;
-	svr_opts.banner = NULL;
-	svr_opts.forced_command = NULL;
-	svr_opts.forkbg = 1;
-	svr_opts.norootlogin = 0;
+	svr_opts->bannerfile = NULL;
+	svr_opts->banner = NULL;
+	svr_opts->forced_command = NULL;
+	svr_opts->forkbg = 1;
+	svr_opts->norootlogin = 0;
 #ifdef HAVE_GETGROUPLIST
-	svr_opts.restrict_group = NULL;
-	svr_opts.restrict_group_gid = 0;
+	svr_opts->restrict_group = NULL;
+	svr_opts->restrict_group_gid = 0;
 #endif
-	svr_opts.noauthpass = 0;
-	svr_opts.norootpass = 0;
-	svr_opts.allowblankpass = 0;
-	svr_opts.multiauthmethod = 0;
-	svr_opts.maxauthtries = MAX_AUTH_TRIES;
-	svr_opts.inetdmode = 0;
-	svr_opts.portcount = 0;
-	svr_opts.hostkey = NULL;
-	svr_opts.delay_hostkey = 0;
-	svr_opts.pidfile = expand_homedir_path(DROPBEAR_PIDFILE);
+	svr_opts->noauthpass = 0;
+	svr_opts->norootpass = 0;
+	svr_opts->allowblankpass = 0;
+	svr_opts->multiauthmethod = 0;
+	svr_opts->maxauthtries = MAX_AUTH_TRIES;
+	svr_opts->inetdmode = 0;
+	svr_opts->portcount = 0;
+	svr_opts->hostkey = NULL;
+	svr_opts->delay_hostkey = 0;
+	svr_opts->pidfile = expand_homedir_path(DROPBEAR_PIDFILE);
 #if DROPBEAR_SVR_LOCALTCPFWD
-	svr_opts.nolocaltcp = 0;
+	svr_opts->nolocaltcp = 0;
 #endif
 #if DROPBEAR_SVR_REMOTETCPFWD
-	svr_opts.noremotetcp = 0;
+	svr_opts->noremotetcp = 0;
 #endif
 #if DROPBEAR_PLUGIN
-        svr_opts.pubkey_plugin = NULL;
-        svr_opts.pubkey_plugin_options = NULL;
+        svr_opts->pubkey_plugin = NULL;
+        svr_opts->pubkey_plugin_options = NULL;
 #endif
-	svr_opts.pass_on_env = 0;
-	svr_opts.reexec_childpipe = -1;
+	svr_opts->pass_on_env = 0;
+	svr_opts->reexec_childpipe = -1;
 
 #ifndef DISABLE_ZLIB
-	opts.compress_mode = DROPBEAR_COMPRESS_DELAYED;
+	opts->compress_mode = DROPBEAR_COMPRESS_DELAYED;
 #endif 
 
 	/* not yet
-	opts.ipv4 = 1;
-	opts.ipv6 = 1;
+	opts->ipv4 = 1;
+	opts->ipv6 = 1;
 	*/
 #if DO_MOTD
-	svr_opts.domotd = 1;
+	svr_opts->domotd = 1;
 #endif
 #ifndef DISABLE_SYSLOG
-	opts.usingsyslog = 1;
+	opts->usingsyslog = 1;
 #endif
-	opts.recv_window = DEFAULT_RECV_WINDOW;
-	opts.keepalive_secs = DEFAULT_KEEPALIVE;
-	opts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;
+	opts->recv_window = DEFAULT_RECV_WINDOW;
+	opts->keepalive_secs = DEFAULT_KEEPALIVE;
+	opts->idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;
 	
 #if DROPBEAR_SVR_REMOTETCPFWD
-	opts.listen_fwd_all = 0;
+	opts->listen_fwd_all = 0;
 #endif
-	opts.disable_ip_tos = 0;
+	opts->disable_ip_tos = 0;
 
 	for (i = 1; i < (unsigned int)argc; i++) {
 		if (argv[i][0] != '-' || argv[i][1] == '\0')
@@ -211,46 +211,46 @@
 		for (j = 1; (c = argv[i][j]) != '\0' && !next && !nextisport; j++) {
 			switch (c) {
 				case 'b':
-					next = &svr_opts.bannerfile;
+					next = &svr_opts->bannerfile;
 					break;
 				case 'c':
-					next = &svr_opts.forced_command;
+					next = &svr_opts->forced_command;
 					break;
 				case 'd':
 				case 'r':
 					next = &keyfile;
 					break;
 				case 'R':
-					svr_opts.delay_hostkey = 1;
+					svr_opts->delay_hostkey = 1;
 					break;
 				case 'F':
-					svr_opts.forkbg = 0;
+					svr_opts->forkbg = 0;
 					break;
 #ifndef DISABLE_SYSLOG
 				case 'E':
-					opts.usingsyslog = 0;
+					opts->usingsyslog = 0;
 					break;
 #endif
 				case 'e':
-					svr_opts.pass_on_env = 1;
+					svr_opts->pass_on_env = 1;
 					break;
 
 #if DROPBEAR_SVR_LOCALTCPFWD
 				case 'j':
-					svr_opts.nolocaltcp = 1;
+					svr_opts->nolocaltcp = 1;
 					break;
 #endif
 #if DROPBEAR_SVR_REMOTETCPFWD
 				case 'k':
-					svr_opts.noremotetcp = 1;
+					svr_opts->noremotetcp = 1;
 					break;
 				case 'a':
-					opts.listen_fwd_all = 1;
+					opts->listen_fwd_all = 1;
 					break;
 #endif
 #if INETD_MODE
 				case 'i':
-					svr_opts.inetdmode = 1;
+					svr_opts->inetdmode = 1;
 					break;
 #endif
 #if DROPBEAR_DO_REEXEC && NON_INETD_MODE
@@ -263,20 +263,20 @@
 					nextisport = 1;
 					break;
 				case 'P':
-					next = &svr_opts.pidfile;
+					next = &svr_opts->pidfile;
 					break;
 #if DO_MOTD
 				/* motd is displayed by default, -m turns it off */
 				case 'm':
-					svr_opts.domotd = 0;
+					svr_opts->domotd = 0;
 					break;
 #endif
 				case 'w':
-					svr_opts.norootlogin = 1;
+					svr_opts->norootlogin = 1;
 					break;
 #ifdef HAVE_GETGROUPLIST
 				case 'G':
-					next = &svr_opts.restrict_group;
+					next = &svr_opts->restrict_group;
 					break;
 #endif
 				case 'W':
@@ -293,16 +293,16 @@
 					break;
 #if DROPBEAR_SVR_PASSWORD_AUTH || DROPBEAR_SVR_PAM_AUTH
 				case 's':
-					svr_opts.noauthpass = 1;
+					svr_opts->noauthpass = 1;
 					break;
 				case 'g':
-					svr_opts.norootpass = 1;
+					svr_opts->norootpass = 1;
 					break;
 				case 'B':
-					svr_opts.allowblankpass = 1;
+					svr_opts->allowblankpass = 1;
 					break;
 				case 't':
-					svr_opts.multiauthmethod = 1;
+					svr_opts->multiauthmethod = 1;
 					break;
 #endif
 				case 'h':
@@ -327,7 +327,7 @@
 					exit(EXIT_SUCCESS);
 					break;
 				case 'z':
-					opts.disable_ip_tos = 1;
+					opts->disable_ip_tos = 1;
 					break;
 				default:
 					fprintf(stderr, "Invalid option -%c\n", c);
@@ -366,17 +366,17 @@
 	}
 
 	/* Set up listening ports */
-	if (svr_opts.portcount == 0) {
-		svr_opts.ports[0] = m_strdup(DROPBEAR_DEFPORT);
-		svr_opts.addresses[0] = m_strdup(DROPBEAR_DEFADDRESS);
-		svr_opts.portcount = 1;
+	if (svr_opts->portcount == 0) {
+		svr_opts->ports[0] = m_strdup(DROPBEAR_DEFPORT);
+		svr_opts->addresses[0] = m_strdup(DROPBEAR_DEFADDRESS);
+		svr_opts->portcount = 1;
 	}
 
-	if (svr_opts.bannerfile) {
+	if (svr_opts->bannerfile) {
 		struct stat buf;
-		if (stat(svr_opts.bannerfile, &buf) != 0) {
+		if (stat(svr_opts->bannerfile, &buf) != 0) {
 			dropbear_exit("Error opening banner file '%s'",
-					svr_opts.bannerfile);
+					svr_opts->bannerfile);
 		}
 		
 		if (buf.st_size > MAX_BANNER_SIZE) {
@@ -384,22 +384,22 @@
 					MAX_BANNER_SIZE);
 		}
 
-		svr_opts.banner = buf_new(buf.st_size);
-		if (buf_readfile(svr_opts.banner, svr_opts.bannerfile)!=DROPBEAR_SUCCESS) {
+		svr_opts->banner = buf_new(buf.st_size);
+		if (buf_readfile(svr_opts->banner, svr_opts->bannerfile)!=DROPBEAR_SUCCESS) {
 			dropbear_exit("Error reading banner file '%s'",
-					svr_opts.bannerfile);
+					svr_opts->bannerfile);
 		}
-		buf_setpos(svr_opts.banner, 0);
+		buf_setpos(svr_opts->banner, 0);
 	}
 
 #ifdef HAVE_GETGROUPLIST
-	if (svr_opts.restrict_group) {
-		struct group *restrictedgroup = getgrnam(svr_opts.restrict_group);
+	if (svr_opts->restrict_group) {
+		struct group *restrictedgroup = getgrnam(svr_opts->restrict_group);
 
 		if (restrictedgroup){
-			svr_opts.restrict_group_gid = restrictedgroup->gr_gid;
+			svr_opts->restrict_group_gid = restrictedgroup->gr_gid;
 		} else {
-			dropbear_exit("Cannot restrict logins to group '%s' as the group does not exist", svr_opts.restrict_group);
+			dropbear_exit("Cannot restrict logins to group '%s' as the group does not exist", svr_opts->restrict_group);
 		}
 	}
 #endif
@@ -414,7 +414,7 @@
 			|| val == 0) {
 			dropbear_exit("Bad maxauthtries '%s'", maxauthtries_arg);
 		}
-		svr_opts.maxauthtries = val;
+		svr_opts->maxauthtries = val;
 	}
 
 
@@ -423,7 +423,7 @@
 		if (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {
 			dropbear_exit("Bad keepalive '%s'", keepalive_arg);
 		}
-		opts.keepalive_secs = val;
+		opts->keepalive_secs = val;
 	}
 
 	if (idle_timeout_arg) {
@@ -431,23 +431,23 @@
 		if (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {
 			dropbear_exit("Bad idle_timeout '%s'", idle_timeout_arg);
 		}
-		opts.idle_timeout_secs = val;
+		opts->idle_timeout_secs = val;
 	}
 
-	if (svr_opts.forced_command) {
-		dropbear_log(LOG_INFO, "Forced command set to '%s'", svr_opts.forced_command);
+	if (svr_opts->forced_command) {
+		dropbear_log(LOG_INFO, "Forced command set to '%s'", svr_opts->forced_command);
 	}
 
 	if (reexec_fd_arg) {
-		if (m_str_to_uint(reexec_fd_arg, &svr_opts.reexec_childpipe) == DROPBEAR_FAILURE
-			|| svr_opts.reexec_childpipe < 0) {
+		if (m_str_to_uint(reexec_fd_arg, &svr_opts->reexec_childpipe) == DROPBEAR_FAILURE
+			|| svr_opts->reexec_childpipe < 0) {
 			dropbear_exit("Bad -2");
 		}
 	}
 
 #if INETD_MODE
-	if (svr_opts.inetdmode && (
-		opts.usingsyslog == 0
+	if (svr_opts->inetdmode && (
+		opts->usingsyslog == 0
 #if DEBUG_TRACE
 		|| debug_trace
 #endif
@@ -457,19 +457,19 @@
 	}
 #endif
 
-	if (svr_opts.multiauthmethod && svr_opts.noauthpass) {
+	if (svr_opts->multiauthmethod && svr_opts->noauthpass) {
 		dropbear_exit("-t and -s are incompatible");
 	}
 
 #if DROPBEAR_PLUGIN
 	if (pubkey_plugin) {
-		svr_opts.pubkey_plugin = m_strdup(pubkey_plugin);
-		char *args = strchr(svr_opts.pubkey_plugin, ',');
+		svr_opts->pubkey_plugin = m_strdup(pubkey_plugin);
+		char *args = strchr(svr_opts->pubkey_plugin, ',');
 		if (args) {
 			*args='\0';
 			++args;
 		}
-		svr_opts.pubkey_plugin_options = args;
+		svr_opts->pubkey_plugin_options = args;
 	}
 #endif
 }
@@ -477,7 +477,7 @@
 static void addportandaddress(const char* spec) {
 	char *port = NULL, *address = NULL;
 
-	if (svr_opts.portcount >= DROPBEAR_MAX_PORTS) {
+	if (svr_opts->portcount >= DROPBEAR_MAX_PORTS) {
 		return;
 	}
 
@@ -500,9 +500,9 @@
 		/* empty port -> exit */
 		dropbear_exit("Bad port");
 	}
-	svr_opts.ports[svr_opts.portcount] = port;
-	svr_opts.addresses[svr_opts.portcount] = address;
-	svr_opts.portcount++;
+	svr_opts->ports[svr_opts->portcount] = port;
+	svr_opts->addresses[svr_opts->portcount] = address;
+	svr_opts->portcount++;
 }
 
 static void disablekey(int type) {
@@ -534,7 +534,7 @@
 	char *expand_path = expand_homedir_path(keyfile);
 	enum signkey_type type = DROPBEAR_SIGNKEY_ANY;
 	if (readhostkey(expand_path, read_key, &type) == DROPBEAR_FAILURE) {
-		if (!svr_opts.delay_hostkey) {
+		if (!svr_opts->delay_hostkey) {
 			dropbear_log(LOG_WARNING, "Failed loading %s", expand_path);
 		}
 	}
@@ -542,37 +542,37 @@
 
 #if DROPBEAR_RSA
 	if (type == DROPBEAR_SIGNKEY_RSA) {
-		loadhostkey_helper("RSA", (void**)&read_key->rsakey, (void**)&svr_opts.hostkey->rsakey, fatal_duplicate);
+		loadhostkey_helper("RSA", (void**)&read_key->rsakey, (void**)&svr_opts->hostkey->rsakey, fatal_duplicate);
 	}
 #endif
 
 #if DROPBEAR_DSS
 	if (type == DROPBEAR_SIGNKEY_DSS) {
-		loadhostkey_helper("DSS", (void**)&read_key->dsskey, (void**)&svr_opts.hostkey->dsskey, fatal_duplicate);
+		loadhostkey_helper("DSS", (void**)&read_key->dsskey, (void**)&svr_opts->hostkey->dsskey, fatal_duplicate);
 	}
 #endif
 
 #if DROPBEAR_ECDSA
 #if DROPBEAR_ECC_256
 	if (type == DROPBEAR_SIGNKEY_ECDSA_NISTP256) {
-		loadhostkey_helper("ECDSA256", (void**)&read_key->ecckey256, (void**)&svr_opts.hostkey->ecckey256, fatal_duplicate);
+		loadhostkey_helper("ECDSA256", (void**)&read_key->ecckey256, (void**)&svr_opts->hostkey->ecckey256, fatal_duplicate);
 	}
 #endif
 #if DROPBEAR_ECC_384
 	if (type == DROPBEAR_SIGNKEY_ECDSA_NISTP384) {
-		loadhostkey_helper("ECDSA384", (void**)&read_key->ecckey384, (void**)&svr_opts.hostkey->ecckey384, fatal_duplicate);
+		loadhostkey_helper("ECDSA384", (void**)&read_key->ecckey384, (void**)&svr_opts->hostkey->ecckey384, fatal_duplicate);
 	}
 #endif
 #if DROPBEAR_ECC_521
 	if (type == DROPBEAR_SIGNKEY_ECDSA_NISTP521) {
-		loadhostkey_helper("ECDSA521", (void**)&read_key->ecckey521, (void**)&svr_opts.hostkey->ecckey521, fatal_duplicate);
+		loadhostkey_helper("ECDSA521", (void**)&read_key->ecckey521, (void**)&svr_opts->hostkey->ecckey521, fatal_duplicate);
 	}
 #endif
 #endif /* DROPBEAR_ECDSA */
 
 #if DROPBEAR_ED25519
 	if (type == DROPBEAR_SIGNKEY_ED25519) {
-		loadhostkey_helper("ed25519", (void**)&read_key->ed25519key, (void**)&svr_opts.hostkey->ed25519key, fatal_duplicate);
+		loadhostkey_helper("ed25519", (void**)&read_key->ed25519key, (void**)&svr_opts->hostkey->ed25519key, fatal_duplicate);
 	}
 #endif
 
@@ -581,11 +581,11 @@
 }
 
 static void addhostkey(const char *keyfile) {
-	if (svr_opts.num_hostkey_files >= MAX_HOSTKEYS) {
+	if (svr_opts->num_hostkey_files >= MAX_HOSTKEYS) {
 		dropbear_exit("Too many hostkeys");
 	}
-	svr_opts.hostkey_files[svr_opts.num_hostkey_files] = m_strdup(keyfile);
-	svr_opts.num_hostkey_files++;
+	svr_opts->hostkey_files[svr_opts->num_hostkey_files] = m_strdup(keyfile);
+	svr_opts->num_hostkey_files++;
 }
 
 
@@ -596,16 +596,16 @@
 	int loaded_any_ecdsa = 0;
 #endif
 
-	svr_opts.hostkey = new_sign_key();
+	svr_opts->hostkey = new_sign_key();
 
-	for (i = 0; i < svr_opts.num_hostkey_files; i++) {
-		char *hostkey_file = svr_opts.hostkey_files[i];
+	for (i = 0; i < svr_opts->num_hostkey_files; i++) {
+		char *hostkey_file = svr_opts->hostkey_files[i];
 		loadhostkey(hostkey_file, 1);
 		m_free(hostkey_file);
 	}
 
 	/* Only load default host keys if a host key is not specified by the user */
-	if (svr_opts.num_hostkey_files == 0) {
+	if (svr_opts->num_hostkey_files == 0) {
 #if DROPBEAR_RSA
 		loadhostkey(RSA_PRIV_FILENAME, 0);
 #endif
@@ -623,7 +623,7 @@
 	}
 
 #if DROPBEAR_RSA
-	if (!svr_opts.delay_hostkey && !svr_opts.hostkey->rsakey) {
+	if (!svr_opts->delay_hostkey && !svr_opts->hostkey->rsakey) {
 		disablekey(DROPBEAR_SIGNKEY_RSA);
 	} else {
 		any_keys = 1;
@@ -631,7 +631,7 @@
 #endif
 
 #if DROPBEAR_DSS
-	if (!svr_opts.delay_hostkey && !svr_opts.hostkey->dsskey) {
+	if (!svr_opts->delay_hostkey && !svr_opts->hostkey->dsskey) {
 		disablekey(DROPBEAR_SIGNKEY_DSS);
 	} else {
 		any_keys = 1;
@@ -648,43 +648,43 @@
 	loaded_any_ecdsa = 
 		0
 #if DROPBEAR_ECC_256
-		|| svr_opts.hostkey->ecckey256
+		|| svr_opts->hostkey->ecckey256
 #endif
 #if DROPBEAR_ECC_384
-		|| svr_opts.hostkey->ecckey384
+		|| svr_opts->hostkey->ecckey384
 #endif
 #if DROPBEAR_ECC_521
-		|| svr_opts.hostkey->ecckey521
+		|| svr_opts->hostkey->ecckey521
 #endif
 		;
 	any_keys |= loaded_any_ecdsa;
 
 	/* Or an ecdsa key could be generated at runtime */
-	any_keys |= svr_opts.delay_hostkey;
+	any_keys |= svr_opts->delay_hostkey;
 
 	/* At most one ecdsa key size will be left enabled */
 #if DROPBEAR_ECC_256
-	if (!svr_opts.hostkey->ecckey256
-		&& (!svr_opts.delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 256 )) {
+	if (!svr_opts->hostkey->ecckey256
+		&& (!svr_opts->delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 256 )) {
 		disablekey(DROPBEAR_SIGNKEY_ECDSA_NISTP256);
 	}
 #endif
 #if DROPBEAR_ECC_384
-	if (!svr_opts.hostkey->ecckey384
-		&& (!svr_opts.delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 384 )) {
+	if (!svr_opts->hostkey->ecckey384
+		&& (!svr_opts->delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 384 )) {
 		disablekey(DROPBEAR_SIGNKEY_ECDSA_NISTP384);
 	}
 #endif
 #if DROPBEAR_ECC_521
-	if (!svr_opts.hostkey->ecckey521
-		&& (!svr_opts.delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 521 )) {
+	if (!svr_opts->hostkey->ecckey521
+		&& (!svr_opts->delay_hostkey || loaded_any_ecdsa || ECDSA_DEFAULT_SIZE != 521 )) {
 		disablekey(DROPBEAR_SIGNKEY_ECDSA_NISTP521);
 	}
 #endif
 #endif /* DROPBEAR_ECDSA */
 
 #if DROPBEAR_ED25519
-	if (!svr_opts.delay_hostkey && !svr_opts.hostkey->ed25519key) {
+	if (!svr_opts->delay_hostkey && !svr_opts->hostkey->ed25519key) {
 		disablekey(DROPBEAR_SIGNKEY_ED25519);
 	} else {
 		any_keys = 1;
diff -aur dropbear-2022.83/svr-service.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-service.c
--- dropbear-2022.83/svr-service.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-service.c	2023-08-09 16:05:01.056015960 +0600
@@ -41,7 +41,7 @@
 
 	TRACE(("enter recv_msg_service_request"))
 
-	name = buf_getstring(ses.payload, &len);
+	name = buf_getstring(ses->payload, &len);
 
 	/* ssh-userauth */
 	if (len == SSH_SERVICE_USERAUTH_LEN && 
@@ -56,7 +56,7 @@
 	/* ssh-connection */
 	if (len == SSH_SERVICE_CONNECTION_LEN &&
 			(strncmp(SSH_SERVICE_CONNECTION, name, len) == 0)) {
-		if (ses.authstate.authdone != 1) {
+		if (ses->authstate.authdone != 1) {
 			dropbear_exit("Request for connection before auth");
 		}
 
@@ -79,8 +79,8 @@
 
 	CHECKCLEARTOWRITE();
 
-	buf_putbyte(ses.writepayload, SSH_MSG_SERVICE_ACCEPT);
-	buf_putstring(ses.writepayload, name, len);
+	buf_putbyte(ses->writepayload, SSH_MSG_SERVICE_ACCEPT);
+	buf_putstring(ses->writepayload, name, len);
 
 	encrypt_packet();
 
diff -aur dropbear-2022.83/svr-session.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-session.c
--- dropbear-2022.83/svr-session.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-session.c	2023-08-09 16:05:01.056015960 +0600
@@ -45,7 +45,7 @@
 static void svr_remoteclosed(void);
 static void svr_algos_initialise(void);
 
-struct serversession svr_ses; /* GLOBAL */
+struct serversession *svr_ses; /* GLOBAL */
 
 static const packettype svr_packettypes[] = {
 	{SSH_MSG_CHANNEL_DATA, recv_msg_channel_data},
@@ -84,20 +84,20 @@
 	/* free potential public key options */
 	svr_pubkey_options_cleanup();
 
-	m_free(svr_ses.addrstring);
-	m_free(svr_ses.remotehost);
-	m_free(svr_ses.childpids);
-	svr_ses.childpidsize = 0;
+	m_free(svr_ses->addrstring);
+	m_free(svr_ses->remotehost);
+	m_free(svr_ses->childpids);
+	svr_ses->childpidsize = 0;
 
 #if DROPBEAR_PLUGIN
-        if (svr_ses.plugin_handle != NULL) {
-            if (svr_ses.plugin_instance) {
-                svr_ses.plugin_instance->delete_plugin(svr_ses.plugin_instance);
-                svr_ses.plugin_instance = NULL;
+        if (svr_ses->plugin_handle != NULL) {
+            if (svr_ses->plugin_instance) {
+                svr_ses->plugin_instance->delete_plugin(svr_ses->plugin_instance);
+                svr_ses->plugin_instance = NULL;
             }
 
-            dlclose(svr_ses.plugin_handle);
-            svr_ses.plugin_handle = NULL;
+            dlclose(svr_ses->plugin_handle);
+            svr_ses->plugin_handle = NULL;
         }
 #endif
 }
@@ -109,24 +109,24 @@
 	common_session_init(sock, sock);
 
 	/* Initialise server specific parts of the session */
-	svr_ses.childpipe = childpipe;
+	svr_ses->childpipe = childpipe;
 #if DROPBEAR_VFORK
-	svr_ses.server_pid = getpid();
+	svr_ses->server_pid = getpid();
 #endif
 
 	/* for logging the remote address */
-	get_socket_address(ses.sock_in, NULL, NULL, &host, &port, 0);
+	get_socket_address(ses->sock_in, NULL, NULL, &host, &port, 0);
 	len = strlen(host) + strlen(port) + 2;
-	svr_ses.addrstring = m_malloc(len);
-	snprintf(svr_ses.addrstring, len, "%s:%s", host, port);
+	svr_ses->addrstring = m_malloc(len);
+	snprintf(svr_ses->addrstring, len, "%s:%s", host, port);
 	m_free(host);
 	m_free(port);
 
 #if DROPBEAR_PLUGIN
         /* Initializes the PLUGIN Plugin */
-        svr_ses.plugin_handle = NULL;
-        svr_ses.plugin_instance = NULL;
-        if (svr_opts.pubkey_plugin) {
+        svr_ses->plugin_handle = NULL;
+        svr_ses->plugin_instance = NULL;
+        if (svr_opts->pubkey_plugin) {
 #if DEBUG_TRACE
             const int verbose = debug_trace;
 #else
@@ -135,35 +135,35 @@
             PubkeyExtPlugin_newFn  pluginConstructor;
 
             /* RTLD_NOW: fails if not all the symbols are resolved now. Better fail now than at run-time */
-            svr_ses.plugin_handle = dlopen(svr_opts.pubkey_plugin, RTLD_NOW);
-            if (svr_ses.plugin_handle == NULL) {
-                dropbear_exit("failed to load external pubkey plugin '%s': %s", svr_opts.pubkey_plugin, dlerror());
+            svr_ses->plugin_handle = dlopen(svr_opts->pubkey_plugin, RTLD_NOW);
+            if (svr_ses->plugin_handle == NULL) {
+                dropbear_exit("failed to load external pubkey plugin '%s': %s", svr_opts->pubkey_plugin, dlerror());
             }
-            pluginConstructor = (PubkeyExtPlugin_newFn)dlsym(svr_ses.plugin_handle, DROPBEAR_PUBKEY_PLUGIN_FNNAME_NEW);
+            pluginConstructor = (PubkeyExtPlugin_newFn)dlsym(svr_ses->plugin_handle, DROPBEAR_PUBKEY_PLUGIN_FNNAME_NEW);
             if (!pluginConstructor) {
                 dropbear_exit("plugin constructor method not found in external pubkey plugin");
             }
 
             /* Create an instance of the plugin */
-            svr_ses.plugin_instance = pluginConstructor(verbose, svr_opts.pubkey_plugin_options, svr_ses.addrstring);
-            if (svr_ses.plugin_instance == NULL) {
+            svr_ses->plugin_instance = pluginConstructor(verbose, svr_opts->pubkey_plugin_options, svr_ses->addrstring);
+            if (svr_ses->plugin_instance == NULL) {
                 dropbear_exit("external plugin initialization failed");
             }
             /* Check if the plugin is compatible */
-            if ( (svr_ses.plugin_instance->api_version[0] != DROPBEAR_PLUGIN_VERSION_MAJOR) ||
-                 (svr_ses.plugin_instance->api_version[1] < DROPBEAR_PLUGIN_VERSION_MINOR) ) {
+            if ( (svr_ses->plugin_instance->api_version[0] != DROPBEAR_PLUGIN_VERSION_MAJOR) ||
+                 (svr_ses->plugin_instance->api_version[1] < DROPBEAR_PLUGIN_VERSION_MINOR) ) {
                 dropbear_exit("plugin version check failed: "
                               "Dropbear=%d.%d, plugin=%d.%d",
                         DROPBEAR_PLUGIN_VERSION_MAJOR, DROPBEAR_PLUGIN_VERSION_MINOR,
-                        svr_ses.plugin_instance->api_version[0], svr_ses.plugin_instance->api_version[1]);
+                        svr_ses->plugin_instance->api_version[0], svr_ses->plugin_instance->api_version[1]);
             }
-            if (svr_ses.plugin_instance->api_version[1] > DROPBEAR_PLUGIN_VERSION_MINOR) {
+            if (svr_ses->plugin_instance->api_version[1] > DROPBEAR_PLUGIN_VERSION_MINOR) {
                 dropbear_log(LOG_WARNING, "plugin API newer than dropbear API: "
                               "Dropbear=%d.%d, plugin=%d.%d",
                         DROPBEAR_PLUGIN_VERSION_MAJOR, DROPBEAR_PLUGIN_VERSION_MINOR,
-                        svr_ses.plugin_instance->api_version[0], svr_ses.plugin_instance->api_version[1]);
+                        svr_ses->plugin_instance->api_version[0], svr_ses->plugin_instance->api_version[1]);
             }
-            dropbear_log(LOG_INFO, "successfully loaded and initialized pubkey plugin '%s'", svr_opts.pubkey_plugin);
+            dropbear_log(LOG_INFO, "successfully loaded and initialized pubkey plugin '%s'", svr_opts->pubkey_plugin);
         }
 #endif
 
@@ -172,20 +172,20 @@
 	svr_chansessinitialise();
 	svr_algos_initialise();
 
-	get_socket_address(ses.sock_in, NULL, NULL, 
-			&svr_ses.remotehost, NULL, 1);
+	get_socket_address(ses->sock_in, NULL, NULL, 
+			&svr_ses->remotehost, NULL, 1);
 
 	/* set up messages etc */
-	ses.remoteclosed = svr_remoteclosed;
-	ses.extra_session_cleanup = svr_session_cleanup;
+	ses->remoteclosed = svr_remoteclosed;
+	ses->extra_session_cleanup = svr_session_cleanup;
 
 	/* packet handlers */
-	ses.packettypes = svr_packettypes;
+	ses->packettypes = svr_packettypes;
 
-	ses.isserver = 1;
+	ses->isserver = 1;
 
 	/* We're ready to go now */
-	ses.init_done = 1;
+	ses->init_done = 1;
 
 	/* exchange identification, version etc */
 	send_session_identification();
@@ -217,38 +217,38 @@
 	int add_delay = 0;
 
 #if DROPBEAR_PLUGIN
-	if ((ses.plugin_session != NULL)) {
-		svr_ses.plugin_instance->delete_session(ses.plugin_session);
+	if ((ses->plugin_session != NULL)) {
+		svr_ses->plugin_instance->delete_session(ses->plugin_session);
 	}
-	ses.plugin_session = NULL;
-	svr_opts.pubkey_plugin_options = NULL;
-	m_free(svr_opts.pubkey_plugin);
+	ses->plugin_session = NULL;
+	svr_opts->pubkey_plugin_options = NULL;
+	m_free(svr_opts->pubkey_plugin);
 #endif
 
 	/* Render the formatted exit message */
 	vsnprintf(exitmsg, sizeof(exitmsg), format, param);
 
-	/* svr_ses.addrstring may not be set for some early exits, or for
+	/* svr_ses->addrstring may not be set for some early exits, or for
 	the listener process */
 	fromaddr[0] = '\0';
-	if (svr_ses.addrstring) {
-	    snprintf(fromaddr, sizeof(fromaddr), " from <%s>", svr_ses.addrstring);
+	if (svr_ses->addrstring) {
+	    snprintf(fromaddr, sizeof(fromaddr), " from <%s>", svr_ses->addrstring);
     }
 
 	/* Add the prefix depending on session/auth state */
-	if (!ses.init_done) {
+	if (!ses->init_done) {
 		/* before session init */
 		snprintf(fullmsg, sizeof(fullmsg), "Early exit%s: %s", fromaddr, exitmsg);
-	} else if (ses.authstate.authdone) {
+	} else if (ses->authstate.authdone) {
 		/* user has authenticated */
 		snprintf(fullmsg, sizeof(fullmsg),
 				"Exit (%s)%s: %s", 
-				ses.authstate.pw_name, fromaddr, exitmsg);
-	} else if (ses.authstate.pw_name) {
+				ses->authstate.pw_name, fromaddr, exitmsg);
+	} else if (ses->authstate.pw_name) {
 		/* we have a potential user */
 		snprintf(fullmsg, sizeof(fullmsg), 
 				"Exit before auth%s: (user '%s', %u fails): %s",
-				fromaddr, ses.authstate.pw_name, ses.authstate.failcount, exitmsg);
+				fromaddr, ses->authstate.pw_name, ses->authstate.failcount, exitmsg);
 		add_delay = 1;
 	} else {
 		/* before userauth */
@@ -279,7 +279,7 @@
 #if DROPBEAR_VFORK
 	/* For uclinux only the main server process should cleanup - we don't want
 	 * forked children doing that */
-	if (svr_ses.server_pid == getpid())
+	if (svr_ses->server_pid == getpid())
 #endif
 	{
 		/* must be after we've done with username etc */
@@ -293,16 +293,20 @@
     }
 #endif
 
-	if (svr_opts.hostkey) {
-		sign_key_free(svr_opts.hostkey);
-		svr_opts.hostkey = NULL;
+	if (svr_opts->hostkey) {
+		sign_key_free(svr_opts->hostkey);
+		svr_opts->hostkey = NULL;
 	}
 	for (i = 0; i < DROPBEAR_MAX_PORTS; i++) {
-		m_free(svr_opts.addresses[i]);
-		m_free(svr_opts.ports[i]);
+		m_free(svr_opts->addresses[i]);
+		m_free(svr_opts->ports[i]);
 	}
 
     
+#ifdef DROPBEAR_EMBOX_BUILD
+    dropbear_embox_free_ses();
+#endif
+
 	exit(exitcode);
 
 }
@@ -318,7 +322,7 @@
 	vsnprintf(printbuf, sizeof(printbuf), format, param);
 
 #ifndef DISABLE_SYSLOG
-	if (opts.usingsyslog) {
+	if (opts->usingsyslog) {
 		syslog(priority, "%s", printbuf);
 	}
 #endif
@@ -329,7 +333,7 @@
 	havetrace = debug_trace;
 #endif
 
-	if (!opts.usingsyslog || havetrace) {
+	if (!opts->usingsyslog || havetrace) {
 		struct tm * local_tm = NULL;
 		timesec = time(NULL);
 		local_tm = localtime(&timesec);
@@ -347,12 +351,12 @@
 /* called when the remote side closes the connection */
 static void svr_remoteclosed() {
 
-	m_close(ses.sock_in);
-	if (ses.sock_in != ses.sock_out) {
-		m_close(ses.sock_out);
+	m_close(ses->sock_in);
+	if (ses->sock_in != ses->sock_out) {
+		m_close(ses->sock_out);
 	}
-	ses.sock_in = -1;
-	ses.sock_out = -1;
+	ses->sock_in = -1;
+	ses->sock_out = -1;
 	dropbear_close("Exited normally");
 
 }
diff -aur dropbear-2022.83/svr-tcpfwd.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-tcpfwd.c
--- dropbear-2022.83/svr-tcpfwd.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-tcpfwd.c	2023-08-09 16:05:01.060015893 +0600
@@ -43,8 +43,8 @@
 
 	TRACE(("recv_msg_global_request_remotetcp: remote tcp forwarding not compiled in"))
 
-	buf_eatstring(ses.payload);
-	wantreply = buf_getbool(ses.payload);
+	buf_eatstring(ses->payload);
+	wantreply = buf_getbool(ses->payload);
 	if (wantreply) {
 		send_msg_request_failure();
 	}
@@ -79,13 +79,13 @@
 
 	TRACE(("enter recv_msg_global_request_remotetcp"))
 
-	if (svr_opts.noremotetcp || !svr_pubkey_allows_tcpfwd()) {
+	if (svr_opts->noremotetcp || !svr_pubkey_allows_tcpfwd()) {
 		TRACE(("leave recv_msg_global_request_remotetcp: remote tcp forwarding disabled"))
 		goto out;
 	}
 
-	reqname = buf_getstring(ses.payload, &namelen);
-	wantreply = buf_getbool(ses.payload);
+	reqname = buf_getstring(ses->payload, &namelen);
+	wantreply = buf_getbool(ses->payload);
 
 	if (namelen > MAX_NAME_LEN) {
 		TRACE(("name len is wrong: %d", namelen))
@@ -98,8 +98,8 @@
 		/* client expects-port-number-to-make-use-of-server-allocated-ports */
 		if (DROPBEAR_SUCCESS == ret) {
 			CHECKCLEARTOWRITE();
-			buf_putbyte(ses.writepayload, SSH_MSG_REQUEST_SUCCESS);
-			buf_putint(ses.writepayload, allocated_listen_port);
+			buf_putbyte(ses->writepayload, SSH_MSG_REQUEST_SUCCESS);
+			buf_putint(ses->writepayload, allocated_listen_port);
 			encrypt_packet();
 			wantreply = 0; /* avoid out: below sending another reply */
 		}
@@ -144,13 +144,13 @@
 
 	TRACE(("enter cancelremotetcp"))
 
-	bindaddr = buf_getstring(ses.payload, &addrlen);
+	bindaddr = buf_getstring(ses->payload, &addrlen);
 	if (addrlen > MAX_HOST_LEN) {
 		TRACE(("addr len too long: %d", addrlen))
 		goto out;
 	}
 
-	port = buf_getint(ses.payload);
+	port = buf_getint(ses->payload);
 
 	tcpinfo.sendaddr = NULL;
 	tcpinfo.sendport = 0;
@@ -179,13 +179,13 @@
 
 	TRACE(("enter remotetcpreq"))
 
-	request_addr = buf_getstring(ses.payload, &addrlen);
+	request_addr = buf_getstring(ses->payload, &addrlen);
 	if (addrlen > MAX_HOST_LEN) {
 		TRACE(("addr len too long: %d", addrlen))
 		goto out;
 	}
 
-	port = buf_getint(ses.payload);
+	port = buf_getint(ses->payload);
 
 	if (port != 0) {
 		if (port < 1 || port > 65535) {
@@ -193,7 +193,7 @@
 			goto out;
 		}
 
-		if (!ses.allowprivport && port < IPPORT_RESERVED) {
+		if (!ses->allowprivport && port < IPPORT_RESERVED) {
 			TRACE(("can't assign port < 1024 for non-root"))
 			goto out;
 		}
@@ -207,7 +207,7 @@
 	tcpinfo->tcp_type = forwarded;
 
 	tcpinfo->request_listenaddr = request_addr;
-	if (!opts.listen_fwd_all || (strcmp(request_addr, "localhost") == 0) ) {
+	if (!opts->listen_fwd_all || (strcmp(request_addr, "localhost") == 0) ) {
 		/* NULL means "localhost only" */
 		tcpinfo->listenaddr = NULL;
 	}
@@ -262,26 +262,26 @@
 
 	TRACE(("newtcpdirect channel %d", channel->index))
 
-	if (svr_opts.nolocaltcp || !svr_pubkey_allows_tcpfwd()) {
+	if (svr_opts->nolocaltcp || !svr_pubkey_allows_tcpfwd()) {
 		TRACE(("leave newtcpdirect: local tcp forwarding disabled"))
 		goto out;
 	}
 
-	desthost = buf_getstring(ses.payload, &len);
+	desthost = buf_getstring(ses->payload, &len);
 	if (len > MAX_HOST_LEN) {
 		TRACE(("leave newtcpdirect: desthost too long"))
 		goto out;
 	}
 
-	destport = buf_getint(ses.payload);
+	destport = buf_getint(ses->payload);
 	
-	orighost = buf_getstring(ses.payload, &len);
+	orighost = buf_getstring(ses->payload, &len);
 	if (len > MAX_HOST_LEN) {
 		TRACE(("leave newtcpdirect: orighost too long"))
 		goto out;
 	}
 
-	origport = buf_getint(ses.payload);
+	origport = buf_getint(ses->payload);
 
 	/* best be sure */
 	if (origport > 65535 || destport > 65535) {
diff -aur dropbear-2022.83/svr-x11fwd.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-x11fwd.c
--- dropbear-2022.83/svr-x11fwd.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/svr-x11fwd.c	2023-08-09 16:05:01.060015893 +0600
@@ -75,10 +75,10 @@
 		return DROPBEAR_FAILURE;
 	}
 
-	chansess->x11singleconn = buf_getbool(ses.payload);
-	chansess->x11authprot = buf_getstring(ses.payload, NULL);
-	chansess->x11authcookie = buf_getstring(ses.payload, NULL);
-	chansess->x11screennum = buf_getint(ses.payload);
+	chansess->x11singleconn = buf_getbool(ses->payload);
+	chansess->x11authprot = buf_getstring(ses->payload, NULL);
+	chansess->x11authcookie = buf_getstring(ses->payload, NULL);
+	chansess->x11screennum = buf_getint(ses->payload);
 
 	if (xauth_valid_string(chansess->x11authprot) == DROPBEAR_FAILURE ||
 		xauth_valid_string(chansess->x11authcookie) == DROPBEAR_FAILURE) {
@@ -226,8 +226,8 @@
 
 	if (send_msg_channel_open_init(fd, &chan_x11) == DROPBEAR_SUCCESS) {
 		ipstring = inet_ntoa(addr->sin_addr);
-		buf_putstring(ses.writepayload, ipstring, strlen(ipstring));
-		buf_putint(ses.writepayload, addr->sin_port);
+		buf_putstring(ses->writepayload, ipstring, strlen(ipstring));
+		buf_putint(ses->writepayload, addr->sin_port);
 
 		encrypt_packet();
 		return DROPBEAR_SUCCESS;
diff -aur dropbear-2022.83/sysoptions.h ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/sysoptions.h
--- dropbear-2022.83/sysoptions.h	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/sysoptions.h	2023-08-09 16:05:01.060015893 +0600
@@ -32,6 +32,8 @@
 /* Would probably work on freebsd but hasn't been tested */
 #if defined(HAVE_FEXECVE) && DROPBEAR_REEXEC && defined(__linux__)
 #define DROPBEAR_DO_REEXEC 1
+#elif defined(DROPBEAR_EMBOX_BUILD)
+#define DROPBEAR_DO_REEXEC 1
 #else
 #define DROPBEAR_DO_REEXEC 0
 #endif
@@ -75,7 +77,11 @@
 /* Each port might have at least a v4 and a v6 address */
 #define MAX_LISTEN_ADDR (DROPBEAR_MAX_PORTS*3)
 
+#ifndef DROPBEAR_EMBOX_BUILD
 #define _PATH_TTY "/dev/tty"
+#else
+#define _PATH_TTY "/dev_pty_0"
+#endif
 
 #define _PATH_CP "/bin/cp"
 
@@ -213,7 +219,7 @@
 #define TRANS_MAX_WINDOW 500000000 /* 500MB is sufficient, stopping overflow */
 #define TRANS_MAX_WIN_INCR 500000000 /* overflow prevention */
 
-#define RECV_WINDOWEXTEND (opts.recv_window / 3) /* We send a "window extend" every
+#define RECV_WINDOWEXTEND (opts->recv_window / 3) /* We send a "window extend" every
 								RECV_WINDOWEXTEND bytes */
 #define MAX_RECV_WINDOW (10*1024*1024) /* 10 MB should be enough */
 
@@ -299,9 +305,13 @@
 
 /* Source for randomness. This must be able to provide hundreds of bytes per SSH
  * connection without blocking. */
+#ifndef DROPBEAR_EMBOX_BUILD
 #ifndef DROPBEAR_URANDOM_DEV
 #define DROPBEAR_URANDOM_DEV "/dev/urandom"
 #endif
+#else
+#define DROPBEAR_URANDOM_DEV "/etc/dropbear/random"
+#endif
 
 /* client keyboard interactive authentication is often used for password auth.
  rfc4256 */
@@ -311,8 +321,8 @@
  * code, if we're just compiling as client or server */
 #if (DROPBEAR_SERVER) && (DROPBEAR_CLIENT)
 
-#define IS_DROPBEAR_SERVER (ses.isserver == 1)
-#define IS_DROPBEAR_CLIENT (ses.isserver == 0)
+#define IS_DROPBEAR_SERVER (ses->isserver == 1)
+#define IS_DROPBEAR_CLIENT (ses->isserver == 0)
 
 #elif DROPBEAR_SERVER
 
diff -aur dropbear-2022.83/tcp-accept.c ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/tcp-accept.c
--- dropbear-2022.83/tcp-accept.c	2022-11-14 20:30:00.000000000 +0600
+++ ../build/extbld/third_party/dropbear/dropbear/dropbear-2022.83/tcp-accept.c	2023-08-09 16:05:01.060015893 +0600
@@ -87,13 +87,13 @@
 		if (addr == NULL) {
 			addr = "localhost";
 		}
-		buf_putstring(ses.writepayload, addr, strlen(addr));
-		buf_putint(ses.writepayload, port);
+		buf_putstring(ses->writepayload, addr, strlen(addr));
+		buf_putint(ses->writepayload, port);
 
 		/* originator ip */
-		buf_putstring(ses.writepayload, ipstring, strlen(ipstring));
+		buf_putstring(ses->writepayload, ipstring, strlen(ipstring));
 		/* originator port */
-		buf_putint(ses.writepayload, atol(portstring));
+		buf_putint(ses->writepayload, atol(portstring));
 
 		encrypt_packet();
 
@@ -117,7 +117,7 @@
 	snprintf(portstring, sizeof(portstring), "%u", tcpinfo->listenport);
 
 	nsocks = dropbear_listen(tcpinfo->listenaddr, portstring, socks, 
-			DROPBEAR_MAX_SOCKS, &errstring, &ses.maxfd);
+			DROPBEAR_MAX_SOCKS, &errstring, &ses->maxfd);
 	if (nsocks < 0) {
 		dropbear_log(LOG_INFO, "TCP forward failed: %s", errstring);
 		m_free(errstring);
